(defun thaw (V4413) (V4413))

(defun eval (V4414) (eval-kl (shen.shen->kl (shen.process-applications (macroexpand V4414) (shen.find-types V4414)))))

(defun external (V4415) (cond ((= null V4415) ()) (true (trap-error (get V4415 shen.external-symbols (value *property-vector*)) (lambda Z4416 (simple-error (cn "package " (shen.app V4415 " does not exist.
;" shen.a))))))))

(defun internal (V4417) (cond ((= null V4417) ()) (true (trap-error (get V4417 shen.internal-symbols (value *property-vector*)) (lambda Z4418 (simple-error (cn "package " (shen.app V4417 " does not exist.
;" shen.a))))))))

(defun fail-if (V4419 V4420) (if (V4419 V4420) (fail) V4420))

(defun @s (V4421 V4422) (cn V4421 V4422))

(defun tc? () (value shen.*tc*))

(defun ps (V4423) (trap-error (get V4423 shen.source (value *property-vector*)) (lambda Z4424 (simple-error (shen.app V4423 " not found.
" shen.a)))))

(defun stinput () (value *stinput*))

(defun vector (V4425) (let W4426 (absvector (+ V4425 1)) (let W4427 (address-> W4426 0 V4425) (let W4428 (if (= V4425 0) W4427 (shen.fillvector W4427 1 V4425 (fail))) W4428))))

(defun shen.fillvector (V4430 V4431 V4432 V4433) (cond ((= V4431 V4432) (address-> V4430 V4432 V4433)) (true (shen.fillvector (address-> V4430 V4431 V4433) (+ 1 V4431) V4432 V4433))))

(defun vector? (V4434) (and (absvector? V4434) (trap-error (>= (<-address V4434 0) 0) (lambda Z4435 false))))

(defun vector-> (V4436 V4437 V4438) (if (= V4437 0) (simple-error "cannot access 0th element of a vector
") (address-> V4436 V4437 V4438)))

(defun <-vector (V4439 V4440) (if (= V4440 0) (simple-error "cannot access 0th element of a vector
") (let W4441 (<-address V4439 V4440) (if (= W4441 (fail)) (simple-error "vector element not found
") W4441))))

(defun shen.posint? (V4442) (and (integer? V4442) (>= V4442 0)))

(defun limit (V4443) (<-address V4443 0))

(defun symbol? (V4444) (cond ((or (boolean? V4444) (or (number? V4444) (or (string? V4444) (or (cons? V4444) (or (empty? V4444) (vector? V4444)))))) false) ((element? V4444 (cons { (cons } (cons (intern ":") (cons (intern ";") (cons (intern ",") ())))))) true) (true (trap-error (let W4445 (str V4444) (shen.analyse-symbol? W4445)) (lambda Z4446 false)))))

(defun shen.analyse-symbol? (V4449) (cond ((shen.+string? V4449) (and (shen.alpha? (string->n (hdstr V4449))) (shen.alphanums? (tlstr V4449)))) (true (simple-error "implementation error in shen.analyse-symbol?"))))

(defun shen.alphanums? (V4452) (cond ((= "" V4452) true) ((shen.+string? V4452) (let W4453 (string->n (hdstr V4452)) (and (or (shen.alpha? W4453) (shen.digit? W4453)) (shen.alphanums? (tlstr V4452))))) (true (simple-error "implementation error in shen.alphanums?"))))

(defun variable? (V4454) (cond ((or (boolean? V4454) (or (number? V4454) (string? V4454))) false) (true (trap-error (let W4455 (str V4454) (shen.analyse-variable? W4455)) (lambda Z4456 false)))))

(defun shen.analyse-variable? (V4459) (cond ((shen.+string? V4459) (and (shen.uppercase? (string->n (hdstr V4459))) (shen.alphanums? (tlstr V4459)))) (true (simple-error "implementation error in shen.analyse-variable?"))))

(defun gensym (V4460) (concat V4460 (set shen.*gensym* (+ 1 (value shen.*gensym*)))))

(defun concat (V4461 V4462) (intern (cn (str V4461) (str V4462))))

(defun @p (V4463 V4464) (let W4465 (absvector 3) (let W4466 (address-> W4465 0 shen.tuple) (let W4467 (address-> W4465 1 V4463) (let W4468 (address-> W4465 2 V4464) W4465)))))

(defun fst (V4469) (<-address V4469 1))

(defun snd (V4470) (<-address V4470 2))

(defun tuple? (V4471) (trap-error (and (absvector? V4471) (= shen.tuple (<-address V4471 0))) (lambda Z4472 false)))

(defun append (V4477 V4478) (cond ((= () V4477) V4478) ((cons? V4477) (cons (hd V4477) (append (tl V4477) V4478))) (true (simple-error "attempt to append a non-list"))))

(defun @v (V4479 V4480) (let W4481 (limit V4480) (let W4482 (vector (+ W4481 1)) (let W4483 (vector-> W4482 1 V4479) (if (= W4481 0) W4483 (shen.@v-help V4480 1 W4481 W4483))))))

(defun shen.@v-help (V4485 V4486 V4487 V4488) (cond ((= V4486 V4487) (shen.copyfromvector V4485 V4488 V4487 (+ V4487 1))) (true (shen.@v-help V4485 (+ V4486 1) V4487 (shen.copyfromvector V4485 V4488 V4486 (+ V4486 1))))))

(defun shen.copyfromvector (V4489 V4490 V4491 V4492) (trap-error (vector-> V4490 V4492 (<-vector V4489 V4491)) (lambda Z4493 V4490)))

(defun hdv (V4494) (trap-error (<-vector V4494 1) (lambda Z4495 (simple-error "hdv needs a non-empty vector as an argument
"))))

(defun tlv (V4496) (let W4497 (limit V4496) (if (= W4497 0) (simple-error "cannot take the tail of the empty vector
") (if (= W4497 1) (vector 0) (let W4498 (vector (- W4497 1)) (shen.tlv-help V4496 2 W4497 (vector (- W4497 1))))))))

(defun shen.tlv-help (V4500 V4501 V4502 V4503) (cond ((= V4501 V4502) (shen.copyfromvector V4500 V4503 V4502 (- V4502 1))) (true (shen.tlv-help V4500 (+ V4501 1) V4502 (shen.copyfromvector V4500 V4503 V4501 (- V4501 1))))))

(defun assoc (V4515 V4516) (cond ((= () V4516) ()) ((and (cons? V4516) (and (cons? (hd V4516)) (= V4515 (hd (hd V4516))))) (hd V4516)) ((cons? V4516) (assoc V4515 (tl V4516))) (true (simple-error "attempt to search a non-list with assoc
"))))

(defun boolean? (V4519) (cond ((= true V4519) true) ((= false V4519) true) (true false)))

(defun nl (V4520) (cond ((= 0 V4520) 0) (true (do (pr "
" (stoutput)) (nl (- V4520 1))))))

(defun difference (V4527 V4528) (cond ((= () V4527) ()) ((cons? V4527) (if (element? (hd V4527) V4528) (difference (tl V4527) V4528) (cons (hd V4527) (difference (tl V4527) V4528)))) (true (simple-error "attempt to find the difference with a non-list
"))))

(defun do (V4529 V4530) V4530)

(defun element? (V4542 V4543) (cond ((= () V4543) false) ((and (cons? V4543) (= V4542 (hd V4543))) true) ((cons? V4543) (element? V4542 (tl V4543))) (true (simple-error "attempt to find an element in a non-list
"))))

(defun empty? (V4546) (cond ((= () V4546) true) (true false)))

(defun fix (V4547 V4548) (shen.fix-help V4547 V4548 (V4547 V4548)))

(defun shen.fix-help (V4554 V4555 V4556) (cond ((= V4555 V4556) V4556) (true (shen.fix-help V4554 V4556 (V4554 V4556)))))

(defun put (V4557 V4558 V4559 V4560) (let W4561 (hash V4557 (limit V4560)) (let W4562 (trap-error (<-vector V4560 W4561) (lambda Z4563 ())) (let W4564 (vector-> V4560 W4561 (shen.change-pointer-value V4557 V4558 V4559 W4562)) V4559))))

(defun unput (V4565 V4566 V4567) (let W4568 (hash V4565 (limit V4567)) (let W4569 (trap-error (<-vector V4567 W4568) (lambda Z4570 ())) (let W4571 (vector-> V4567 W4568 (shen.remove-pointer V4565 V4566 W4569)) V4565))))

(defun shen.remove-pointer (V4582 V4583 V4584) (cond ((= () V4584) ()) ((and (cons? V4584) (and (cons? (hd V4584)) (and (cons? (hd (hd V4584))) (and (cons? (tl (hd (hd V4584)))) (and (= () (tl (tl (hd (hd V4584))))) (and (= V4583 (hd (tl (hd (hd V4584))))) (= V4582 (hd (hd (hd V4584)))))))))) (tl V4584)) ((cons? V4584) (cons (hd V4584) (shen.remove-pointer V4582 V4583 (tl V4584)))) (true (simple-error "implementation error in shen.remove-pointer"))))

(defun shen.change-pointer-value (V4597 V4598 V4599 V4600) (cond ((= () V4600) (cons (cons (cons V4597 (cons V4598 ())) V4599) ())) ((and (cons? V4600) (and (cons? (hd V4600)) (and (cons? (hd (hd V4600))) (and (cons? (tl (hd (hd V4600)))) (and (= () (tl (tl (hd (hd V4600))))) (and (= V4598 (hd (tl (hd (hd V4600))))) (= V4597 (hd (hd (hd V4600)))))))))) (cons (cons (hd (hd V4600)) V4599) (tl V4600))) ((cons? V4600) (cons (hd V4600) (shen.change-pointer-value V4597 V4598 V4599 (tl V4600)))) (true (simple-error "implementation error in shen.change-pointer-value"))))

(defun get (V4601 V4602 V4603) (let W4604 (hash V4601 (limit V4603)) (let W4605 (trap-error (<-vector V4603 W4604) (lambda Z4606 (simple-error (shen.app V4601 (cn " has no attributes: " (shen.app V4602 "
" shen.s)) shen.a)))) (let W4607 (assoc (cons V4601 (cons V4602 ())) W4605) (if (empty? W4607) (simple-error (cn "attribute " (shen.app V4602 (cn " not found for " (shen.app V4601 "
" shen.s)) shen.s))) (tl W4607))))))

(defun hash (V4608 V4609) (let W4610 (shen.mod (shen.hashkey V4608) V4609) (if (= W4610 0) 1 W4610)))

(defun shen.hashkey (V4611) (let W4612 (map (lambda Z4613 (string->n Z4613)) (explode V4611)) (shen.prodbutzero W4612 1)))

(defun shen.prodbutzero (V4614 V4615) (cond ((= () V4614) V4615) ((and (cons? V4614) (= 0 (hd V4614))) (shen.prodbutzero (tl V4614) V4615)) ((cons? V4614) (if (> V4615 10000000000) (shen.prodbutzero (tl V4614) (+ V4615 (hd V4614))) (shen.prodbutzero (tl V4614) (* V4615 (hd V4614))))) (true (shen.f-error shen.prodbutzero))))

(defun shen.mod (V4616 V4617) (shen.modh V4616 (shen.multiples V4616 (cons V4617 ()))))

(defun shen.multiples (V4622 V4623) (cond ((and (cons? V4623) (> (hd V4623) V4622)) (tl V4623)) ((cons? V4623) (shen.multiples V4622 (cons (* 2 (hd V4623)) V4623))) (true (simple-error "implementation error in shen.multiples"))))

(defun shen.modh (V4630 V4631) (cond ((= 0 V4630) 0) ((= () V4631) V4630) ((and (cons? V4631) (> (hd V4631) V4630)) (if (empty? (tl V4631)) V4630 (shen.modh V4630 (tl V4631)))) ((cons? V4631) (shen.modh (- V4630 (hd V4631)) V4631)) (true (simple-error "implementation error in shen.modh"))))

(defun sum (V4634) (cond ((= () V4634) 0) ((cons? V4634) (+ (hd V4634) (sum (tl V4634)))) (true (simple-error "attempt to sum a non-list
"))))

(defun head (V4639) (cond ((cons? V4639) (hd V4639)) (true (simple-error "head expects a non-empty list
"))))

(defun tail (V4644) (cond ((cons? V4644) (tl V4644)) (true (simple-error "tail expects a non-empty list
"))))

(defun hdstr (V4645) (pos V4645 0))

(defun intersection (V4652 V4653) (cond ((= () V4652) ()) ((cons? V4652) (if (element? (hd V4652) V4653) (cons (hd V4652) (intersection (tl V4652) V4653)) (intersection (tl V4652) V4653))) (true (simple-error "attempt to find the intersection with a non-list
"))))

(defun reverse (V4654) (shen.reverse-help V4654 ()))

(defun shen.reverse-help (V4659 V4660) (cond ((= () V4659) V4660) ((cons? V4659) (shen.reverse-help (tl V4659) (cons (hd V4659) V4660))) (true (simple-error "attempt to reverse a non-list
"))))

(defun union (V4665 V4666) (cond ((= () V4665) V4666) ((cons? V4665) (if (element? (hd V4665) V4666) (union (tl V4665) V4666) (cons (hd V4665) (union (tl V4665) V4666)))) (true (simple-error "attempt to find the union with a non-list
"))))

(defun y-or-n? (V4667) (let W4668 (pr (shen.proc-nl V4667) (stoutput)) (let W4669 (pr " (y/n) " (stoutput)) (let W4670 (shen.app (read (stinput)) "" shen.s) (if (= "y" W4670) true (if (= "n" W4670) false (do (pr "please answer y or n
" (stoutput)) (y-or-n? V4667))))))))

(defun not (V4671) (if V4671 false true))

(defun abort () (simple-error ""))

(defun subst (V4677 V4678 V4679) (cond ((= V4678 V4679) V4677) ((cons? V4679) (cons (subst V4677 V4678 (hd V4679)) (subst V4677 V4678 (tl V4679)))) (true V4679)))

(defun explode (V4680) (shen.explode-h (shen.app V4680 "" shen.a)))

(defun shen.explode-h (V4683) (cond ((= "" V4683) ()) ((shen.+string? V4683) (cons (hdstr V4683) (shen.explode-h (tlstr V4683)))) (true (simple-error "implementation error in explode-h"))))

(defun cd (V4684) (set *home-directory* (if (= V4684 "") "" (shen.app V4684 "/" shen.a))))

(defun map (V4685 V4686) (shen.map-h V4685 V4686 ()))

(defun shen.map-h (V4687 V4688 V4689) (cond ((= () V4688) (reverse V4689)) ((cons? V4688) (shen.map-h V4687 (tl V4688) (cons (V4687 (hd V4688)) V4689))) (true (shen.f-error shen.map-h))))

(defun length (V4690) (shen.length-h V4690 0))

(defun shen.length-h (V4695 V4696) (cond ((= () V4695) V4696) (true (shen.length-h (tl V4695) (+ V4696 1)))))

(defun occurrences (V4702 V4703) (cond ((= V4702 V4703) 1) ((cons? V4703) (+ (occurrences V4702 (hd V4703)) (occurrences V4702 (tl V4703)))) (true 0)))

(defun nth (V4708 V4709) (cond ((and (= 1 V4708) (cons? V4709)) (hd V4709)) ((cons? V4709) (nth (- V4708 1) (tl V4709))) (true (simple-error (cn "nth applied to " (shen.app V4708 (cn ", " (shen.app V4709 "
" shen.a)) shen.a))))))

(defun integer? (V4710) (and (number? V4710) (let W4711 (shen.abs V4710) (shen.integer-test? W4711 (shen.magless W4711 1)))))

(defun shen.abs (V4712) (if (> V4712 0) V4712 (- 0 V4712)))

(defun shen.magless (V4713 V4714) (let W4715 (* V4714 2) (if (> W4715 V4713) V4714 (shen.magless V4713 W4715))))

(defun shen.integer-test? (V4719 V4720) (cond ((= 0 V4719) true) ((> 1 V4719) false) (true (let W4721 (- V4719 V4720) (if (> 0 W4721) (integer? V4719) (shen.integer-test? W4721 V4720))))))

(defun mapcan (V4728 V4729) (cond ((= () V4729) ()) ((cons? V4729) (append (V4728 (hd V4729)) (mapcan V4728 (tl V4729)))) (true (simple-error "attempt to mapcan over a non-list
"))))

(defun == (V4735 V4736) (cond ((= V4735 V4736) true) (true false)))

(defun bound? (V4737) (and (symbol? V4737) (let W4738 (trap-error (value V4737) (lambda Z4739 shen.this-symbol-is-unbound)) (if (= W4738 shen.this-symbol-is-unbound) false true))))

(defun shen.string->bytes (V4740) (cond ((= "" V4740) ()) (true (cons (string->n (pos V4740 0)) (shen.string->bytes (tlstr V4740))))))

(defun maxinferences (V4741) (set shen.*maxinferences* V4741))

(defun inferences () (value shen.*infs*))

(defun protect (V4742) V4742)

(defun stoutput () (value *stoutput*))

(defun string->symbol (V4743) (let W4744 (intern V4743) (if (symbol? W4744) W4744 (simple-error (cn "cannot intern " (shen.app V4743 " to a symbol" shen.s))))))

(defun optimise (V4747) (cond ((= + V4747) (set shen.*optimise* true)) ((= - V4747) (set shen.*optimise* false)) (true (simple-error "optimise expects a + or a -.
"))))

(defun os () (value *os*))

(defun language () (value *language*))

(defun version () (value *version*))

(defun port () (value *port*))

(defun porters () (value *porters*))

(defun implementation () (value *implementation*))

(defun release () (value *release*))

(defun package? (V4748) (cond ((= null V4748) true) (true (trap-error (do (external V4748) true) (lambda Z4749 false)))))

(defun fail () shen.fail!)(defun enable-type-theory (V4752) (cond ((= + V4752) (set shen.*shen-type-theory-enabled?* true)) ((= - V4752) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun tc (V4755) (cond ((= + V4755) (set shen.*tc* true)) ((= - V4755) (set shen.*tc* false)) (true (simple-error "tc expects a + or -"))))

(defun destroy (V4756) (do (shen.unassoc V4756 (value shen.*sigf*)) V4756))

(defun shen.unassoc (V4757 V4758) (let W4759 (assoc V4757 V4758) (let W4760 (remove W4759 V4758) (set shen.*sigf* W4760))))

(defun in-package (V4761) (if (package? V4761) (set shen.*package* V4761) (simple-error (cn "package " (shen.app V4761 " does not exist
" shen.a)))))

(defun write-to-file (V4762 V4763) (let W4764 (open V4762 out) (let W4765 (if (string? V4763) (shen.app V4763 "

" shen.a) (shen.app V4763 "

" shen.s)) (let W4766 (pr W4765 W4764) (let W4767 (close W4764) V4763)))))

(defun fresh () (shen.freshterm (gensym shen.t)))

(defun update-lambda-table (V4768 V4769) (let W4770 (put V4768 arity V4769 (value *property-vector*)) (let W4771 (shen.lambda-entry V4768) (let W4772 (set shen.*lambdatable* (cons W4771 (value shen.*lambdatable*))) V4768))))

(defun specialise (V4775 V4776) (cond ((= 0 V4776) (do (set shen.*special* (remove V4775 (value shen.*special*))) (do (set shen.*extraspecial* (remove V4775 (value shen.*extraspecial*))) V4775))) ((= 1 V4776) (do (set shen.*special* (adjoin V4775 (value shen.*special*))) (do (set shen.*extraspecial* (remove V4775 (value shen.*extraspecial*))) V4775))) ((= 2 V4776) (do (set shen.*special* (remove V4775 (value shen.*special*))) (do (set shen.*extraspecial* (adjoin V4775 (value shen.*extraspecial*))) V4775))) (true (simple-error "specialise requires values of 0, 1 or 2
"))))

