(defun cl.kl-to-lisp (V12294) (cl.kl-to-lisp-h () V12294))

(defun cl.kl-to-lisp-h (V12302 V12303) (cond ((= T (MEMBER V12303 V12302)) V12303) ((and (cons? V12303) (and (= type (hd V12303)) (and (cons? (tl V12303)) (and (cons? (tl (tl V12303))) (= () (tl (tl (tl V12303)))))))) (cl.kl-to-lisp-h V12302 (hd (tl V12303)))) ((and (cons? V12303) (and (= protect (hd V12303)) (and (cons? (tl V12303)) (= () (tl (tl V12303)))))) (cl.kl-to-lisp-h V12302 (hd (tl V12303)))) ((and (cons? V12303) (and (= lambda (hd V12303)) (and (cons? (tl V12303)) (and (cons? (tl (tl V12303))) (and (= () (tl (tl (tl V12303)))) (= (hd (tl V12303)) T)))))) (cl.kl-to-lisp-h V12302 (cl.rectify-t V12303))) ((and (cons? V12303) (and (= lambda (hd V12303)) (and (cons? (tl V12303)) (and (cons? (tl (tl V12303))) (= () (tl (tl (tl V12303)))))))) (cons FUNCTION (cons (cons LAMBDA (cons (cons (hd (tl V12303)) ()) (cons (cl.kl-to-lisp-h (cons (hd (tl V12303)) V12302) (hd (tl (tl V12303)))) ()))) ()))) ((and (cons? V12303) (and (= let (hd V12303)) (and (cons? (tl V12303)) (and (cons? (tl (tl V12303))) (and (cons? (tl (tl (tl V12303)))) (and (= () (tl (tl (tl (tl V12303))))) (= (hd (tl V12303)) T))))))) (cl.kl-to-lisp-h V12302 (cl.rectify-t V12303))) ((and (cons? V12303) (and (= let (hd V12303)) (and (cons? (tl V12303)) (and (cons? (tl (tl V12303))) (and (cons? (tl (tl (tl V12303)))) (= () (tl (tl (tl (tl V12303)))))))))) (cons LET (cons (cons (cons (hd (tl V12303)) (cons (cl.kl-to-lisp-h V12302 (hd (tl (tl V12303)))) ())) ()) (cons (cl.kl-to-lisp-h (cons (hd (tl V12303)) V12302) (hd (tl (tl (tl V12303))))) ())))) ((and (cons? V12303) (and (= defun (hd V12303)) (and (cons? (tl V12303)) (and (cons? (tl (tl V12303))) (and (cons? (tl (tl (tl V12303)))) (= () (tl (tl (tl (tl V12303)))))))))) (cons DEFUN (cons (hd (tl V12303)) (cons (hd (tl (tl V12303))) (cons (cl.kl-to-lisp-h (hd (tl (tl V12303))) (hd (tl (tl (tl V12303))))) ()))))) ((and (cons? V12303) (= cond (hd V12303))) (cons COND (CL.MAPCAR (lambda Z12304 (cl.cond-code V12302 Z12304)) (tl V12303)))) ((and (cons? V12303) (or (= T (MEMBER (hd V12303) V12302)) (cons? (hd V12303)))) (let W12305 (CL.MAPCAR (lambda Z12306 (cl.kl-to-lisp-h V12302 Z12306)) V12303) (cl.currylisp W12305))) ((and (cons? V12303) (cl.fastsymbol? (hd V12303))) (let W12307 (CL.MAPCAR (lambda Z12308 (cl.kl-to-lisp-h V12302 Z12308)) (tl V12303)) (let W12309 (cl.maplispsym (hd V12303)) (cl.optimise-application (cons W12309 W12307))))) ((or (number? V12303) (or (string? V12303) (empty? V12303))) V12303) (true (cons QUOTE (cons V12303 ())))))

(defun cl.rectify-t (V12310) (SUBST (GENSYM "x") T V12310))

(defun cl.currylisp (V12311) (cond ((and (cons? V12311) (and (cons? (tl V12311)) (cons? (tl (tl V12311))))) (cl.currylisp (cons (cons FUNCALL (cons (hd V12311) (cons (hd (tl V12311)) ()))) (tl (tl V12311))))) ((and (cons? V12311) (and (cons? (tl V12311)) (= () (tl (tl V12311))))) (cons FUNCALL V12311)) ((and (cons? V12311) (= () (tl V12311))) (cons FUNCALL V12311)) (true V12311)))

(defun cl.optimise-application (V12312) (cond ((and (cons? V12312) (and (= protect (hd V12312)) (and (cons? (tl V12312)) (= () (tl (tl V12312)))))) (cl.optimise-application (hd (tl V12312)))) ((and (cons? V12312) (and (= hd (hd V12312)) (and (cons? (tl V12312)) (= () (tl (tl V12312)))))) (cons CAR (cons (cl.optimise-application (hd (tl V12312))) ()))) ((and (cons? V12312) (and (= tl (hd V12312)) (and (cons? (tl V12312)) (= () (tl (tl V12312)))))) (cons CDR (cons (cl.optimise-application (hd (tl V12312))) ()))) ((and (cons? V12312) (and (= cons (hd V12312)) (and (cons? (tl V12312)) (and (cons? (tl (tl V12312))) (= () (tl (tl (tl V12312)))))))) (cons CONS (cons (cl.optimise-application (hd (tl V12312))) (cons (cl.optimise-application (hd (tl (tl V12312)))) ())))) ((and (cons? V12312) (and (= append (hd V12312)) (and (cons? (tl V12312)) (and (cons? (tl (tl V12312))) (= () (tl (tl (tl V12312)))))))) (cons APPEND (cons (cl.optimise-application (hd (tl V12312))) (cons (cl.optimise-application (hd (tl (tl V12312)))) ())))) ((and (cons? V12312) (and (= reverse (hd V12312)) (and (cons? (tl V12312)) (= () (tl (tl V12312)))))) (cons REVERSE (cons (cl.optimise-application (hd (tl V12312))) ()))) ((and (cons? V12312) (and (= length (hd V12312)) (and (cons? (tl V12312)) (= () (tl (tl V12312)))))) (cons CL.LIST-LENGTH (cons (cl.optimise-application (hd (tl V12312))) ()))) ((and (cons? V12312) (and (= if (hd V12312)) (and (cons? (tl V12312)) (and (cons? (tl (tl V12312))) (and (cons? (tl (tl (tl V12312)))) (= () (tl (tl (tl (tl V12312)))))))))) (cons IF (cons (cl.wrap (hd (tl V12312))) (cons (cl.optimise-application (hd (tl (tl V12312)))) (cons (cl.optimise-application (hd (tl (tl (tl V12312))))) ()))))) ((and (cons? V12312) (and (= value (hd V12312)) (and (cons? (tl V12312)) (and (cons? (hd (tl V12312))) (and (cons? (tl (hd (tl V12312)))) (and (= () (tl (tl (hd (tl V12312))))) (and (= () (tl (tl V12312))) (= (hd (hd (tl V12312))) QUOTE)))))))) (hd (tl (hd (tl V12312))))) ((and (cons? V12312) (and (= map (hd V12312)) (and (cons? (tl V12312)) (and (cons? (tl (tl V12312))) (= () (tl (tl (tl V12312)))))))) (cons CL.MAPCAR (tl V12312))) ((and (cons? V12312) (and (= + (hd V12312)) (and (cons? (tl V12312)) (and (= 1 (hd (tl V12312))) (and (cons? (tl (tl V12312))) (= () (tl (tl (tl V12312))))))))) (cons (intern "1+") (cons (cl.optimise-application (hd (tl (tl V12312)))) ()))) ((and (cons? V12312) (and (= + (hd V12312)) (and (cons? (tl V12312)) (and (cons? (tl (tl V12312))) (and (= 1 (hd (tl (tl V12312)))) (= () (tl (tl (tl V12312))))))))) (cons (intern "1+") (cons (cl.optimise-application (hd (tl V12312))) ()))) ((and (cons? V12312) (and (= - (hd V12312)) (and (cons? (tl V12312)) (and (cons? (tl (tl V12312))) (and (= 1 (hd (tl (tl V12312)))) (= () (tl (tl (tl V12312))))))))) (cons (intern "1-") (cons (cl.optimise-application (hd (tl V12312))) ()))) ((cons? V12312) (CL.MAPCAR (lambda Z12313 (cl.optimise-application Z12313)) V12312)) (true V12312)))

(defun cl.cond-code (V12318 V12319) (cond ((and (cons? V12319) (and (cons? (tl V12319)) (= () (tl (tl V12319))))) (let W12320 (cl.wrap (cl.kl-to-lisp-h V12318 (hd V12319))) (let W12321 (cl.kl-to-lisp-h V12318 (hd (tl V12319))) (cons W12320 (cons W12321 ()))))) (true (simple-error "implementation error in shen.cond-code"))))

(defun cl.wrap (V12322) (cond ((and (cons? V12322) (and (cons? (tl V12322)) (and (= true (hd (tl V12322))) (and (= () (tl (tl V12322))) (= (hd V12322) QUOTE))))) T) ((and (cons? V12322) (and (= cons? (hd V12322)) (and (cons? (tl V12322)) (= () (tl (tl V12322)))))) (cons CONSP (tl V12322))) ((and (cons? V12322) (and (= string? (hd V12322)) (and (cons? (tl V12322)) (= () (tl (tl V12322)))))) (cons STRINGP (tl V12322))) ((and (cons? V12322) (and (= number? (hd V12322)) (and (cons? (tl V12322)) (= () (tl (tl V12322)))))) (cons NUMBERP (tl V12322))) ((and (cons? V12322) (and (= empty? (hd V12322)) (and (cons? (tl V12322)) (= () (tl (tl V12322)))))) (cons NULL (tl V12322))) ((and (cons? V12322) (and (= and (hd V12322)) (and (cons? (tl V12322)) (and (cons? (tl (tl V12322))) (= () (tl (tl (tl V12322)))))))) (cons AND (cons (cl.wrap (hd (tl V12322))) (cons (cl.wrap (hd (tl (tl V12322)))) ())))) ((and (cons? V12322) (and (= or (hd V12322)) (and (cons? (tl V12322)) (and (cons? (tl (tl V12322))) (= () (tl (tl (tl V12322)))))))) (cons OR (cons (cl.wrap (hd (tl V12322))) (cons (cl.wrap (hd (tl (tl V12322)))) ())))) ((and (cons? V12322) (and (= not (hd V12322)) (and (cons? (tl V12322)) (= () (tl (tl V12322)))))) (cons NOT (cons (cl.wrap (hd (tl V12322))) ()))) ((and (cons? V12322) (and (= cl.equal? (hd V12322)) (and (cons? (tl V12322)) (and (cons? (tl (tl V12322))) (and (= () (hd (tl (tl V12322)))) (= () (tl (tl (tl V12322))))))))) (cons NULL (cons (hd (tl V12322)) ()))) ((and (cons? V12322) (and (= cl.equal? (hd V12322)) (and (cons? (tl V12322)) (and (= () (hd (tl V12322))) (and (cons? (tl (tl V12322))) (= () (tl (tl (tl V12322))))))))) (cons NULL (tl (tl V12322)))) ((and (cons? V12322) (and (= cl.equal? (hd V12322)) (and (cons? (tl V12322)) (and (cons? (tl (tl V12322))) (and (cons? (hd (tl (tl V12322)))) (and (cons? (tl (hd (tl (tl V12322))))) (and (= () (tl (tl (hd (tl (tl V12322)))))) (and (= () (tl (tl (tl V12322)))) (and (= (hd (hd (tl (tl V12322)))) QUOTE) (cl.fastsymbol? (hd (tl (hd (tl (tl V12322))))))))))))))) (cons EQ (tl V12322))) ((and (cons? V12322) (and (= cl.equal? (hd V12322)) (and (cons? (tl V12322)) (and (cons? (hd (tl V12322))) (and (cons? (tl (hd (tl V12322)))) (and (= () (tl (tl (hd (tl V12322))))) (and (cons? (tl (tl V12322))) (and (= () (tl (tl (tl V12322)))) (and (= (hd (hd (tl V12322))) QUOTE) (cl.fastsymbol? (hd (tl (hd (tl V12322)))))))))))))) (cons EQ (tl V12322))) ((and (cons? V12322) (and (= cl.equal? (hd V12322)) (and (cons? (tl V12322)) (and (cons? (hd (tl V12322))) (and (= fail (hd (hd (tl V12322)))) (and (= () (tl (hd (tl V12322)))) (and (cons? (tl (tl V12322))) (= () (tl (tl (tl V12322))))))))))) (cons EQ (tl V12322))) ((and (cons? V12322) (and (= cl.equal? (hd V12322)) (and (cons? (tl V12322)) (and (cons? (tl (tl V12322))) (and (cons? (hd (tl (tl V12322)))) (and (= fail (hd (hd (tl (tl V12322))))) (and (= () (tl (hd (tl (tl V12322))))) (= () (tl (tl (tl V12322))))))))))) (cons EQ (tl V12322))) ((and (cons? V12322) (and (= cl.equal? (hd V12322)) (and (cons? (tl V12322)) (and (cons? (tl (tl V12322))) (and (= () (tl (tl (tl V12322)))) (string? (hd (tl V12322)))))))) (cons EQUAL (tl V12322))) ((and (cons? V12322) (and (= cl.equal? (hd V12322)) (and (cons? (tl V12322)) (and (cons? (tl (tl V12322))) (and (= () (tl (tl (tl V12322)))) (string? (hd (tl (tl V12322))))))))) (cons EQUAL (tl V12322))) ((and (cons? V12322) (and (= cl.equal? (hd V12322)) (and (cons? (tl V12322)) (and (cons? (tl (tl V12322))) (and (= () (tl (tl (tl V12322)))) (number? (hd (tl V12322)))))))) (cons EQUALP (tl V12322))) ((and (cons? V12322) (and (= cl.equal? (hd V12322)) (and (cons? (tl V12322)) (and (cons? (tl (tl V12322))) (and (= () (tl (tl (tl V12322)))) (number? (hd (tl (tl V12322))))))))) (cons EQUALP (tl V12322))) ((and (cons? V12322) (and (= cl.equal? (hd V12322)) (and (cons? (tl V12322)) (and (cons? (tl (tl V12322))) (= () (tl (tl (tl V12322)))))))) (cons cl.ABSEQUAL (tl V12322))) ((and (cons? V12322) (and (= cl.greater? (hd V12322)) (and (cons? (tl V12322)) (and (cons? (tl (tl V12322))) (= () (tl (tl (tl V12322)))))))) (cons > (tl V12322))) ((and (cons? V12322) (and (= cl.greater-than-or-equal-to? (hd V12322)) (and (cons? (tl V12322)) (and (cons? (tl (tl V12322))) (= () (tl (tl (tl V12322)))))))) (cons >= (tl V12322))) ((and (cons? V12322) (and (= cl.less? (hd V12322)) (and (cons? (tl V12322)) (and (cons? (tl (tl V12322))) (= () (tl (tl (tl V12322)))))))) (cons < (tl V12322))) ((and (cons? V12322) (and (= cl.less-than-or-equal-to? (hd V12322)) (and (cons? (tl V12322)) (and (cons? (tl (tl V12322))) (= () (tl (tl (tl V12322)))))))) (cons <= (tl V12322))) (true (cons cl.wrapper (cons V12322 ())))))

(defun cl.fastsymbol? (V12329) (cond ((cons? V12329) false) ((= () V12329) false) ((string? V12329) false) ((number? V12329) false) (true true)))

(defun cl.wrapper (V12330) (cond ((= true V12330) T) ((= false V12330) ()) (true (simple-error "boolean expected"))))

(defun cl.maplispsym (V12331) (cond ((= = V12331) cl.equal?) ((= > V12331) cl.greater?) ((= < V12331) cl.less?) ((= >= V12331) cl.greater-than-or-equal-to?) ((= <= V12331) cl.less-than-or-equal-to?) ((= + V12331) cl.add) ((= - V12331) cl.subtract) ((= / V12331) cl.divide) ((= * V12331) cl.multiply) (true V12331)))

