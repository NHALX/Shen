(defun cl.kl-to-lisp (V10152) (cl.kl-to-lisp-h () V10152))

(defun cl.kl-to-lisp-h (V10160 V10161) (cond ((= T (MEMBER V10161 V10160)) V10161) ((and (cons? V10161) (and (= type (hd V10161)) (and (cons? (tl V10161)) (and (cons? (tl (tl V10161))) (= () (tl (tl (tl V10161)))))))) (cl.kl-to-lisp-h V10160 (hd (tl V10161)))) ((and (cons? V10161) (and (= protect (hd V10161)) (and (cons? (tl V10161)) (= () (tl (tl V10161)))))) (cl.kl-to-lisp-h V10160 (hd (tl V10161)))) ((and (cons? V10161) (and (= lambda (hd V10161)) (and (cons? (tl V10161)) (and (cons? (tl (tl V10161))) (and (= () (tl (tl (tl V10161)))) (= (hd (tl V10161)) T)))))) (cl.kl-to-lisp-h V10160 (cl.rectify-t V10161))) ((and (cons? V10161) (and (= lambda (hd V10161)) (and (cons? (tl V10161)) (and (cons? (tl (tl V10161))) (= () (tl (tl (tl V10161)))))))) (cons FUNCTION (cons (cons LAMBDA (cons (cons (hd (tl V10161)) ()) (cons (cl.kl-to-lisp-h (cons (hd (tl V10161)) V10160) (hd (tl (tl V10161)))) ()))) ()))) ((and (cons? V10161) (and (= let (hd V10161)) (and (cons? (tl V10161)) (and (cons? (tl (tl V10161))) (and (cons? (tl (tl (tl V10161)))) (and (= () (tl (tl (tl (tl V10161))))) (= (hd (tl V10161)) T))))))) (cl.kl-to-lisp-h V10160 (cl.rectify-t V10161))) ((and (cons? V10161) (and (= let (hd V10161)) (and (cons? (tl V10161)) (and (cons? (tl (tl V10161))) (and (cons? (tl (tl (tl V10161)))) (= () (tl (tl (tl (tl V10161)))))))))) (cons LET (cons (cons (cons (hd (tl V10161)) (cons (cl.kl-to-lisp-h V10160 (hd (tl (tl V10161)))) ())) ()) (cons (cl.kl-to-lisp-h (cons (hd (tl V10161)) V10160) (hd (tl (tl (tl V10161))))) ())))) ((and (cons? V10161) (and (= defun (hd V10161)) (and (cons? (tl V10161)) (and (cons? (tl (tl V10161))) (and (cons? (tl (tl (tl V10161)))) (= () (tl (tl (tl (tl V10161)))))))))) (cons DEFUN (cons (hd (tl V10161)) (cons (hd (tl (tl V10161))) (cons (cl.kl-to-lisp-h (hd (tl (tl V10161))) (hd (tl (tl (tl V10161))))) ()))))) ((and (cons? V10161) (= cond (hd V10161))) (cons COND (CL.MAPCAR (lambda C (cl.cond-code V10160 C)) (tl V10161)))) ((and (cons? V10161) (or (= T (MEMBER (hd V10161) V10160)) (cons? (hd V10161)))) (let Lisp (CL.MAPCAR (lambda Y (cl.kl-to-lisp-h V10160 Y)) V10161) (cl.currylisp Lisp))) ((and (cons? V10161) (cl.fastsymbol? (hd V10161))) (let LispX (CL.MAPCAR (lambda Y (cl.kl-to-lisp-h V10160 Y)) (tl V10161)) (let LispF (cl.maplispsym (hd V10161)) (cl.optimise-application (cons LispF LispX))))) ((or (number? V10161) (or (string? V10161) (empty? V10161))) V10161) (true (cons QUOTE (cons V10161 ())))))

(defun cl.rectify-t (V10162) (SUBST (GENSYM "x") T V10162))

(defun cl.currylisp (V10163) (cond ((and (cons? V10163) (and (cons? (tl V10163)) (cons? (tl (tl V10163))))) (cl.currylisp (cons (cons FUNCALL (cons (hd V10163) (cons (hd (tl V10163)) ()))) (tl (tl V10163))))) ((and (cons? V10163) (and (cons? (tl V10163)) (= () (tl (tl V10163))))) (cons FUNCALL V10163)) ((and (cons? V10163) (= () (tl V10163))) (cons FUNCALL V10163)) (true V10163)))

(defun cl.optimise-application (V10164) (cond ((and (cons? V10164) (and (= protect (hd V10164)) (and (cons? (tl V10164)) (= () (tl (tl V10164)))))) (cl.optimise-application (hd (tl V10164)))) ((and (cons? V10164) (and (= hd (hd V10164)) (and (cons? (tl V10164)) (= () (tl (tl V10164)))))) (cons CAR (cons (cl.optimise-application (hd (tl V10164))) ()))) ((and (cons? V10164) (and (= tl (hd V10164)) (and (cons? (tl V10164)) (= () (tl (tl V10164)))))) (cons CDR (cons (cl.optimise-application (hd (tl V10164))) ()))) ((and (cons? V10164) (and (= cons (hd V10164)) (and (cons? (tl V10164)) (and (cons? (tl (tl V10164))) (= () (tl (tl (tl V10164)))))))) (cons CONS (cons (cl.optimise-application (hd (tl V10164))) (cons (cl.optimise-application (hd (tl (tl V10164)))) ())))) ((and (cons? V10164) (and (= append (hd V10164)) (and (cons? (tl V10164)) (and (cons? (tl (tl V10164))) (= () (tl (tl (tl V10164)))))))) (cons APPEND (cons (cl.optimise-application (hd (tl V10164))) (cons (cl.optimise-application (hd (tl (tl V10164)))) ())))) ((and (cons? V10164) (and (= reverse (hd V10164)) (and (cons? (tl V10164)) (= () (tl (tl V10164)))))) (cons REVERSE (cons (cl.optimise-application (hd (tl V10164))) ()))) ((and (cons? V10164) (and (= length (hd V10164)) (and (cons? (tl V10164)) (= () (tl (tl V10164)))))) (cons CL.LIST-LENGTH (cons (cl.optimise-application (hd (tl V10164))) ()))) ((and (cons? V10164) (and (= if (hd V10164)) (and (cons? (tl V10164)) (and (cons? (tl (tl V10164))) (and (cons? (tl (tl (tl V10164)))) (= () (tl (tl (tl (tl V10164)))))))))) (cons IF (cons (cl.wrap (hd (tl V10164))) (cons (cl.optimise-application (hd (tl (tl V10164)))) (cons (cl.optimise-application (hd (tl (tl (tl V10164))))) ()))))) ((and (cons? V10164) (and (= value (hd V10164)) (and (cons? (tl V10164)) (and (cons? (hd (tl V10164))) (and (cons? (tl (hd (tl V10164)))) (and (= () (tl (tl (hd (tl V10164))))) (and (= () (tl (tl V10164))) (= (hd (hd (tl V10164))) QUOTE)))))))) (hd (tl (hd (tl V10164))))) ((and (cons? V10164) (and (= map (hd V10164)) (and (cons? (tl V10164)) (and (cons? (tl (tl V10164))) (= () (tl (tl (tl V10164)))))))) (cons CL.MAPCAR (tl V10164))) ((and (cons? V10164) (and (= + (hd V10164)) (and (cons? (tl V10164)) (and (= 1 (hd (tl V10164))) (and (cons? (tl (tl V10164))) (= () (tl (tl (tl V10164))))))))) (cons (intern "1+") (cons (cl.optimise-application (hd (tl (tl V10164)))) ()))) ((and (cons? V10164) (and (= + (hd V10164)) (and (cons? (tl V10164)) (and (cons? (tl (tl V10164))) (and (= 1 (hd (tl (tl V10164)))) (= () (tl (tl (tl V10164))))))))) (cons (intern "1+") (cons (cl.optimise-application (hd (tl V10164))) ()))) ((and (cons? V10164) (and (= - (hd V10164)) (and (cons? (tl V10164)) (and (cons? (tl (tl V10164))) (and (= 1 (hd (tl (tl V10164)))) (= () (tl (tl (tl V10164))))))))) (cons (intern "1-") (cons (cl.optimise-application (hd (tl V10164))) ()))) ((cons? V10164) (CL.MAPCAR (lambda Z (cl.optimise-application Z)) V10164)) (true V10164)))

(defun cl.cond-code (V10169 V10170) (cond ((and (cons? V10170) (and (cons? (tl V10170)) (= () (tl (tl V10170))))) (let LispTest (cl.wrap (cl.kl-to-lisp-h V10169 (hd V10170))) (let LispResult (cl.kl-to-lisp-h V10169 (hd (tl V10170))) (cons LispTest (cons LispResult ()))))) (true (simple-error "implementation error in shen.cond-code"))))

(defun cl.wrap (V10171) (cond ((and (cons? V10171) (and (cons? (tl V10171)) (and (= true (hd (tl V10171))) (and (= () (tl (tl V10171))) (= (hd V10171) QUOTE))))) T) ((and (cons? V10171) (and (= cons? (hd V10171)) (and (cons? (tl V10171)) (= () (tl (tl V10171)))))) (cons CONSP (tl V10171))) ((and (cons? V10171) (and (= string? (hd V10171)) (and (cons? (tl V10171)) (= () (tl (tl V10171)))))) (cons STRINGP (tl V10171))) ((and (cons? V10171) (and (= number? (hd V10171)) (and (cons? (tl V10171)) (= () (tl (tl V10171)))))) (cons NUMBERP (tl V10171))) ((and (cons? V10171) (and (= empty? (hd V10171)) (and (cons? (tl V10171)) (= () (tl (tl V10171)))))) (cons NULL (tl V10171))) ((and (cons? V10171) (and (= and (hd V10171)) (and (cons? (tl V10171)) (and (cons? (tl (tl V10171))) (= () (tl (tl (tl V10171)))))))) (cons AND (cons (cl.wrap (hd (tl V10171))) (cons (cl.wrap (hd (tl (tl V10171)))) ())))) ((and (cons? V10171) (and (= or (hd V10171)) (and (cons? (tl V10171)) (and (cons? (tl (tl V10171))) (= () (tl (tl (tl V10171)))))))) (cons OR (cons (cl.wrap (hd (tl V10171))) (cons (cl.wrap (hd (tl (tl V10171)))) ())))) ((and (cons? V10171) (and (= not (hd V10171)) (and (cons? (tl V10171)) (= () (tl (tl V10171)))))) (cons NOT (cons (cl.wrap (hd (tl V10171))) ()))) ((and (cons? V10171) (and (= cl.equal? (hd V10171)) (and (cons? (tl V10171)) (and (cons? (tl (tl V10171))) (and (= () (hd (tl (tl V10171)))) (= () (tl (tl (tl V10171))))))))) (cons NULL (cons (hd (tl V10171)) ()))) ((and (cons? V10171) (and (= cl.equal? (hd V10171)) (and (cons? (tl V10171)) (and (= () (hd (tl V10171))) (and (cons? (tl (tl V10171))) (= () (tl (tl (tl V10171))))))))) (cons NULL (tl (tl V10171)))) ((and (cons? V10171) (and (= cl.equal? (hd V10171)) (and (cons? (tl V10171)) (and (cons? (tl (tl V10171))) (and (cons? (hd (tl (tl V10171)))) (and (cons? (tl (hd (tl (tl V10171))))) (and (= () (tl (tl (hd (tl (tl V10171)))))) (and (= () (tl (tl (tl V10171)))) (and (= (hd (hd (tl (tl V10171)))) QUOTE) (cl.fastsymbol? (hd (tl (hd (tl (tl V10171))))))))))))))) (cons EQ (tl V10171))) ((and (cons? V10171) (and (= cl.equal? (hd V10171)) (and (cons? (tl V10171)) (and (cons? (hd (tl V10171))) (and (cons? (tl (hd (tl V10171)))) (and (= () (tl (tl (hd (tl V10171))))) (and (cons? (tl (tl V10171))) (and (= () (tl (tl (tl V10171)))) (and (= (hd (hd (tl V10171))) QUOTE) (cl.fastsymbol? (hd (tl (hd (tl V10171)))))))))))))) (cons EQ (tl V10171))) ((and (cons? V10171) (and (= cl.equal? (hd V10171)) (and (cons? (tl V10171)) (and (cons? (hd (tl V10171))) (and (= fail (hd (hd (tl V10171)))) (and (= () (tl (hd (tl V10171)))) (and (cons? (tl (tl V10171))) (= () (tl (tl (tl V10171))))))))))) (cons EQ (tl V10171))) ((and (cons? V10171) (and (= cl.equal? (hd V10171)) (and (cons? (tl V10171)) (and (cons? (tl (tl V10171))) (and (cons? (hd (tl (tl V10171)))) (and (= fail (hd (hd (tl (tl V10171))))) (and (= () (tl (hd (tl (tl V10171))))) (= () (tl (tl (tl V10171))))))))))) (cons EQ (tl V10171))) ((and (cons? V10171) (and (= cl.equal? (hd V10171)) (and (cons? (tl V10171)) (and (cons? (tl (tl V10171))) (and (= () (tl (tl (tl V10171)))) (string? (hd (tl V10171)))))))) (cons EQUAL (tl V10171))) ((and (cons? V10171) (and (= cl.equal? (hd V10171)) (and (cons? (tl V10171)) (and (cons? (tl (tl V10171))) (and (= () (tl (tl (tl V10171)))) (string? (hd (tl (tl V10171))))))))) (cons EQUAL (tl V10171))) ((and (cons? V10171) (and (= cl.equal? (hd V10171)) (and (cons? (tl V10171)) (and (cons? (tl (tl V10171))) (and (= () (tl (tl (tl V10171)))) (number? (hd (tl V10171)))))))) (cons EQUALP (tl V10171))) ((and (cons? V10171) (and (= cl.equal? (hd V10171)) (and (cons? (tl V10171)) (and (cons? (tl (tl V10171))) (and (= () (tl (tl (tl V10171)))) (number? (hd (tl (tl V10171))))))))) (cons EQUALP (tl V10171))) ((and (cons? V10171) (and (= cl.equal? (hd V10171)) (and (cons? (tl V10171)) (and (cons? (tl (tl V10171))) (= () (tl (tl (tl V10171)))))))) (cons cl.ABSEQUAL (tl V10171))) ((and (cons? V10171) (and (= cl.greater? (hd V10171)) (and (cons? (tl V10171)) (and (cons? (tl (tl V10171))) (= () (tl (tl (tl V10171)))))))) (cons > (tl V10171))) ((and (cons? V10171) (and (= cl.greater-than-or-equal-to? (hd V10171)) (and (cons? (tl V10171)) (and (cons? (tl (tl V10171))) (= () (tl (tl (tl V10171)))))))) (cons >= (tl V10171))) ((and (cons? V10171) (and (= cl.less? (hd V10171)) (and (cons? (tl V10171)) (and (cons? (tl (tl V10171))) (= () (tl (tl (tl V10171)))))))) (cons < (tl V10171))) ((and (cons? V10171) (and (= cl.less-than-or-equal-to? (hd V10171)) (and (cons? (tl V10171)) (and (cons? (tl (tl V10171))) (= () (tl (tl (tl V10171)))))))) (cons <= (tl V10171))) (true (cons cl.wrapper (cons V10171 ())))))

(defun cl.fastsymbol? (V10178) (cond ((cons? V10178) false) ((= () V10178) false) ((string? V10178) false) ((number? V10178) false) (true true)))

(defun cl.wrapper (V10179) (cond ((= true V10179) T) ((= false V10179) ()) (true (simple-error "boolean expected"))))

(defun cl.maplispsym (V10180) (cond ((= = V10180) cl.equal?) ((= > V10180) cl.greater?) ((= < V10180) cl.less?) ((= >= V10180) cl.greater-than-or-equal-to?) ((= <= V10180) cl.less-than-or-equal-to?) ((= + V10180) cl.add) ((= - V10180) cl.subtract) ((= / V10180) cl.divide) ((= * V10180) cl.multiply) (true V10180)))

