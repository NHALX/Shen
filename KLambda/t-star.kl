(defun shen.typecheck (V9572 V9573) (let Vs (shen.extract-vars V9573) (let A* (shen.rectify-type V9573) (let Curried (shen.curry V9572) (((((lambda V8938 (lambda L8939 (lambda K8940 (lambda C8941 (let Out (shen.newpv V8938) (shen.gc V8938 (do (shen.incinfs) (shen.insert-prolog-variables (receive (shen.deref Vs V8938)) (receive (shen.deref A* V8938)) Out V8938 L8939 K8940 (freeze (shen.toplevel-forms (receive (shen.deref Curried V8938)) Out V8938 L8939 K8940 (freeze (return Out V8938 L8939 K8940 C8941)))))))))))) (shen.reset-prolog-vector)) (@v true (@v 0 (vector 0)))) 0) (freeze true))))))

(defun shen.insert-prolog-variables (V9574 V9575 V9576 V9577 V9578 V9579 V9580) (let C8953 (if (shen.unlocked? V9578) (let Tm8954 (shen.lazyderef V9574 V9577) (if (= Tm8954 ()) (do (shen.incinfs) (is! V9575 V9576 V9577 V9578 V9579 V9580)) false)) false) (if (= C8953 false) (if (shen.unlocked? V9578) (let Tm8955 (shen.lazyderef V9574 V9577) (if (cons? Tm8955) (let V (hd Tm8955) (let Vs (tl Tm8955) (let X (shen.newpv V9577) (shen.gc V9577 (do (shen.incinfs) (shen.insert-prolog-variables Vs (subst (shen.deref X V9577) V V9575) V9576 V9577 V9578 V9579 V9580)))))) false)) false) C8953)))

(defun shen.toplevel-forms (V9581 V9582 V9583 V9584 V9585 V9586) (let K8960 (+ V9585 1) (let C8964 (if (shen.unlocked? V9584) (let Tm8965 (shen.lazyderef V9581 V9583) (if (cons? Tm8965) (let Tm8966 (shen.lazyderef (hd Tm8965) V9583) (if (= Tm8966 define) (let Tm8967 (shen.lazyderef (tl Tm8965) V9583) (if (cons? Tm8967) (let F (hd Tm8967) (let X (tl Tm8967) (do (shen.incinfs) (when (shen.type-theory-enabled?) V9583 V9584 K8960 (freeze (shen.cut V9583 V9584 K8960 (freeze (shen.signal-def (value shen.*spy*) F V9583 V9584 K8960 (freeze (shen.t* (cons define (cons F X)) V9582 V9583 V9584 K8960 V9586)))))))))) false)) false)) false)) false) (if (= C8964 false) (let C8968 (if (shen.unlocked? V9584) (do (shen.incinfs) (shen.system-S (cons V9581 (cons (intern ":") (cons V9582 ()))) () V9583 V9584 K8960 V9586)) false) (if (= C8968 false) (shen.unlock V9584 K8960) C8968)) C8964))))

(defun shen.signal-def (V9587 V9588 V9589 V9590 V9591 V9592) (let C8977 (if (shen.unlocked? V9590) (let Tm8978 (shen.lazyderef V9587 V9589) (if (= Tm8978 false) (do (shen.incinfs) (thaw V9592)) false)) false) (if (= C8977 false) (if (shen.unlocked? V9590) (let Tm8979 (shen.lazyderef V9587 V9589) (if (= Tm8979 true) (let ShowF (shen.newpv V9589) (shen.gc V9589 (do (shen.incinfs) (is ShowF (pr (cn "
typechecking (fn " (shen.app (shen.deref V9588 V9589) ")
" shen.a)) (stoutput)) V9589 V9590 V9591 V9592)))) false)) false) C8977)))

(defun shen.rectify-type (V9593) (shen.demodulate (shen.curry-type V9593)))

(defun shen.demodulate (V9594) (trap-error (let Demod (shen.walk (lambda Y (shen.demod Y)) V9594) (if (= Demod V9594) V9594 (shen.demodulate Demod))) (lambda E V9594)))

(defun shen.curry-type (V9595) (cond ((and (cons? V9595) (and (cons? (tl V9595)) (and (= --> (hd (tl V9595))) (and (cons? (tl (tl V9595))) (and (cons? (tl (tl (tl V9595)))) (= --> (hd (tl (tl (tl V9595)))))))))) (shen.curry-type (cons (hd V9595) (cons --> (cons (tl (tl V9595)) ()))))) ((and (cons? V9595) (and (cons? (tl V9595)) (and (= ==> (hd (tl V9595))) (and (cons? (tl (tl V9595))) (= () (tl (tl (tl V9595)))))))) (shen.curry-type (cons (cons (hd V9595) (cons * (cons A ()))) (cons --> (cons (cons (cons vector (cons boolean ())) (cons --> (cons (cons (hd V9595) (cons * (tl (tl V9595)))) ()))) ()))))) ((and (cons? V9595) (and (cons? (tl V9595)) (and (= * (hd (tl V9595))) (and (cons? (tl (tl V9595))) (and (cons? (tl (tl (tl V9595)))) (= * (hd (tl (tl (tl V9595)))))))))) (shen.curry-type (cons (hd V9595) (cons * (cons (tl (tl V9595)) ()))))) ((cons? V9595) (map (lambda Z (shen.curry-type Z)) V9595)) (true V9595)))

(defun shen.curry (V9596) (cond ((and (cons? V9596) (and (= define (hd V9596)) (cons? (tl V9596)))) V9596) ((and (cons? V9596) (and (= type (hd V9596)) (and (cons? (tl V9596)) (and (cons? (tl (tl V9596))) (= () (tl (tl (tl V9596)))))))) (cons type (cons (shen.curry (hd (tl V9596))) (tl (tl V9596))))) ((and (cons? V9596) (and (= input+ (hd V9596)) (and (cons? (tl V9596)) (and (cons? (tl (tl V9596))) (= () (tl (tl (tl V9596)))))))) (cons input+ (cons (hd (tl V9596)) (cons (shen.curry (hd (tl (tl V9596)))) ())))) ((and (cons? V9596) (shen.special? (hd V9596))) (cons (hd V9596) (map (lambda Y (shen.curry Y)) (tl V9596)))) ((and (cons? V9596) (shen.extraspecial? (hd V9596))) V9596) ((and (cons? V9596) (and (cons? (tl V9596)) (cons? (tl (tl V9596))))) (shen.curry (cons (cons (hd V9596) (cons (hd (tl V9596)) ())) (tl (tl V9596))))) ((and (cons? V9596) (and (cons? (tl V9596)) (= () (tl (tl V9596))))) (cons (shen.curry (hd V9596)) (cons (shen.curry (hd (tl V9596))) ()))) (true V9596)))

(defun shen.special? (V9597) (element? V9597 (value shen.*special*)))

(defun shen.extraspecial? (V9598) (element? V9598 (value shen.*extraspecial*)))

(defun shen.system-S (V9599 V9600 V9601 V9602 V9603 V9604) (let K8984 (+ V9603 1) (let C8988 (if (shen.unlocked? V9602) (do (shen.incinfs) (when (shen.maxinfexceeded?) V9601 V9602 K8984 V9604)) false) (if (= C8988 false) (let C8989 (if (shen.unlocked? V9602) (let Tm8990 (shen.lazyderef V9599 V9601) (if (cons? Tm8990) (let X (hd Tm8990) (let Tm8991 (shen.lazyderef (tl Tm8990) V9601) (if (cons? Tm8991) (let Colon (hd Tm8991) (let Tm8992 (shen.lazyderef (tl Tm8991) V9601) (if (cons? Tm8992) (let A (hd Tm8992) (let Tm8993 (shen.lazyderef (tl Tm8992) V9601) (if (= Tm8993 ()) (do (shen.incinfs) (when (= (shen.deref Colon V9601) (intern ":")) V9601 V9602 K8984 (freeze (when (shen.type-theory-enabled?) V9601 V9602 K8984 (freeze (shen.cut V9601 V9602 K8984 (freeze (shen.system-S-h X A V9600 V9601 V9602 K8984 V9604)))))))) false))) false))) false))) false)) false) (if (= C8989 false) (let C8994 (if (shen.unlocked? V9602) (do (shen.incinfs) (when (value shen.*spy*) V9601 V9602 K8984 (freeze (shen.show V9599 V9600 V9601 V9602 K8984 V9604)))) false) (if (= C8994 false) (let C8995 (if (shen.unlocked? V9602) (do (shen.incinfs) (shen.search-user-datatypes V9599 V9600 (value shen.*datatypes*) V9601 V9602 K8984 V9604)) false) (if (= C8995 false) (shen.unlock V9602 K8984) C8995)) C8994)) C8989)) C8988))))

(defun shen.show (V9611 V9612 V9613 V9614 V9615 V9616) (do (shen.line) (do (shen.show-p (shen.deref V9611 V9613)) (do (nl 2) (do (shen.show-assumptions (shen.deref V9612 V9613) 1) (do (shen.pause-for-user) false))))))

(defun shen.line () (let Infs (inferences) (pr (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V9617) (cond ((and (cons? V9617) (and (cons? (tl V9617)) (and (cons? (tl (tl V9617))) (and (= () (tl (tl (tl V9617)))) (= (hd (tl V9617)) (intern ":")))))) (do (shen.prterm (hd V9617)) (do (pr " : " (stoutput)) (pr (shen.app (hd (tl (tl V9617))) "" shen.r) (stoutput))))) (true (shen.prterm V9617))))

(defun shen.prterm (V9618) (cond ((and (cons? V9618) (and (= cons (hd V9618)) (and (cons? (tl V9618)) (and (cons? (tl (tl V9618))) (= () (tl (tl (tl V9618)))))))) (do (pr "[" (stoutput)) (do (shen.prterm (hd (tl V9618))) (do (shen.prtl (hd (tl (tl V9618)))) (pr "]" (stoutput)))))) ((cons? V9618) (do (pr "(" (stoutput)) (do (shen.prterm (hd V9618)) (do (map (lambda Y (do (pr " " (stoutput)) (shen.prterm Y))) (tl V9618)) (pr ")" (stoutput)))))) (true (print V9618))))

(defun shen.prtl (V9619) (cond ((= () V9619) "") ((and (cons? V9619) (and (= cons (hd V9619)) (and (cons? (tl V9619)) (and (cons? (tl (tl V9619))) (= () (tl (tl (tl V9619)))))))) (do (pr " " (stoutput)) (do (shen.prterm (hd (tl V9619))) (shen.prtl (hd (tl (tl V9619))))))) (true (do (pr " | " (stoutput)) (shen.prterm V9619)))))

(defun shen.show-assumptions (V9626 V9627) (cond ((= () V9626) (pr "
> " (stoutput))) ((cons? V9626) (do (pr (shen.app V9627 ". " shen.a) (stoutput)) (do (shen.show-p (hd V9626)) (do (nl 1) (shen.show-assumptions (tl V9626) (+ V9627 1)))))) (true (simple-error "implementation error in shen.show-assumptions"))))

(defun shen.pause-for-user () (let Byte (read-byte (stinput)) (if (= Byte 94) (simple-error "input aborted
") (nl 1))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun shen.maxinfexceeded? () (if (> (inferences) (value shen.*maxinferences*)) (simple-error "maximum inferences exceeded") false))

(defun shen.system-S-h (V9628 V9629 V9630 V9631 V9632 V9633 V9634) (let K9002 (+ V9633 1) (let C9007 (if (shen.unlocked? V9632) (do (shen.incinfs) (when (value shen.*spy*) V9631 V9632 K9002 (freeze (shen.show (cons V9628 (cons (intern ":") (cons V9629 ()))) V9630 V9631 V9632 K9002 V9634)))) false) (if (= C9007 false) (let C9008 (if (shen.unlocked? V9632) (do (shen.incinfs) (when (not (cons? (shen.lazyderef V9628 V9631))) V9631 V9632 K9002 (freeze (shen.primitive V9628 V9629 V9631 V9632 K9002 V9634)))) false) (if (= C9008 false) (let C9009 (if (shen.unlocked? V9632) (do (shen.incinfs) (shen.by-hypothesis V9628 V9629 V9630 V9631 V9632 K9002 V9634)) false) (if (= C9009 false) (let C9010 (if (shen.unlocked? V9632) (let Tm9011 (shen.lazyderef V9628 V9631) (if (cons? Tm9011) (let F (hd Tm9011) (let Tm9012 (shen.lazyderef (tl Tm9011) V9631) (if (= Tm9012 ()) (do (shen.incinfs) (shen.lookupsig F (cons --> (cons V9629 ())) V9631 V9632 K9002 V9634)) false))) false)) false) (if (= C9010 false) (let C9013 (if (shen.unlocked? V9632) (let Tm9014 (shen.lazyderef V9628 V9631) (if (cons? Tm9014) (let Tm9015 (shen.lazyderef (hd Tm9014) V9631) (if (= Tm9015 fn) (let Tm9016 (shen.lazyderef (tl Tm9014) V9631) (if (cons? Tm9016) (let F (hd Tm9016) (let Tm9017 (shen.lazyderef (tl Tm9016) V9631) (if (= Tm9017 ()) (do (shen.incinfs) (shen.lookupsig F V9629 V9631 V9632 K9002 V9634)) false))) false)) false)) false)) false) (if (= C9013 false) (let C9018 (if (shen.unlocked? V9632) (let Tm9019 (shen.lazyderef V9628 V9631) (if (cons? Tm9019) (let F (hd Tm9019) (let Tm9020 (shen.lazyderef (tl Tm9019) V9631) (if (cons? Tm9020) (let X (hd Tm9020) (let Tm9021 (shen.lazyderef (tl Tm9020) V9631) (if (= Tm9021 ()) (let B (shen.newpv V9631) (shen.gc V9631 (do (shen.incinfs) (when (not (cons? (shen.lazyderef F V9631))) V9631 V9632 K9002 (freeze (shen.lookupsig F (cons B (cons --> (cons V9629 ()))) V9631 V9632 K9002 (freeze (shen.system-S-h X B V9630 V9631 V9632 K9002 V9634)))))))) false))) false))) false)) false) (if (= C9018 false) (let C9022 (if (shen.unlocked? V9632) (let Tm9023 (shen.lazyderef V9628 V9631) (if (cons? Tm9023) (let F (hd Tm9023) (let Tm9024 (shen.lazyderef (tl Tm9023) V9631) (if (cons? Tm9024) (let X (hd Tm9024) (let Tm9025 (shen.lazyderef (tl Tm9024) V9631) (if (= Tm9025 ()) (let B (shen.newpv V9631) (shen.gc V9631 (do (shen.incinfs) (shen.system-S-h F (cons B (cons --> (cons V9629 ()))) V9630 V9631 V9632 K9002 (freeze (shen.system-S-h X B V9630 V9631 V9632 K9002 V9634)))))) false))) false))) false)) false) (if (= C9022 false) (let C9026 (if (shen.unlocked? V9632) (let Tm9027 (shen.lazyderef V9628 V9631) (if (cons? Tm9027) (let Tm9028 (shen.lazyderef (hd Tm9027) V9631) (if (= Tm9028 cons) (let Tm9029 (shen.lazyderef (tl Tm9027) V9631) (if (cons? Tm9029) (let X (hd Tm9029) (let Tm9030 (shen.lazyderef (tl Tm9029) V9631) (if (cons? Tm9030) (let Y (hd Tm9030) (let Tm9031 (shen.lazyderef (tl Tm9030) V9631) (if (= Tm9031 ()) (let Tm9032 (shen.lazyderef V9629 V9631) (let GoTo9033 (lambda A (do (shen.incinfs) (shen.system-S-h X A V9630 V9631 V9632 K9002 (freeze (shen.system-S-h Y (cons list (cons A ())) V9630 V9631 V9632 K9002 V9634))))) (if (cons? Tm9032) (let Tm9034 (shen.lazyderef (hd Tm9032) V9631) (let GoTo9035 (freeze (let Tm9036 (shen.lazyderef (tl Tm9032) V9631) (let GoTo9037 (lambda A (GoTo9033 A)) (if (cons? Tm9036) (let A (hd Tm9036) (let Tm9038 (shen.lazyderef (tl Tm9036) V9631) (let GoTo9039 (freeze (GoTo9037 A)) (if (= Tm9038 ()) (thaw GoTo9039) (if (shen.pvar? Tm9038) (shen.bind! Tm9038 () V9631 GoTo9039) false))))) (if (shen.pvar? Tm9036) (let A (shen.newpv V9631) (shen.gc V9631 (shen.bind! Tm9036 (cons A ()) V9631 (freeze (GoTo9037 A))))) false))))) (if (= Tm9034 list) (thaw GoTo9035) (if (shen.pvar? Tm9034) (shen.bind! Tm9034 list V9631 GoTo9035) false)))) (if (shen.pvar? Tm9032) (let A (shen.newpv V9631) (shen.gc V9631 (shen.bind! Tm9032 (cons list (cons A ())) V9631 (freeze (GoTo9033 A))))) false)))) false))) false))) false)) false)) false)) false) (if (= C9026 false) (let C9040 (if (shen.unlocked? V9632) (let Tm9041 (shen.lazyderef V9628 V9631) (if (cons? Tm9041) (let Tm9042 (shen.lazyderef (hd Tm9041) V9631) (if (= Tm9042 @p) (let Tm9043 (shen.lazyderef (tl Tm9041) V9631) (if (cons? Tm9043) (let X (hd Tm9043) (let Tm9044 (shen.lazyderef (tl Tm9043) V9631) (if (cons? Tm9044) (let Y (hd Tm9044) (let Tm9045 (shen.lazyderef (tl Tm9044) V9631) (if (= Tm9045 ()) (let Tm9046 (shen.lazyderef V9629 V9631) (let GoTo9047 (lambda A (lambda B (do (shen.incinfs) (shen.system-S-h X A V9630 V9631 V9632 K9002 (freeze (shen.system-S-h Y B V9630 V9631 V9632 K9002 V9634)))))) (if (cons? Tm9046) (let A (hd Tm9046) (let Tm9048 (shen.lazyderef (tl Tm9046) V9631) (let GoTo9049 (lambda B ((GoTo9047 A) B)) (if (cons? Tm9048) (let Tm9050 (shen.lazyderef (hd Tm9048) V9631) (let GoTo9051 (freeze (let Tm9052 (shen.lazyderef (tl Tm9048) V9631) (let GoTo9053 (lambda B (GoTo9049 B)) (if (cons? Tm9052) (let B (hd Tm9052) (let Tm9054 (shen.lazyderef (tl Tm9052) V9631) (let GoTo9055 (freeze (GoTo9053 B)) (if (= Tm9054 ()) (thaw GoTo9055) (if (shen.pvar? Tm9054) (shen.bind! Tm9054 () V9631 GoTo9055) false))))) (if (shen.pvar? Tm9052) (let B (shen.newpv V9631) (shen.gc V9631 (shen.bind! Tm9052 (cons B ()) V9631 (freeze (GoTo9053 B))))) false))))) (if (= Tm9050 *) (thaw GoTo9051) (if (shen.pvar? Tm9050) (shen.bind! Tm9050 * V9631 GoTo9051) false)))) (if (shen.pvar? Tm9048) (let B (shen.newpv V9631) (shen.gc V9631 (shen.bind! Tm9048 (cons * (cons B ())) V9631 (freeze (GoTo9049 B))))) false))))) (if (shen.pvar? Tm9046) (let A (shen.newpv V9631) (shen.gc V9631 (let B (shen.newpv V9631) (shen.gc V9631 (shen.bind! Tm9046 (cons A (cons * (cons B ()))) V9631 (freeze ((GoTo9047 A) B))))))) false)))) false))) false))) false)) false)) false)) false) (if (= C9040 false) (let C9056 (if (shen.unlocked? V9632) (let Tm9057 (shen.lazyderef V9628 V9631) (if (cons? Tm9057) (let Tm9058 (shen.lazyderef (hd Tm9057) V9631) (if (= Tm9058 @v) (let Tm9059 (shen.lazyderef (tl Tm9057) V9631) (if (cons? Tm9059) (let X (hd Tm9059) (let Tm9060 (shen.lazyderef (tl Tm9059) V9631) (if (cons? Tm9060) (let Y (hd Tm9060) (let Tm9061 (shen.lazyderef (tl Tm9060) V9631) (if (= Tm9061 ()) (let Tm9062 (shen.lazyderef V9629 V9631) (let GoTo9063 (lambda A (do (shen.incinfs) (shen.system-S-h X A V9630 V9631 V9632 K9002 (freeze (shen.system-S-h Y (cons vector (cons A ())) V9630 V9631 V9632 K9002 V9634))))) (if (cons? Tm9062) (let Tm9064 (shen.lazyderef (hd Tm9062) V9631) (let GoTo9065 (freeze (let Tm9066 (shen.lazyderef (tl Tm9062) V9631) (let GoTo9067 (lambda A (GoTo9063 A)) (if (cons? Tm9066) (let A (hd Tm9066) (let Tm9068 (shen.lazyderef (tl Tm9066) V9631) (let GoTo9069 (freeze (GoTo9067 A)) (if (= Tm9068 ()) (thaw GoTo9069) (if (shen.pvar? Tm9068) (shen.bind! Tm9068 () V9631 GoTo9069) false))))) (if (shen.pvar? Tm9066) (let A (shen.newpv V9631) (shen.gc V9631 (shen.bind! Tm9066 (cons A ()) V9631 (freeze (GoTo9067 A))))) false))))) (if (= Tm9064 vector) (thaw GoTo9065) (if (shen.pvar? Tm9064) (shen.bind! Tm9064 vector V9631 GoTo9065) false)))) (if (shen.pvar? Tm9062) (let A (shen.newpv V9631) (shen.gc V9631 (shen.bind! Tm9062 (cons vector (cons A ())) V9631 (freeze (GoTo9063 A))))) false)))) false))) false))) false)) false)) false)) false) (if (= C9056 false) (let C9070 (if (shen.unlocked? V9632) (let Tm9071 (shen.lazyderef V9628 V9631) (if (cons? Tm9071) (let Tm9072 (shen.lazyderef (hd Tm9071) V9631) (if (= Tm9072 @s) (let Tm9073 (shen.lazyderef (tl Tm9071) V9631) (if (cons? Tm9073) (let X (hd Tm9073) (let Tm9074 (shen.lazyderef (tl Tm9073) V9631) (if (cons? Tm9074) (let Y (hd Tm9074) (let Tm9075 (shen.lazyderef (tl Tm9074) V9631) (if (= Tm9075 ()) (let Tm9076 (shen.lazyderef V9629 V9631) (let GoTo9077 (freeze (do (shen.incinfs) (shen.system-S-h X string V9630 V9631 V9632 K9002 (freeze (shen.system-S-h Y string V9630 V9631 V9632 K9002 V9634))))) (if (= Tm9076 string) (thaw GoTo9077) (if (shen.pvar? Tm9076) (shen.bind! Tm9076 string V9631 GoTo9077) false)))) false))) false))) false)) false)) false)) false) (if (= C9070 false) (let C9078 (if (shen.unlocked? V9632) (let Tm9079 (shen.lazyderef V9628 V9631) (if (cons? Tm9079) (let Tm9080 (shen.lazyderef (hd Tm9079) V9631) (if (= Tm9080 lambda) (let Tm9081 (shen.lazyderef (tl Tm9079) V9631) (if (cons? Tm9081) (let X (hd Tm9081) (let Tm9082 (shen.lazyderef (tl Tm9081) V9631) (if (cons? Tm9082) (let Y (hd Tm9082) (let Tm9083 (shen.lazyderef (tl Tm9082) V9631) (if (= Tm9083 ()) (let Tm9084 (shen.lazyderef V9629 V9631) (let GoTo9085 (lambda A (lambda B (let Z (shen.newpv V9631) (shen.gc V9631 (let New (shen.newpv V9631) (shen.gc V9631 (do (shen.incinfs) (bind New (shen.freshterm (shen.lazyderef X V9631)) V9631 V9632 K9002 (freeze (bind Z (shen.beta (shen.lazyderef X V9631) (shen.deref New V9631) (shen.deref Y V9631)) V9631 V9632 K9002 (freeze (shen.system-S-h Z B (cons (cons New (cons (intern ":") (cons A ()))) V9630) V9631 V9632 K9002 V9634)))))))))))) (if (cons? Tm9084) (let A (hd Tm9084) (let Tm9086 (shen.lazyderef (tl Tm9084) V9631) (let GoTo9087 (lambda B ((GoTo9085 A) B)) (if (cons? Tm9086) (let Tm9088 (shen.lazyderef (hd Tm9086) V9631) (let GoTo9089 (freeze (let Tm9090 (shen.lazyderef (tl Tm9086) V9631) (let GoTo9091 (lambda B (GoTo9087 B)) (if (cons? Tm9090) (let B (hd Tm9090) (let Tm9092 (shen.lazyderef (tl Tm9090) V9631) (let GoTo9093 (freeze (GoTo9091 B)) (if (= Tm9092 ()) (thaw GoTo9093) (if (shen.pvar? Tm9092) (shen.bind! Tm9092 () V9631 GoTo9093) false))))) (if (shen.pvar? Tm9090) (let B (shen.newpv V9631) (shen.gc V9631 (shen.bind! Tm9090 (cons B ()) V9631 (freeze (GoTo9091 B))))) false))))) (if (= Tm9088 -->) (thaw GoTo9089) (if (shen.pvar? Tm9088) (shen.bind! Tm9088 --> V9631 GoTo9089) false)))) (if (shen.pvar? Tm9086) (let B (shen.newpv V9631) (shen.gc V9631 (shen.bind! Tm9086 (cons --> (cons B ())) V9631 (freeze (GoTo9087 B))))) false))))) (if (shen.pvar? Tm9084) (let A (shen.newpv V9631) (shen.gc V9631 (let B (shen.newpv V9631) (shen.gc V9631 (shen.bind! Tm9084 (cons A (cons --> (cons B ()))) V9631 (freeze ((GoTo9085 A) B))))))) false)))) false))) false))) false)) false)) false)) false) (if (= C9078 false) (let C9094 (if (shen.unlocked? V9632) (let Tm9095 (shen.lazyderef V9628 V9631) (if (cons? Tm9095) (let Tm9096 (shen.lazyderef (hd Tm9095) V9631) (if (= Tm9096 let) (let Tm9097 (shen.lazyderef (tl Tm9095) V9631) (if (cons? Tm9097) (let X (hd Tm9097) (let Tm9098 (shen.lazyderef (tl Tm9097) V9631) (if (cons? Tm9098) (let Y (hd Tm9098) (let Tm9099 (shen.lazyderef (tl Tm9098) V9631) (if (cons? Tm9099) (let Z (hd Tm9099) (let Tm9100 (shen.lazyderef (tl Tm9099) V9631) (if (= Tm9100 ()) (let W (shen.newpv V9631) (shen.gc V9631 (let New (shen.newpv V9631) (shen.gc V9631 (let B (shen.newpv V9631) (shen.gc V9631 (do (shen.incinfs) (shen.system-S-h Y B V9630 V9631 V9632 K9002 (freeze (bind New (shen.freshterm (shen.lazyderef X V9631)) V9631 V9632 K9002 (freeze (bind W (shen.beta (shen.lazyderef X V9631) (shen.lazyderef New V9631) (shen.lazyderef Z V9631)) V9631 V9632 K9002 (freeze (shen.system-S-h W V9629 (cons (cons New (cons (intern ":") (cons B ()))) V9630) V9631 V9632 K9002 V9634)))))))))))))) false))) false))) false))) false)) false)) false)) false) (if (= C9094 false) (let C9101 (if (shen.unlocked? V9632) (let Tm9102 (shen.lazyderef V9628 V9631) (if (cons? Tm9102) (let Tm9103 (shen.lazyderef (hd Tm9102) V9631) (if (= Tm9103 open) (let Tm9104 (shen.lazyderef (tl Tm9102) V9631) (if (cons? Tm9104) (let File (hd Tm9104) (let Tm9105 (shen.lazyderef (tl Tm9104) V9631) (if (cons? Tm9105) (let V8996 (hd Tm9105) (let Tm9106 (shen.lazyderef (tl Tm9105) V9631) (if (= Tm9106 ()) (let Tm9107 (shen.lazyderef V9629 V9631) (let GoTo9108 (lambda D (do (shen.incinfs) (is! V8996 D V9631 V9632 K9002 (freeze (when (element? (shen.lazyderef D V9631) (cons in (cons out ()))) V9631 V9632 K9002 (freeze (shen.system-S-h File string V9630 V9631 V9632 K9002 V9634))))))) (if (cons? Tm9107) (let Tm9109 (shen.lazyderef (hd Tm9107) V9631) (let GoTo9110 (freeze (let Tm9111 (shen.lazyderef (tl Tm9107) V9631) (let GoTo9112 (lambda D (GoTo9108 D)) (if (cons? Tm9111) (let D (hd Tm9111) (let Tm9113 (shen.lazyderef (tl Tm9111) V9631) (let GoTo9114 (freeze (GoTo9112 D)) (if (= Tm9113 ()) (thaw GoTo9114) (if (shen.pvar? Tm9113) (shen.bind! Tm9113 () V9631 GoTo9114) false))))) (if (shen.pvar? Tm9111) (let D (shen.newpv V9631) (shen.gc V9631 (shen.bind! Tm9111 (cons D ()) V9631 (freeze (GoTo9112 D))))) false))))) (if (= Tm9109 stream) (thaw GoTo9110) (if (shen.pvar? Tm9109) (shen.bind! Tm9109 stream V9631 GoTo9110) false)))) (if (shen.pvar? Tm9107) (let D (shen.newpv V9631) (shen.gc V9631 (shen.bind! Tm9107 (cons stream (cons D ())) V9631 (freeze (GoTo9108 D))))) false)))) false))) false))) false)) false)) false)) false) (if (= C9101 false) (let C9115 (if (shen.unlocked? V9632) (let Tm9116 (shen.lazyderef V9628 V9631) (if (cons? Tm9116) (let Tm9117 (shen.lazyderef (hd Tm9116) V9631) (if (= Tm9117 type) (let Tm9118 (shen.lazyderef (tl Tm9116) V9631) (if (cons? Tm9118) (let X (hd Tm9118) (let Tm9119 (shen.lazyderef (tl Tm9118) V9631) (if (cons? Tm9119) (let A (hd Tm9119) (let Tm9120 (shen.lazyderef (tl Tm9119) V9631) (if (= Tm9120 ()) (do (shen.incinfs) (shen.cut V9631 V9632 K9002 (freeze (is! (shen.rectify-type (shen.deref A V9631)) V9629 V9631 V9632 K9002 (freeze (shen.system-S-h X V9629 V9630 V9631 V9632 K9002 V9634)))))) false))) false))) false)) false)) false)) false) (if (= C9115 false) (let C9121 (if (shen.unlocked? V9632) (let Tm9122 (shen.lazyderef V9628 V9631) (if (cons? Tm9122) (let Tm9123 (shen.lazyderef (hd Tm9122) V9631) (if (= Tm9123 input+) (let Tm9124 (shen.lazyderef (tl Tm9122) V9631) (if (cons? Tm9124) (let A (hd Tm9124) (let Tm9125 (shen.lazyderef (tl Tm9124) V9631) (if (cons? Tm9125) (let Stream (hd Tm9125) (let Tm9126 (shen.lazyderef (tl Tm9125) V9631) (if (= Tm9126 ()) (do (shen.incinfs) (is! V9629 (shen.rectify-type (shen.deref A V9631)) V9631 V9632 K9002 (freeze (shen.system-S-h Stream (cons stream (cons in ())) V9630 V9631 V9632 K9002 V9634)))) false))) false))) false)) false)) false)) false) (if (= C9121 false) (let C9127 (if (shen.unlocked? V9632) (let Tm9128 (shen.lazyderef V9628 V9631) (if (cons? Tm9128) (let Tm9129 (shen.lazyderef (hd Tm9128) V9631) (if (= Tm9129 set) (let Tm9130 (shen.lazyderef (tl Tm9128) V9631) (if (cons? Tm9130) (let Var (hd Tm9130) (let Tm9131 (shen.lazyderef (tl Tm9130) V9631) (if (cons? Tm9131) (let Val (hd Tm9131) (let Tm9132 (shen.lazyderef (tl Tm9131) V9631) (if (= Tm9132 ()) (do (shen.incinfs) (shen.system-S-h Var symbol V9630 V9631 V9632 K9002 (freeze (shen.system-S-h (cons value (cons Var ())) V9629 V9630 V9631 V9632 K9002 (freeze (shen.system-S-h Val V9629 V9630 V9631 V9632 K9002 V9634)))))) false))) false))) false)) false)) false)) false) (if (= C9127 false) (let C9133 (if (shen.unlocked? V9632) (let Normalised (shen.newpv V9631) (shen.gc V9631 (do (shen.incinfs) (shen.l-rules V9630 Normalised false V9631 V9632 K9002 (freeze (shen.cut V9631 V9632 K9002 (freeze (shen.system-S-h V9628 V9629 Normalised V9631 V9632 K9002 V9634)))))))) false) (if (= C9133 false) (let C9134 (if (shen.unlocked? V9632) (do (shen.incinfs) (shen.search-user-datatypes (cons V9628 (cons (intern ":") (cons V9629 ()))) V9630 (value shen.*datatypes*) V9631 V9632 K9002 V9634)) false) (if (= C9134 false) (shen.unlock V9632 K9002) C9134)) C9133)) C9127)) C9121)) C9115)) C9101)) C9094)) C9078)) C9070)) C9056)) C9040)) C9026)) C9022)) C9018)) C9013)) C9010)) C9009)) C9008)) C9007))))

(defun shen.primitive (V9635 V9636 V9637 V9638 V9639 V9640) (let C9143 (if (shen.unlocked? V9638) (let Tm9144 (shen.lazyderef V9636 V9637) (let GoTo9145 (freeze (do (shen.incinfs) (when (number? (shen.lazyderef V9635 V9637)) V9637 V9638 V9639 V9640))) (if (= Tm9144 number) (thaw GoTo9145) (if (shen.pvar? Tm9144) (shen.bind! Tm9144 number V9637 GoTo9145) false)))) false) (if (= C9143 false) (let C9146 (if (shen.unlocked? V9638) (let Tm9147 (shen.lazyderef V9636 V9637) (let GoTo9148 (freeze (do (shen.incinfs) (when (boolean? (shen.lazyderef V9635 V9637)) V9637 V9638 V9639 V9640))) (if (= Tm9147 boolean) (thaw GoTo9148) (if (shen.pvar? Tm9147) (shen.bind! Tm9147 boolean V9637 GoTo9148) false)))) false) (if (= C9146 false) (let C9149 (if (shen.unlocked? V9638) (let Tm9150 (shen.lazyderef V9636 V9637) (let GoTo9151 (freeze (do (shen.incinfs) (when (string? (shen.lazyderef V9635 V9637)) V9637 V9638 V9639 V9640))) (if (= Tm9150 string) (thaw GoTo9151) (if (shen.pvar? Tm9150) (shen.bind! Tm9150 string V9637 GoTo9151) false)))) false) (if (= C9149 false) (let C9152 (if (shen.unlocked? V9638) (let Tm9153 (shen.lazyderef V9636 V9637) (let GoTo9154 (freeze (do (shen.incinfs) (when (symbol? (shen.lazyderef V9635 V9637)) V9637 V9638 V9639 V9640))) (if (= Tm9153 symbol) (thaw GoTo9154) (if (shen.pvar? Tm9153) (shen.bind! Tm9153 symbol V9637 GoTo9154) false)))) false) (if (= C9152 false) (if (shen.unlocked? V9638) (let Tm9155 (shen.lazyderef V9635 V9637) (if (= Tm9155 ()) (let Tm9156 (shen.lazyderef V9636 V9637) (let GoTo9157 (lambda A (do (shen.incinfs) (thaw V9640))) (if (cons? Tm9156) (let Tm9158 (shen.lazyderef (hd Tm9156) V9637) (let GoTo9159 (freeze (let Tm9160 (shen.lazyderef (tl Tm9156) V9637) (let GoTo9161 (lambda A (GoTo9157 A)) (if (cons? Tm9160) (let A (hd Tm9160) (let Tm9162 (shen.lazyderef (tl Tm9160) V9637) (let GoTo9163 (freeze (GoTo9161 A)) (if (= Tm9162 ()) (thaw GoTo9163) (if (shen.pvar? Tm9162) (shen.bind! Tm9162 () V9637 GoTo9163) false))))) (if (shen.pvar? Tm9160) (let A (shen.newpv V9637) (shen.gc V9637 (shen.bind! Tm9160 (cons A ()) V9637 (freeze (GoTo9161 A))))) false))))) (if (= Tm9158 list) (thaw GoTo9159) (if (shen.pvar? Tm9158) (shen.bind! Tm9158 list V9637 GoTo9159) false)))) (if (shen.pvar? Tm9156) (let A (shen.newpv V9637) (shen.gc V9637 (shen.bind! Tm9156 (cons list (cons A ())) V9637 (freeze (GoTo9157 A))))) false)))) false)) false) C9152)) C9149)) C9146)) C9143)))

(defun shen.by-hypothesis (V9641 V9642 V9643 V9644 V9645 V9646 V9647) (let C9174 (if (shen.unlocked? V9645) (let Tm9175 (shen.lazyderef V9643 V9644) (if (cons? Tm9175) (let Tm9176 (shen.lazyderef (hd Tm9175) V9644) (if (cons? Tm9176) (let Y (hd Tm9176) (let Tm9177 (shen.lazyderef (tl Tm9176) V9644) (if (cons? Tm9177) (let Colon (hd Tm9177) (let Tm9178 (shen.lazyderef (tl Tm9177) V9644) (if (cons? Tm9178) (let B (hd Tm9178) (let Tm9179 (shen.lazyderef (tl Tm9178) V9644) (if (= Tm9179 ()) (do (shen.incinfs) (when (= (shen.deref Colon V9644) (intern ":")) V9644 V9645 V9646 (freeze (when (= (shen.deref V9641 V9644) (shen.deref Y V9644)) V9644 V9645 V9646 (freeze (is! V9642 B V9644 V9645 V9646 V9647)))))) false))) false))) false))) false)) false)) false) (if (= C9174 false) (if (shen.unlocked? V9645) (let Tm9180 (shen.lazyderef V9643 V9644) (if (cons? Tm9180) (let Hyp (tl Tm9180) (do (shen.incinfs) (shen.by-hypothesis V9641 V9642 Hyp V9644 V9645 V9646 V9647))) false)) false) C9174)))

(defun shen.lookupsig (V9648 V9649 V9650 V9651 V9652 V9653) (if (shen.unlocked? V9651) (do (shen.incinfs) (shen.sigf (assoc V9648 (value shen.*sigf*)) V9649 V9650 V9651 V9652 V9653)) false))

(defun shen.sigf (V9668 V9669 V9670 V9671 V9672 V9673) (cond ((cons? V9668) ((((((tl V9668) V9669) V9670) V9671) V9672) V9673)) (true false)))

(defun shen.freshterm (V9674) (let V (absvector 3) (let V0 (address-> V 0 shen.print-freshterm) (let V1 (address-> V0 1 V9674) (let V2 (address-> V1 2 (set shen.*gensym* (+ 1 (value shen.*gensym*)))) V2)))))

(defun shen.print-freshterm (V9675) (cn "&&" (str (<-address V9675 1))))

(defun shen.search-user-datatypes (V9676 V9677 V9678 V9679 V9680 V9681 V9682) (let C9199 (if (shen.unlocked? V9680) (let Tm9200 (shen.lazyderef V9678 V9679) (if (cons? Tm9200) (let Tm9201 (shen.lazyderef (hd Tm9200) V9679) (if (cons? Tm9201) (let Fn (tl Tm9201) (do (shen.incinfs) (call (((shen.deref Fn V9679) (shen.deref V9676 V9679)) (shen.deref V9677 V9679)) V9679 V9680 V9681 V9682))) false)) false)) false) (if (= C9199 false) (if (shen.unlocked? V9680) (let Tm9202 (shen.lazyderef V9678 V9679) (if (cons? Tm9202) (let Ds (tl Tm9202) (do (shen.incinfs) (shen.search-user-datatypes V9676 V9677 Ds V9679 V9680 V9681 V9682))) false)) false) C9199)))

(defun shen.l-rules (V9683 V9684 V9685 V9686 V9687 V9688 V9689) (let K9208 (+ V9688 1) (let C9213 (if (shen.unlocked? V9687) (let Tm9214 (shen.lazyderef V9683 V9686) (if (= Tm9214 ()) (let Tm9215 (shen.lazyderef V9685 V9686) (if (= Tm9215 true) (do (shen.incinfs) (shen.cut V9686 V9687 K9208 (freeze (bind V9684 () V9686 V9687 K9208 V9689)))) false)) false)) false) (if (= C9213 false) (let C9216 (if (shen.unlocked? V9687) (let Tm9217 (shen.lazyderef V9683 V9686) (if (cons? Tm9217) (let Tm9218 (shen.lazyderef (hd Tm9217) V9686) (if (cons? Tm9218) (let Tm9219 (shen.lazyderef (hd Tm9218) V9686) (if (cons? Tm9219) (let Tm9220 (shen.lazyderef (hd Tm9219) V9686) (if (= Tm9220 cons) (let Tm9221 (shen.lazyderef (tl Tm9219) V9686) (if (cons? Tm9221) (let X (hd Tm9221) (let Tm9222 (shen.lazyderef (tl Tm9221) V9686) (if (cons? Tm9222) (let Y (hd Tm9222) (let Tm9223 (shen.lazyderef (tl Tm9222) V9686) (if (= Tm9223 ()) (let Tm9224 (shen.lazyderef (tl Tm9218) V9686) (if (cons? Tm9224) (let Colon (hd Tm9224) (let Tm9225 (shen.lazyderef (tl Tm9224) V9686) (if (cons? Tm9225) (let Tm9226 (shen.lazyderef (hd Tm9225) V9686) (if (cons? Tm9226) (let Tm9227 (shen.lazyderef (hd Tm9226) V9686) (if (= Tm9227 list) (let Tm9228 (shen.lazyderef (tl Tm9226) V9686) (if (cons? Tm9228) (let A (hd Tm9228) (let Tm9229 (shen.lazyderef (tl Tm9228) V9686) (if (= Tm9229 ()) (let Tm9230 (shen.lazyderef (tl Tm9225) V9686) (if (= Tm9230 ()) (let Hyp (tl Tm9217) (do (shen.incinfs) (when (= (shen.deref Colon V9686) (intern ":")) V9686 V9687 K9208 (freeze (shen.cut V9686 V9687 K9208 (freeze (shen.l-rules (cons (cons X (cons Colon (cons A ()))) (cons (cons Y (cons Colon (cons (cons list (cons A ())) ()))) Hyp)) V9684 true V9686 V9687 K9208 V9689))))))) false)) false))) false)) false)) false)) false))) false)) false))) false))) false)) false)) false)) false)) false)) false) (if (= C9216 false) (let C9231 (if (shen.unlocked? V9687) (let Tm9232 (shen.lazyderef V9683 V9686) (if (cons? Tm9232) (let Tm9233 (shen.lazyderef (hd Tm9232) V9686) (if (cons? Tm9233) (let Tm9234 (shen.lazyderef (hd Tm9233) V9686) (if (cons? Tm9234) (let Tm9235 (shen.lazyderef (hd Tm9234) V9686) (if (= Tm9235 @p) (let Tm9236 (shen.lazyderef (tl Tm9234) V9686) (if (cons? Tm9236) (let X (hd Tm9236) (let Tm9237 (shen.lazyderef (tl Tm9236) V9686) (if (cons? Tm9237) (let Y (hd Tm9237) (let Tm9238 (shen.lazyderef (tl Tm9237) V9686) (if (= Tm9238 ()) (let Tm9239 (shen.lazyderef (tl Tm9233) V9686) (if (cons? Tm9239) (let Colon (hd Tm9239) (let Tm9240 (shen.lazyderef (tl Tm9239) V9686) (if (cons? Tm9240) (let Tm9241 (shen.lazyderef (hd Tm9240) V9686) (if (cons? Tm9241) (let A (hd Tm9241) (let Tm9242 (shen.lazyderef (tl Tm9241) V9686) (if (cons? Tm9242) (let Tm9243 (shen.lazyderef (hd Tm9242) V9686) (if (= Tm9243 *) (let Tm9244 (shen.lazyderef (tl Tm9242) V9686) (if (cons? Tm9244) (let B (hd Tm9244) (let Tm9245 (shen.lazyderef (tl Tm9244) V9686) (if (= Tm9245 ()) (let Tm9246 (shen.lazyderef (tl Tm9240) V9686) (if (= Tm9246 ()) (let Hyp (tl Tm9232) (do (shen.incinfs) (when (= (shen.deref Colon V9686) (intern ":")) V9686 V9687 K9208 (freeze (shen.cut V9686 V9687 K9208 (freeze (shen.l-rules (cons (cons X (cons Colon (cons A ()))) (cons (cons Y (cons Colon (cons B ()))) Hyp)) V9684 true V9686 V9687 K9208 V9689))))))) false)) false))) false)) false)) false))) false)) false))) false)) false))) false))) false)) false)) false)) false)) false)) false) (if (= C9231 false) (let C9247 (if (shen.unlocked? V9687) (let Tm9248 (shen.lazyderef V9683 V9686) (if (cons? Tm9248) (let Tm9249 (shen.lazyderef (hd Tm9248) V9686) (if (cons? Tm9249) (let Tm9250 (shen.lazyderef (hd Tm9249) V9686) (if (cons? Tm9250) (let Tm9251 (shen.lazyderef (hd Tm9250) V9686) (if (= Tm9251 @s) (let Tm9252 (shen.lazyderef (tl Tm9250) V9686) (if (cons? Tm9252) (let X (hd Tm9252) (let Tm9253 (shen.lazyderef (tl Tm9252) V9686) (if (cons? Tm9253) (let Y (hd Tm9253) (let Tm9254 (shen.lazyderef (tl Tm9253) V9686) (if (= Tm9254 ()) (let Tm9255 (shen.lazyderef (tl Tm9249) V9686) (if (cons? Tm9255) (let Colon (hd Tm9255) (let Tm9256 (shen.lazyderef (tl Tm9255) V9686) (if (cons? Tm9256) (let Tm9257 (shen.lazyderef (hd Tm9256) V9686) (if (= Tm9257 string) (let Tm9258 (shen.lazyderef (tl Tm9256) V9686) (if (= Tm9258 ()) (let Hyp (tl Tm9248) (do (shen.incinfs) (when (= (shen.deref Colon V9686) (intern ":")) V9686 V9687 K9208 (freeze (shen.cut V9686 V9687 K9208 (freeze (shen.l-rules (cons (cons X (cons Colon (cons string ()))) (cons (cons Y (cons Colon (cons string ()))) Hyp)) V9684 true V9686 V9687 K9208 V9689))))))) false)) false)) false))) false)) false))) false))) false)) false)) false)) false)) false)) false) (if (= C9247 false) (let C9259 (if (shen.unlocked? V9687) (let Tm9260 (shen.lazyderef V9683 V9686) (if (cons? Tm9260) (let Tm9261 (shen.lazyderef (hd Tm9260) V9686) (if (cons? Tm9261) (let Tm9262 (shen.lazyderef (hd Tm9261) V9686) (if (cons? Tm9262) (let Tm9263 (shen.lazyderef (hd Tm9262) V9686) (if (= Tm9263 @v) (let Tm9264 (shen.lazyderef (tl Tm9262) V9686) (if (cons? Tm9264) (let X (hd Tm9264) (let Tm9265 (shen.lazyderef (tl Tm9264) V9686) (if (cons? Tm9265) (let Y (hd Tm9265) (let Tm9266 (shen.lazyderef (tl Tm9265) V9686) (if (= Tm9266 ()) (let Tm9267 (shen.lazyderef (tl Tm9261) V9686) (if (cons? Tm9267) (let Colon (hd Tm9267) (let Tm9268 (shen.lazyderef (tl Tm9267) V9686) (if (cons? Tm9268) (let Tm9269 (shen.lazyderef (hd Tm9268) V9686) (if (cons? Tm9269) (let Tm9270 (shen.lazyderef (hd Tm9269) V9686) (if (= Tm9270 vector) (let Tm9271 (shen.lazyderef (tl Tm9269) V9686) (if (cons? Tm9271) (let A (hd Tm9271) (let Tm9272 (shen.lazyderef (tl Tm9271) V9686) (if (= Tm9272 ()) (let Tm9273 (shen.lazyderef (tl Tm9268) V9686) (if (= Tm9273 ()) (let Hyp (tl Tm9260) (do (shen.incinfs) (when (= (shen.deref Colon V9686) (intern ":")) V9686 V9687 K9208 (freeze (shen.cut V9686 V9687 K9208 (freeze (shen.l-rules (cons (cons X (cons Colon (cons A ()))) (cons (cons Y (cons Colon (cons (cons vector (cons A ())) ()))) Hyp)) V9684 true V9686 V9687 K9208 V9689))))))) false)) false))) false)) false)) false)) false))) false)) false))) false))) false)) false)) false)) false)) false)) false) (if (= C9259 false) (let C9274 (if (shen.unlocked? V9687) (let Tm9275 (shen.lazyderef V9683 V9686) (if (cons? Tm9275) (let P (hd Tm9275) (let Hyp (tl Tm9275) (let Tm9276 (shen.lazyderef V9684 V9686) (let GoTo9277 (lambda Q (lambda Normalised (do (shen.incinfs) (bind Q P V9686 V9687 K9208 (freeze (shen.l-rules Hyp Normalised V9685 V9686 V9687 K9208 V9689)))))) (if (cons? Tm9276) (let Q (hd Tm9276) (let Normalised (tl Tm9276) ((GoTo9277 Q) Normalised))) (if (shen.pvar? Tm9276) (let Q (shen.newpv V9686) (shen.gc V9686 (let Normalised (shen.newpv V9686) (shen.gc V9686 (shen.bind! Tm9276 (cons Q Normalised) V9686 (freeze ((GoTo9277 Q) Normalised))))))) false)))))) false)) false) (if (= C9274 false) (shen.unlock V9687 K9208) C9274)) C9259)) C9247)) C9231)) C9216)) C9213))))

(defun shen.t* (V9690 V9691 V9692 V9693 V9694 V9695) (let K9282 (+ V9694 1) (let C9286 (if (shen.unlocked? V9693) (let Tm9287 (shen.lazyderef V9690 V9692) (if (cons? Tm9287) (let Tm9288 (shen.lazyderef (hd Tm9287) V9692) (if (= Tm9288 define) (let Tm9289 (shen.lazyderef (tl Tm9287) V9692) (if (cons? Tm9289) (let F (hd Tm9289) (let X (tl Tm9289) (let SigxRules (shen.newpv V9692) (shen.gc V9692 (let Rules (shen.newpv V9692) (shen.gc V9692 (let FreshSig (shen.newpv V9692) (shen.gc V9692 (let Sig (shen.newpv V9692) (shen.gc V9692 (do (shen.incinfs) (shen.cut V9692 V9693 K9282 (freeze (bind SigxRules (shen.sigxrules (cons F X)) V9692 V9693 K9282 (freeze (bind Sig (fst (shen.lazyderef SigxRules V9692)) V9692 V9693 K9282 (freeze (bind Rules (snd (shen.lazyderef SigxRules V9692)) V9692 V9693 K9282 (freeze (bind FreshSig (shen.freshen-sig (shen.deref Sig V9692)) V9692 V9693 K9282 (freeze (shen.t*-rules F Rules FreshSig 1 V9692 V9693 K9282 (freeze (is Sig V9691 V9692 V9693 K9282 V9695)))))))))))))))))))))))) false)) false)) false)) false) (if (= C9286 false) (shen.unlock V9693 K9282) C9286))))

(defun shen.sigxrules (V9696) (compile (lambda X (shen.<sig*rules> X)) V9696))

(defun shen.<sig*rules> (V9697) (let Result (if (shen.non-empty-stream? V9697) (let F (shen.hds V9697) (let News9291 (shen.tls V9697) (if (shen.=hd? News9291 {) (let News9292 (shen.tls News9291) (let Parseshen.<signature> (shen.<signature> News9292) (if (shen.parse-failure? Parseshen.<signature>) (shen.parse-failure) (if (shen.=hd? Parseshen.<signature> }) (let News9293 (shen.tls Parseshen.<signature>) (let Parseshen.<rules*> (shen.<rules*> News9293) (if (shen.parse-failure? Parseshen.<rules*>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<rules*>) (let Rectified (shen.rectify-type (shen.<-out Parseshen.<signature>)) (@p Rectified (shen.<-out Parseshen.<rules*>))))))) (shen.parse-failure))))) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.freshen-sig (V9698) (let Vs (shen.extract-vars V9698) (let Assoc (map (lambda V (cons V (shen.freshterm (concat & V)))) Vs) (shen.freshen-type Assoc V9698))))

(defun shen.freshen-type (V9699 V9700) (cond ((= () V9699) V9700) ((and (cons? V9699) (cons? (hd V9699))) (shen.freshen-type (tl V9699) (subst (tl (hd V9699)) (hd (hd V9699)) V9700))) (true (shen.f-error shen.freshen-type))))

(defun shen.<rules*> (V9701) (let Result (let Parseshen.<rule*> (shen.<rule*> V9701) (if (shen.parse-failure? Parseshen.<rule*>) (shen.parse-failure) (let Parseshen.<rules*> (shen.<rules*> Parseshen.<rule*>) (if (shen.parse-failure? Parseshen.<rules*>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<rules*>) (cons (shen.<-out Parseshen.<rule*>) (shen.<-out Parseshen.<rules*>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<rule*> (shen.<rule*> V9701) (if (shen.parse-failure? Parseshen.<rule*>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<rule*>) (cons (shen.<-out Parseshen.<rule*>) ())))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<rule*> (V9702) (let Result (let Parseshen.<patterns> (shen.<patterns> V9702) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> ->) (let News9296 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News9296) (let Action (shen.hds News9296) (let News9297 (shen.tls News9296) (if (shen.=hd? News9297 where) (let News9298 (shen.tls News9297) (if (shen.non-empty-stream? News9298) (let Guard (shen.hds News9298) (let News9299 (shen.tls News9298) (shen.comb (shen.in-> News9299) (@p (shen.<-out Parseshen.<patterns>) (cons where (cons Guard (cons Action ()))))))) (shen.parse-failure))) (shen.parse-failure)))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<patterns> (shen.<patterns> V9702) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> <-) (let News9300 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News9300) (let Action (shen.hds News9300) (let News9301 (shen.tls News9300) (if (shen.=hd? News9301 where) (let News9302 (shen.tls News9301) (if (shen.non-empty-stream? News9302) (let Guard (shen.hds News9302) (let News9303 (shen.tls News9302) (shen.comb (shen.in-> News9303) (@p (shen.<-out Parseshen.<patterns>) (shen.correct (cons where (cons Guard (cons Action ())))))))) (shen.parse-failure))) (shen.parse-failure)))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<patterns> (shen.<patterns> V9702) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> <-) (let News9304 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News9304) (let Action (shen.hds News9304) (let News9305 (shen.tls News9304) (shen.comb (shen.in-> News9305) (@p (shen.<-out Parseshen.<patterns>) (shen.correct Action))))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<patterns> (shen.<patterns> V9702) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> ->) (let News9306 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News9306) (let Action (shen.hds News9306) (let News9307 (shen.tls News9306) (shen.comb (shen.in-> News9307) (@p (shen.<-out Parseshen.<patterns>) Action)))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)) Result)))

(defun shen.correct (V9703) (cond ((and (cons? V9703) (and (= where (hd V9703)) (and (cons? (tl V9703)) (and (cons? (tl (tl V9703))) (and (cons? (hd (tl (tl V9703)))) (and (= fail-if (hd (hd (tl (tl V9703))))) (and (cons? (tl (hd (tl (tl V9703))))) (and (cons? (tl (tl (hd (tl (tl V9703)))))) (and (= () (tl (tl (tl (hd (tl (tl V9703))))))) (= () (tl (tl (tl V9703))))))))))))) (cons where (cons (cons and (cons (hd (tl V9703)) (cons (cons not (cons (tl (hd (tl (tl V9703)))) ())) ()))) (tl (tl (hd (tl (tl V9703)))))))) ((and (cons? V9703) (and (= where (hd V9703)) (and (cons? (tl V9703)) (and (cons? (tl (tl V9703))) (= () (tl (tl (tl V9703)))))))) (cons where (cons (cons and (cons (hd (tl V9703)) (cons (cons not (cons (cons = (cons (hd (tl (tl V9703))) (cons (cons fail ()) ()))) ())) ()))) (tl (tl V9703))))) ((and (cons? V9703) (and (= fail-if (hd V9703)) (and (cons? (tl V9703)) (and (cons? (tl (tl V9703))) (= () (tl (tl (tl V9703)))))))) (cons where (cons (cons not (cons (tl V9703) ())) (tl (tl V9703))))) (true (cons where (cons (cons not (cons (cons = (cons V9703 (cons (cons fail ()) ()))) ())) (cons V9703 ()))))))

(defun shen.t*-rules (V9704 V9705 V9706 V9707 V9708 V9709 V9710 V9711) (let K9314 (+ V9710 1) (let C9320 (if (shen.unlocked? V9709) (let Tm9321 (shen.lazyderef V9705 V9708) (if (= Tm9321 ()) (do (shen.incinfs) (thaw V9711)) false)) false) (if (= C9320 false) (let C9322 (if (shen.unlocked? V9709) (let Tm9323 (shen.lazyderef V9705 V9708) (if (cons? Tm9323) (let Rule (hd Tm9323) (let Rules (tl Tm9323) (let Fresh (shen.newpv V9708) (shen.gc V9708 (do (shen.incinfs) (bind Fresh (shen.freshen-rule (shen.deref Rule V9708)) V9708 V9709 K9314 (freeze (shen.t*-rule V9704 V9707 (fst (shen.lazyderef Fresh V9708)) (snd (shen.lazyderef Fresh V9708)) V9706 V9708 V9709 K9314 (freeze (shen.cut V9708 V9709 K9314 (freeze (shen.t*-rules V9704 Rules V9706 (+ V9707 1) V9708 V9709 K9314 V9711)))))))))))) false)) false) (if (= C9322 false) (shen.unlock V9709 K9314) C9322)) C9320))))

(defun shen.freshen-rule (V9712) (cond ((tuple? V9712) (let Vs (shen.extract-vars (fst V9712)) (let Assoc (map (lambda V (cons V (shen.freshterm V))) Vs) (@p (shen.freshen Assoc (fst V9712)) (shen.freshen Assoc (snd V9712)))))) (true (shen.f-error shen.freshen-rule))))

(defun shen.freshen (V9713 V9714) (cond ((= () V9713) V9714) ((and (cons? V9713) (cons? (hd V9713))) (shen.freshen (tl V9713) (shen.beta (hd (hd V9713)) (tl (hd V9713)) V9714))) (true (shen.f-error shen.freshen))))

(defun shen.t*-rule (V9715 V9716 V9717 V9718 V9719 V9720 V9721 V9722 V9723) (let C9338 (if (shen.unlocked? V9721) (do (shen.incinfs) (shen.t*-rule-h V9717 V9718 V9719 V9720 V9721 V9722 V9723)) false) (if (= C9338 false) (if (shen.unlocked? V9721) (let Err (shen.newpv V9720) (shen.gc V9720 (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app V9716 (cn " of " (shen.app V9715 "
" shen.a)) shen.a))) V9720 V9721 V9722 V9723)))) false) C9338)))

(defun shen.t*-rule-h (V9724 V9725 V9726 V9727 V9728 V9729 V9730) (let K9344 (+ V9729 1) (let C9349 (if (shen.unlocked? V9728) (let Tm9350 (shen.lazyderef V9724 V9727) (if (= Tm9350 ()) (let Tm9351 (shen.lazyderef V9726 V9727) (if (cons? Tm9351) (let Tm9352 (shen.lazyderef (hd Tm9351) V9727) (if (= Tm9352 -->) (let Tm9353 (shen.lazyderef (tl Tm9351) V9727) (if (cons? Tm9353) (let A (hd Tm9353) (let Tm9354 (shen.lazyderef (tl Tm9353) V9727) (if (= Tm9354 ()) (do (shen.incinfs) (shen.cut V9727 V9728 K9344 (freeze (shen.t*-correct V9725 A () V9727 V9728 K9344 V9730)))) false))) false)) false)) false)) false)) false) (if (= C9349 false) (let C9355 (if (shen.unlocked? V9728) (let B (shen.newpv V9727) (shen.gc V9727 (let Hyps (shen.newpv V9727) (shen.gc V9727 (do (shen.incinfs) (shen.p-hyps (shen.freshterms V9724) Hyps V9727 V9728 K9344 (freeze (shen.t*-integrity V9724 V9726 Hyps B V9727 V9728 K9344 (freeze (shen.cut V9727 V9728 K9344 (freeze (shen.t*-correct V9725 B Hyps V9727 V9728 K9344 V9730)))))))))))) false) (if (= C9355 false) (shen.unlock V9728 K9344) C9355)) C9349))))

(defun shen.freshterms (V9733) (cond ((= () V9733) ()) ((and (cons? V9733) (cons? (hd V9733))) (shen.freshterms (append (hd V9733) (tl V9733)))) ((and (cons? V9733) (shen.freshterm? (hd V9733))) (adjoin (hd V9733) (shen.freshterms (tl V9733)))) ((cons? V9733) (shen.freshterms (tl V9733))) (true (shen.f-error shen.freshterms))))

(defun shen.p-hyps (V9734 V9735 V9736 V9737 V9738 V9739) (let C9364 (if (shen.unlocked? V9737) (let Tm9365 (shen.lazyderef V9734 V9736) (if (= Tm9365 ()) (let Tm9366 (shen.lazyderef V9735 V9736) (let GoTo9367 (freeze (do (shen.incinfs) (thaw V9739))) (if (= Tm9366 ()) (thaw GoTo9367) (if (shen.pvar? Tm9366) (shen.bind! Tm9366 () V9736 GoTo9367) false)))) false)) false) (if (= C9364 false) (if (shen.unlocked? V9737) (let Tm9368 (shen.lazyderef V9734 V9736) (if (cons? Tm9368) (let P (hd Tm9368) (let Ps (tl Tm9368) (let Tm9369 (shen.lazyderef V9735 V9736) (let GoTo9370 (lambda Q (lambda Colon (lambda A (lambda Hyps (do (shen.incinfs) (bind Q P V9736 V9737 V9738 (freeze (bind Colon (intern ":") V9736 V9737 V9738 (freeze (shen.p-hyps Ps Hyps V9736 V9737 V9738 V9739)))))))))) (if (cons? Tm9369) (let Tm9371 (shen.lazyderef (hd Tm9369) V9736) (let GoTo9372 (lambda Q (lambda Colon (lambda A (let Hyps (tl Tm9369) ((((GoTo9370 Q) Colon) A) Hyps))))) (if (cons? Tm9371) (let Q (hd Tm9371) (let Tm9373 (shen.lazyderef (tl Tm9371) V9736) (let GoTo9374 (lambda Colon (lambda A (((GoTo9372 Q) Colon) A))) (if (cons? Tm9373) (let Colon (hd Tm9373) (let Tm9375 (shen.lazyderef (tl Tm9373) V9736) (let GoTo9376 (lambda A ((GoTo9374 Colon) A)) (if (cons? Tm9375) (let A (hd Tm9375) (let Tm9377 (shen.lazyderef (tl Tm9375) V9736) (let GoTo9378 (freeze (GoTo9376 A)) (if (= Tm9377 ()) (thaw GoTo9378) (if (shen.pvar? Tm9377) (shen.bind! Tm9377 () V9736 GoTo9378) false))))) (if (shen.pvar? Tm9375) (let A (shen.newpv V9736) (shen.gc V9736 (shen.bind! Tm9375 (cons A ()) V9736 (freeze (GoTo9376 A))))) false))))) (if (shen.pvar? Tm9373) (let Colon (shen.newpv V9736) (shen.gc V9736 (let A (shen.newpv V9736) (shen.gc V9736 (shen.bind! Tm9373 (cons Colon (cons A ())) V9736 (freeze ((GoTo9374 Colon) A))))))) false))))) (if (shen.pvar? Tm9371) (let Q (shen.newpv V9736) (shen.gc V9736 (let Colon (shen.newpv V9736) (shen.gc V9736 (let A (shen.newpv V9736) (shen.gc V9736 (shen.bind! Tm9371 (cons Q (cons Colon (cons A ()))) V9736 (freeze (((GoTo9372 Q) Colon) A))))))))) false)))) (if (shen.pvar? Tm9369) (let Q (shen.newpv V9736) (shen.gc V9736 (let Colon (shen.newpv V9736) (shen.gc V9736 (let A (shen.newpv V9736) (shen.gc V9736 (let Hyps (shen.newpv V9736) (shen.gc V9736 (shen.bind! Tm9369 (cons (cons Q (cons Colon (cons A ()))) Hyps) V9736 (freeze ((((GoTo9370 Q) Colon) A) Hyps))))))))))) false)))))) false)) false) C9364)))

(defun shen.t*-correct (V9740 V9741 V9742 V9743 V9744 V9745 V9746) (let K9384 (+ V9745 1) (let C9389 (if (shen.unlocked? V9744) (let Tm9390 (shen.lazyderef V9740 V9743) (if (cons? Tm9390) (let Tm9391 (shen.lazyderef (hd Tm9390) V9743) (if (= Tm9391 where) (let Tm9392 (shen.lazyderef (tl Tm9390) V9743) (if (cons? Tm9392) (let G (hd Tm9392) (let Tm9393 (shen.lazyderef (tl Tm9392) V9743) (if (cons? Tm9393) (let R (hd Tm9393) (let Tm9394 (shen.lazyderef (tl Tm9393) V9743) (if (= Tm9394 ()) (let CurryG (shen.newpv V9743) (shen.gc V9743 (do (shen.incinfs) (shen.cut V9743 V9744 K9384 (freeze (bind CurryG (shen.curry G) V9743 V9744 K9384 (freeze (shen.system-S-h CurryG boolean V9742 V9743 V9744 K9384 (freeze (shen.cut V9743 V9744 K9384 (freeze (shen.t*-correct R V9741 (cons (cons CurryG (cons (intern ":") (cons verified ()))) V9742) V9743 V9744 K9384 V9746)))))))))))) false))) false))) false)) false)) false)) false) (if (= C9389 false) (let C9395 (if (shen.unlocked? V9744) (do (shen.incinfs) (shen.system-S-h (shen.curry V9740) V9741 V9742 V9743 V9744 K9384 V9746)) false) (if (= C9395 false) (shen.unlock V9744 K9384) C9395)) C9389))))

(defun shen.t*-integrity (V9747 V9748 V9749 V9750 V9751 V9752 V9753 V9754) (let C9409 (if (shen.unlocked? V9752) (let Tm9410 (shen.lazyderef V9747 V9751) (if (= Tm9410 ()) (do (shen.incinfs) (is! V9748 V9750 V9751 V9752 V9753 V9754)) false)) false) (if (= C9409 false) (if (shen.unlocked? V9752) (let Tm9411 (shen.lazyderef V9747 V9751) (if (cons? Tm9411) (let P (hd Tm9411) (let Ps (tl Tm9411) (let Tm9412 (shen.lazyderef V9748 V9751) (if (cons? Tm9412) (let A (hd Tm9412) (let Tm9413 (shen.lazyderef (tl Tm9412) V9751) (if (cons? Tm9413) (let Tm9414 (shen.lazyderef (hd Tm9413) V9751) (if (= Tm9414 -->) (let Tm9415 (shen.lazyderef (tl Tm9413) V9751) (if (cons? Tm9415) (let B (hd Tm9415) (let Tm9416 (shen.lazyderef (tl Tm9415) V9751) (if (= Tm9416 ()) (do (shen.incinfs) (shen.system-S-h P A V9749 V9751 V9752 V9753 (freeze (shen.t*-integrity Ps B V9749 V9750 V9751 V9752 V9753 V9754)))) false))) false)) false)) false))) false)))) false)) false) C9409)))

(defun shen.freshterm? (V9755) (and (absvector? V9755) (and (not (string? V9755)) (= (<-address V9755 0) shen.print-freshterm))))

