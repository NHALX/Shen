(defun shen.compile-prolog (V7162 V7163) (compile (lambda X (shen.<defprolog> X)) (cons V7162 V7163)))

(defun shen.<defprolog> (V7164) (let Result (if (shen.non-empty-stream? V7164) (let F (shen.hds V7164) (let News6956 (shen.tls V7164) (let Parseshen.<clauses> (shen.<clauses> News6956) (if (shen.parse-failure? Parseshen.<clauses>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<clauses>) (let Aritycheck (shen.prolog-arity-check F (shen.<-out Parseshen.<clauses>)) (let LeftLinear (map (lambda X (shen.linearise-clause X)) (shen.<-out Parseshen.<clauses>)) (shen.horn-clause-procedure F LeftLinear)))))))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<clauses> (V7165) (let Result (let Parseshen.<clause> (shen.<clause> V7165) (if (shen.parse-failure? Parseshen.<clause>) (shen.parse-failure) (let Parseshen.<clauses> (shen.<clauses> Parseshen.<clause>) (if (shen.parse-failure? Parseshen.<clauses>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<clauses>) (cons (shen.<-out Parseshen.<clause>) (shen.<-out Parseshen.<clauses>))))))) (if (shen.parse-failure? Result) (let Result (let Parse<!> (<!> V7165) (if (shen.parse-failure? Parse<!>) (shen.parse-failure) (shen.comb (shen.in-> Parse<!>) (if (empty? (shen.<-out Parse<!>)) () (simple-error (cn "Prolog syntax error here:
 " (shen.app (shen.<-out Parse<!>) "
 ..." shen.r))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.prolog-arity-check (V7170 V7171) (cond ((and (cons? V7171) (= () (tl V7171))) shen.skip) ((and (cons? V7171) (and (cons? (hd V7171)) (and (cons? (tl (hd V7171))) (= () (tl (tl (hd V7171))))))) (shen.pac-h V7170 (length (hd (hd V7171))) (tl V7171))) (true (shen.f-error shen.prolog-arity-check))))

(defun shen.linearise-clause (V7172) (cond ((and (cons? V7172) (and (cons? (tl V7172)) (= () (tl (tl V7172))))) (shen.lch (shen.linearise (@p (hd V7172) (hd (tl V7172)))))) (true (shen.f-error shen.linearise-clause))))

(defun shen.lch (V7173) (cond ((tuple? V7173) (cons (fst V7173) (cons (shen.lchh (snd V7173)) ()))) (true (shen.f-error shen.lch))))

(defun shen.lchh (V7174) (cond ((and (cons? V7174) (and (= where (hd V7174)) (and (cons? (tl V7174)) (and (cons? (hd (tl V7174))) (and (= = (hd (hd (tl V7174)))) (and (cons? (tl (hd (tl V7174)))) (and (cons? (tl (tl (hd (tl V7174))))) (and (= () (tl (tl (tl (hd (tl V7174)))))) (and (cons? (tl (tl V7174))) (= () (tl (tl (tl V7174))))))))))))) (cons (cons (if (value shen.*occurs*) is! is) (tl (hd (tl V7174)))) (shen.lchh (hd (tl (tl V7174)))))) (true V7174)))

(defun shen.pac-h (V7181 V7182 V7183) (cond ((= () V7183) true) ((and (cons? V7183) (cons? (hd V7183))) (if (= V7182 (length (hd (hd V7183)))) (shen.pac-h V7181 V7182 (tl V7183)) (simple-error (cn "arity error in prolog procedure " (shen.app V7181 "
" shen.a))))) (true (shen.f-error shen.pac-h))))

(defun shen.<clause> (V7184) (let Result (let Parseshen.<head> (shen.<head> V7184) (if (shen.parse-failure? Parseshen.<head>) (shen.parse-failure) (if (shen.=hd? Parseshen.<head> <--) (let News6959 (shen.tls Parseshen.<head>) (let Parseshen.<body> (shen.<body> News6959) (if (shen.parse-failure? Parseshen.<body>) (shen.parse-failure) (let Parseshen.<sc> (shen.<sc> Parseshen.<body>) (if (shen.parse-failure? Parseshen.<sc>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<sc>) (cons (shen.<-out Parseshen.<head>) (cons (shen.<-out Parseshen.<body>) ())))))))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<head> (V7185) (let Result (let Parseshen.<hterm> (shen.<hterm> V7185) (if (shen.parse-failure? Parseshen.<hterm>) (shen.parse-failure) (let Parseshen.<head> (shen.<head> Parseshen.<hterm>) (if (shen.parse-failure? Parseshen.<head>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<head>) (cons (shen.<-out Parseshen.<hterm>) (shen.<-out Parseshen.<head>))))))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V7185) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ()))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<hterm> (V7186) (let Result (if (shen.non-empty-stream? V7186) (let X (shen.hds V7186) (let News6962 (shen.tls V7186) (if (and (atom? X) (not (shen.prolog-keyword? X))) (shen.comb (shen.in-> News6962) X) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (if (shen.non-empty-stream? V7186) (let X (shen.hds V7186) (let News6963 (shen.tls V7186) (if (= X (intern ":")) (shen.comb (shen.in-> News6963) X) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (if (shen.ccons? V7186) (let SynCons (shen.comb (shen.hds V7186) (shen.<-out V7186)) (if (shen.=hd? SynCons cons) (let News6964 (shen.tls SynCons) (let Parseshen.<hterm1> (shen.<hterm1> News6964) (if (shen.parse-failure? Parseshen.<hterm1>) (shen.parse-failure) (let Parseshen.<hterm2> (shen.<hterm2> Parseshen.<hterm1>) (if (shen.parse-failure? Parseshen.<hterm2>) (shen.parse-failure) (let Parseshen.<end> (shen.<end> Parseshen.<hterm2>) (if (shen.parse-failure? Parseshen.<end>) (shen.parse-failure) (shen.comb (shen.in-> (shen.tlstream V7186)) (cons cons (cons (shen.<-out Parseshen.<hterm1>) (cons (shen.<-out Parseshen.<hterm2>) ()))))))))))) (shen.parse-failure))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (if (shen.ccons? V7186) (let SynCons (shen.comb (shen.hds V7186) (shen.<-out V7186)) (if (shen.=hd? SynCons +) (let News6965 (shen.tls SynCons) (let Parseshen.<hterm> (shen.<hterm> News6965) (if (shen.parse-failure? Parseshen.<hterm>) (shen.parse-failure) (let Parseshen.<end> (shen.<end> Parseshen.<hterm>) (if (shen.parse-failure? Parseshen.<end>) (shen.parse-failure) (shen.comb (shen.in-> (shen.tlstream V7186)) (cons shen.+m (cons (shen.<-out Parseshen.<hterm>) ())))))))) (shen.parse-failure))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (if (shen.ccons? V7186) (let SynCons (shen.comb (shen.hds V7186) (shen.<-out V7186)) (if (shen.=hd? SynCons -) (let News6966 (shen.tls SynCons) (let Parseshen.<hterm> (shen.<hterm> News6966) (if (shen.parse-failure? Parseshen.<hterm>) (shen.parse-failure) (let Parseshen.<end> (shen.<end> Parseshen.<hterm>) (if (shen.parse-failure? Parseshen.<end>) (shen.parse-failure) (shen.comb (shen.in-> (shen.tlstream V7186)) (cons shen.-m (cons (shen.<-out Parseshen.<hterm>) ())))))))) (shen.parse-failure))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (if (shen.ccons? V7186) (let SynCons (shen.comb (shen.hds V7186) (shen.<-out V7186)) (if (shen.=hd? SynCons mode) (let News6967 (shen.tls SynCons) (let Parseshen.<hterm> (shen.<hterm> News6967) (if (shen.parse-failure? Parseshen.<hterm>) (shen.parse-failure) (if (shen.=hd? Parseshen.<hterm> +) (let News6968 (shen.tls Parseshen.<hterm>) (let Parseshen.<end> (shen.<end> News6968) (if (shen.parse-failure? Parseshen.<end>) (shen.parse-failure) (shen.comb (shen.in-> (shen.tlstream V7186)) (cons shen.+m (cons (shen.<-out Parseshen.<hterm>) ())))))) (shen.parse-failure))))) (shen.parse-failure))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (if (shen.ccons? V7186) (let SynCons (shen.comb (shen.hds V7186) (shen.<-out V7186)) (if (shen.=hd? SynCons mode) (let News6969 (shen.tls SynCons) (let Parseshen.<hterm> (shen.<hterm> News6969) (if (shen.parse-failure? Parseshen.<hterm>) (shen.parse-failure) (if (shen.=hd? Parseshen.<hterm> -) (let News6970 (shen.tls Parseshen.<hterm>) (let Parseshen.<end> (shen.<end> News6970) (if (shen.parse-failure? Parseshen.<end>) (shen.parse-failure) (shen.comb (shen.in-> (shen.tlstream V7186)) (cons shen.-m (cons (shen.<-out Parseshen.<hterm>) ())))))) (shen.parse-failure))))) (shen.parse-failure))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)) Result)) Result)) Result)) Result)))

(defun shen.prolog-keyword? (V7187) (element? V7187 (cons (intern ";") (cons <-- ()))))

(defun atom? (V7188) (or (symbol? V7188) (or (string? V7188) (or (boolean? V7188) (or (number? V7188) (empty? V7188))))))

(defun shen.<hterm1> (V7189) (let Result (let Parseshen.<hterm> (shen.<hterm> V7189) (if (shen.parse-failure? Parseshen.<hterm>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<hterm>) (shen.<-out Parseshen.<hterm>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<hterm2> (V7190) (let Result (let Parseshen.<hterm> (shen.<hterm> V7190) (if (shen.parse-failure? Parseshen.<hterm>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<hterm>) (shen.<-out Parseshen.<hterm>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<body> (V7191) (let Result (let Parseshen.<literal> (shen.<literal> V7191) (if (shen.parse-failure? Parseshen.<literal>) (shen.parse-failure) (let Parseshen.<body> (shen.<body> Parseshen.<literal>) (if (shen.parse-failure? Parseshen.<body>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<body>) (cons (shen.<-out Parseshen.<literal>) (shen.<-out Parseshen.<body>))))))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V7191) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ()))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<literal> (V7192) (let Result (if (shen.=hd? V7192 !) (let News6975 (shen.tls V7192) (shen.comb (shen.in-> News6975) !)) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (if (shen.ccons? V7192) (let SynCons (shen.comb (shen.hds V7192) (shen.<-out V7192)) (let Parseshen.<bterms> (shen.<bterms> SynCons) (if (shen.parse-failure? Parseshen.<bterms>) (shen.parse-failure) (let Parseshen.<end> (shen.<end> Parseshen.<bterms>) (if (shen.parse-failure? Parseshen.<end>) (shen.parse-failure) (shen.comb (shen.in-> (shen.tlstream V7192)) (shen.<-out Parseshen.<bterms>))))))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<bterms> (V7193) (let Result (let Parseshen.<bterm> (shen.<bterm> V7193) (if (shen.parse-failure? Parseshen.<bterm>) (shen.parse-failure) (let Parseshen.<bterms> (shen.<bterms> Parseshen.<bterm>) (if (shen.parse-failure? Parseshen.<bterms>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<bterms>) (cons (shen.<-out Parseshen.<bterm>) (shen.<-out Parseshen.<bterms>))))))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V7193) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ()))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<bterm> (V7194) (let Result (let Parseshen.<wildcard> (shen.<wildcard> V7194) (if (shen.parse-failure? Parseshen.<wildcard>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<wildcard>) (shen.<-out Parseshen.<wildcard>)))) (if (shen.parse-failure? Result) (let Result (if (shen.non-empty-stream? V7194) (let X (shen.hds V7194) (let News6978 (shen.tls V7194) (if (atom? X) (shen.comb (shen.in-> News6978) X) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (if (shen.ccons? V7194) (let SynCons (shen.comb (shen.hds V7194) (shen.<-out V7194)) (let Parseshen.<bterms> (shen.<bterms> SynCons) (if (shen.parse-failure? Parseshen.<bterms>) (shen.parse-failure) (let Parseshen.<end> (shen.<end> Parseshen.<bterms>) (if (shen.parse-failure? Parseshen.<end>) (shen.parse-failure) (shen.comb (shen.in-> (shen.tlstream V7194)) (shen.<-out Parseshen.<bterms>))))))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)))

(defun shen.<wildcard> (V7195) (let Result (if (shen.non-empty-stream? V7195) (let X (shen.hds V7195) (let News6980 (shen.tls V7195) (if (= X _) (shen.comb (shen.in-> News6980) (gensym Y)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<sc> (V7196) (let Result (if (shen.non-empty-stream? V7196) (let X (shen.hds V7196) (let News6982 (shen.tls V7196) (if (shen.semicolon? X) (shen.comb (shen.in-> News6982) X) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.semicolon? (V7197) (= V7197 (intern ";")))

(defun shen.horn-clause-procedure (V7198 V7199) (let Bindings (gensym B) (let Lock (gensym L) (let Key (gensym K) (let Continuation (gensym C) (let Parameters (shen.prolog-parameters V7199) (let HasCut? (shen.hascut? V7199) (let FBody (shen.prolog-fbody V7199 Parameters Bindings Lock Key Continuation HasCut?) (let CutFBody (if HasCut? (cons let (cons Key (cons (cons + (cons Key (cons 1 ()))) (cons FBody ())))) FBody) (let Shen (cons define (cons V7198 (append Parameters (append (cons Bindings (cons Lock (cons Key (cons Continuation (cons -> ()))))) (cons CutFBody ()))))) Shen))))))))))

(defun shen.hascut? (V7202) (cond ((= ! V7202) true) ((cons? V7202) (or (shen.hascut? (hd V7202)) (shen.hascut? (tl V7202)))) (true false)))

(defun shen.prolog-parameters (V7207) (cond ((and (cons? V7207) (cons? (hd V7207))) (shen.parameters (length (hd (hd V7207))))) (true (shen.f-error shen.prolog-parameters))))

(defun shen.prolog-fbody (V7228 V7229 V7230 V7231 V7232 V7233 V7234) (cond ((and (= () V7228) (= true V7234)) (cons shen.unlock (cons V7231 (cons V7232 ())))) ((and (cons? V7228) (and (cons? (hd V7228)) (and (cons? (tl (hd V7228))) (and (= () (tl (tl (hd V7228)))) (and (= () (tl V7228)) (= false V7234)))))) (let Continue (shen.continue (hd (hd V7228)) (hd (tl (hd V7228))) V7230 V7231 V7232 V7233) (cons if (cons (cons shen.unlocked? (cons V7231 ())) (cons (shen.compile-head shen.+m (hd (hd V7228)) V7229 V7230 Continue) (cons false ())))))) ((and (cons? V7228) (and (cons? (hd V7228)) (and (cons? (tl (hd V7228))) (= () (tl (tl (hd V7228))))))) (let Case (gensym C) (let Continue (shen.continue (hd (hd V7228)) (hd (tl (hd V7228))) V7230 V7231 V7232 V7233) (cons let (cons Case (cons (cons if (cons (cons shen.unlocked? (cons V7231 ())) (cons (shen.compile-head shen.+m (hd (hd V7228)) V7229 V7230 Continue) (cons false ())))) (cons (cons if (cons (cons = (cons Case (cons false ()))) (cons (shen.prolog-fbody (tl V7228) V7229 V7230 V7231 V7232 V7233 V7234) (cons Case ())))) ()))))))) (true (simple-error "implementation error in shen.prolog-fbody"))))

(defun shen.unlock (V7235 V7236) (if (and (shen.locked? V7235) (shen.fits? V7236 V7235)) (shen.openlock V7235) false))

(defun shen.locked? (V7237) (not (shen.unlocked? V7237)))

(defun shen.unlocked? (V7238) (<-address V7238 1))

(defun shen.openlock (V7239) (do (address-> V7239 1 true) false))

(defun shen.fits? (V7240 V7241) (= V7240 (<-address V7241 2)))

(defun shen.cut (V7244 V7245 V7246 V7247) (let Compute (thaw V7247) (if (and (= Compute false) (shen.unlocked? V7245)) (shen.lock V7246 V7245) Compute)))

(defun shen.lock (V7248 V7249) (let SetLock (address-> V7249 1 false) (let SetKey (address-> V7249 2 V7248) false)))

(defun shen.continue (V7250 V7251 V7252 V7253 V7254 V7255) (let HVs (shen.extract-vars V7250) (let BVs (shen.extract-free-vars V7251) (let Free (difference BVs HVs) (let ContinuationCode (cons do (cons (cons shen.incinfs ()) (cons (shen.compile-body V7251 V7252 V7253 V7254 V7255) ()))) (shen.stpart Free ContinuationCode V7252))))))

(defun shen.extract-free-vars (V7258) (cond ((and (cons? V7258) (and (= lambda (hd V7258)) (and (cons? (tl V7258)) (and (cons? (tl (tl V7258))) (= () (tl (tl (tl V7258)))))))) (remove (hd (tl V7258)) (shen.extract-free-vars (hd (tl (tl V7258)))))) ((cons? V7258) (union (shen.extract-free-vars (hd V7258)) (shen.extract-free-vars (tl V7258)))) ((variable? V7258) (cons V7258 ())) (true ())))

(defun shen.compile-body (V7275 V7276 V7277 V7278 V7279) (cond ((= () V7275) (cons thaw (cons V7279 ()))) ((and (cons? V7275) (= ! (hd V7275))) (shen.compile-body (cons (cons shen.cut ()) (tl V7275)) V7276 V7277 V7278 V7279)) ((and (cons? V7275) (= () (tl V7275))) (append (shen.deref-calls (hd V7275) V7276) (cons V7276 (cons V7277 (cons V7278 (cons V7279 ())))))) ((cons? V7275) (let P* (shen.deref-calls (hd V7275) V7276) (append P* (cons V7276 (cons V7277 (cons V7278 (cons (shen.freeze-literals (tl V7275) V7276 V7277 V7278 V7279) ()))))))) (true (simple-error "implementation error in shen.compile-fbody"))))

(defun shen.freeze-literals (V7296 V7297 V7298 V7299 V7300) (cond ((= () V7296) V7300) ((and (cons? V7296) (= ! (hd V7296))) (shen.freeze-literals (cons (cons shen.cut ()) (tl V7296)) V7297 V7298 V7299 V7300)) ((cons? V7296) (let P* (shen.deref-calls (hd V7296) V7297) (cons freeze (cons (append P* (cons V7297 (cons V7298 (cons V7299 (cons (shen.freeze-literals (tl V7296) V7297 V7298 V7299 V7300) ()))))) ())))) (true (simple-error "implementation error in shen.freeze-literals"))))

(defun shen.deref-calls (V7305 V7306) (cond ((and (cons? V7305) (= fork (hd V7305))) (cons fork (cons (shen.deref-forked-literals (tl V7305) V7306) ()))) ((cons? V7305) (cons (hd V7305) (map (lambda Y (shen.function-calls Y V7306)) (tl V7305)))) (true (simple-error "implementation error in shen.deref-calls"))))

(defun shen.deref-forked-literals (V7313 V7314) (cond ((= () V7313) ()) ((cons? V7313) (cons cons (cons (shen.deref-calls (hd V7313) V7314) (cons (shen.deref-forked-literals (tl V7313) V7314) ())))) (true (simple-error "fork requires a list of literals
"))))

(defun shen.function-calls (V7317 V7318) (cond ((and (cons? V7317) (and (= cons (hd V7317)) (and (cons? (tl V7317)) (and (cons? (tl (tl V7317))) (= () (tl (tl (tl V7317)))))))) (cons cons (cons (shen.function-calls (hd (tl V7317)) V7318) (cons (shen.function-calls (hd (tl (tl V7317))) V7318) ())))) ((cons? V7317) (shen.deref-terms V7317 V7318 ())) (true V7317)))

(defun shen.deref-terms (V7327 V7328 V7329) (cond ((and (cons? V7327) (and (= 0 (hd V7327)) (and (cons? (tl V7327)) (= () (tl (tl V7327)))))) (if (variable? (hd (tl V7327))) (hd (tl V7327)) (simple-error (cn "attempt to optimise a non-variable " (shen.app (hd (tl V7327)) "
" shen.s))))) ((and (cons? V7327) (and (= 1 (hd V7327)) (and (cons? (tl V7327)) (= () (tl (tl V7327)))))) (if (variable? (hd (tl V7327))) (cons shen.lazyderef (cons (hd (tl V7327)) (cons V7328 ()))) (simple-error (cn "attempt to optimise a non-variable " (shen.app (hd (tl V7327)) "
" shen.s))))) ((and (not (element? V7327 V7329)) (variable? V7327)) (cons shen.deref (cons V7327 (cons V7328 ())))) ((and (cons? V7327) (and (= lambda (hd V7327)) (and (cons? (tl V7327)) (and (cons? (tl (tl V7327))) (= () (tl (tl (tl V7327)))))))) (cons lambda (cons (hd (tl V7327)) (cons (shen.deref-terms (hd (tl (tl V7327))) V7328 (cons (hd (tl V7327)) V7329)) ())))) ((cons? V7327) (map (lambda Z (shen.deref-terms Z V7328 V7329)) V7327)) (true V7327)))

(defun shen.compile-head (V7347 V7348 V7349 V7350 V7351) (cond ((and (= () V7348) (= () V7349)) V7351) ((and (cons? V7348) (and (cons? (hd V7348)) (and (= shen.+m (hd (hd V7348))) (and (cons? (tl (hd V7348))) (= () (tl (tl (hd V7348)))))))) (shen.compile-head V7347 (cons shen.+m (cons (hd (tl (hd V7348))) (cons V7347 (tl V7348)))) V7349 V7350 V7351)) ((and (cons? V7348) (and (cons? (hd V7348)) (and (= shen.-m (hd (hd V7348))) (and (cons? (tl (hd V7348))) (= () (tl (tl (hd V7348)))))))) (shen.compile-head V7347 (cons shen.-m (cons (hd (tl (hd V7348))) (cons V7347 (tl V7348)))) V7349 V7350 V7351)) ((and (cons? V7348) (= shen.-m (hd V7348))) (shen.compile-head shen.-m (tl V7348) V7349 V7350 V7351)) ((and (cons? V7348) (= shen.+m (hd V7348))) (shen.compile-head shen.+m (tl V7348) V7349 V7350 V7351)) ((and (cons? V7348) (and (cons? V7349) (shen.wildcard? (hd V7348)))) (shen.compile-head V7347 (tl V7348) (tl V7349) V7350 V7351)) ((and (cons? V7348) (variable? (hd V7348))) (shen.variable-case V7347 V7348 V7349 V7350 V7351)) ((and (= shen.-m V7347) (and (cons? V7348) (atom? (hd V7348)))) (shen.atom-case-minus V7348 V7349 V7350 V7351)) ((and (= shen.-m V7347) (and (cons? V7348) (and (cons? (hd V7348)) (and (= cons (hd (hd V7348))) (and (cons? (tl (hd V7348))) (and (cons? (tl (tl (hd V7348)))) (= () (tl (tl (tl (hd V7348))))))))))) (shen.cons-case-minus V7348 V7349 V7350 V7351)) ((and (= shen.+m V7347) (and (cons? V7348) (atom? (hd V7348)))) (shen.atom-case-plus V7348 V7349 V7350 V7351)) ((and (= shen.+m V7347) (and (cons? V7348) (and (cons? (hd V7348)) (and (= cons (hd (hd V7348))) (and (cons? (tl (hd V7348))) (and (cons? (tl (tl (hd V7348)))) (= () (tl (tl (tl (hd V7348))))))))))) (shen.cons-case-plus V7348 V7349 V7350 V7351)) (true (simple-error "implementation error in shen.compile-head"))))

(defun shen.variable-case (V7362 V7363 V7364 V7365 V7366) (cond ((and (cons? V7363) (cons? V7364)) (if (variable? (hd V7364)) (shen.compile-head V7362 (tl V7363) (tl V7364) V7365 (subst (hd V7364) (hd V7363) V7366)) (cons let (cons (hd V7363) (cons (hd V7364) (cons (shen.compile-head V7362 (tl V7363) (tl V7364) V7365 V7366) ())))))) (true (simple-error "implementation error in shen.variable-case"))))

(defun shen.atom-case-minus (V7375 V7376 V7377 V7378) (cond ((and (cons? V7375) (cons? V7376)) (let Tm (gensym Tm) (cons let (cons Tm (cons (cons shen.lazyderef (cons (hd V7376) (cons V7377 ()))) (cons (cons if (cons (cons = (cons Tm (cons (hd V7375) ()))) (cons (shen.compile-head shen.-m (tl V7375) (tl V7376) V7377 V7378) (cons false ())))) ())))))) (true (simple-error "implementation error in shen.atom-case-minus"))))

(defun shen.cons-case-minus (V7387 V7388 V7389 V7390) (cond ((and (cons? V7387) (and (cons? (hd V7387)) (and (= cons (hd (hd V7387))) (and (cons? (tl (hd V7387))) (and (cons? (tl (tl (hd V7387)))) (and (= () (tl (tl (tl (hd V7387))))) (cons? V7388))))))) (let Tm (gensym Tm) (cons let (cons Tm (cons (cons shen.lazyderef (cons (hd V7388) (cons V7389 ()))) (cons (cons if (cons (cons cons? (cons Tm ())) (cons (shen.compile-head shen.-m (cons (hd (tl (hd V7387))) (cons (hd (tl (tl (hd V7387)))) (tl V7387))) (cons (cons hd (cons Tm ())) (cons (cons tl (cons Tm ())) (tl V7388))) V7389 V7390) (cons false ())))) ())))))) (true (simple-error "implementation error in shen.cons-case-minus"))))

(defun shen.atom-case-plus (V7399 V7400 V7401 V7402) (cond ((and (cons? V7399) (cons? V7400)) (let Tm (gensym Tm) (let GoTo (gensym GoTo) (cons let (cons Tm (cons (cons shen.lazyderef (cons (hd V7400) (cons V7401 ()))) (cons GoTo (cons (cons freeze (cons (shen.compile-head shen.+m (tl V7399) (tl V7400) V7401 V7402) ())) (cons (cons if (cons (cons = (cons Tm (cons (hd V7399) ()))) (cons (cons thaw (cons GoTo ())) (cons (cons if (cons (cons shen.pvar? (cons Tm ())) (cons (cons shen.bind! (cons Tm (cons (shen.demode (hd V7399)) (cons V7401 (cons GoTo ()))))) (cons false ())))) ())))) ()))))))))) (true (simple-error "implementation error in shen.atom-case-plus"))))

(defun shen.cons-case-plus (V7411 V7412 V7413 V7414) (cond ((and (cons? V7411) (and (cons? (hd V7411)) (and (= cons (hd (hd V7411))) (and (cons? (tl (hd V7411))) (and (cons? (tl (tl (hd V7411)))) (and (= () (tl (tl (tl (hd V7411))))) (cons? V7412))))))) (let Tm (gensym Tm) (let GoTo (gensym GoTo) (let Vars (shen.extract-vars (cons (hd (tl (hd V7411))) (hd (tl (tl (hd V7411)))))) (let Tame (shen.tame (hd V7411)) (let TVars (shen.extract-vars Tame) (cons let (cons Tm (cons (cons shen.lazyderef (cons (hd V7412) (cons V7413 ()))) (cons GoTo (cons (shen.goto Vars (shen.compile-head shen.+m (tl V7411) (tl V7412) V7413 V7414)) (cons (cons if (cons (cons cons? (cons Tm ())) (cons (shen.compile-head shen.+m (tl (hd V7411)) (cons (cons hd (cons Tm ())) (cons (cons tl (cons Tm ())) ())) V7413 (shen.invoke GoTo Vars)) (cons (cons if (cons (cons shen.pvar? (cons Tm ())) (cons (shen.stpart TVars (cons shen.bind! (cons Tm (cons (shen.demode Tame) (cons V7413 (cons (cons freeze (cons (shen.invoke GoTo Vars) ())) ()))))) V7413) (cons false ())))) ())))) ())))))))))))) (true (simple-error "implementation error in shen.cons-case-plus"))))

(defun shen.demode (V7415) (cond ((and (cons? V7415) (and (= shen.+m (hd V7415)) (and (cons? (tl V7415)) (= () (tl (tl V7415)))))) (shen.demode (hd (tl V7415)))) ((and (cons? V7415) (and (= shen.-m (hd V7415)) (and (cons? (tl V7415)) (= () (tl (tl V7415)))))) (shen.demode (hd (tl V7415)))) ((cons? V7415) (map (lambda Z (shen.demode Z)) V7415)) (true V7415)))

(defun shen.tame (V7416) (cond ((shen.wildcard? V7416) (gensym Y)) ((cons? V7416) (map (lambda Z (shen.tame Z)) V7416)) (true V7416)))

(defun shen.goto (V7417 V7418) (cond ((= () V7417) (cons freeze (cons V7418 ()))) (true (shen.goto-h V7417 V7418))))

(defun shen.goto-h (V7419 V7420) (cond ((= () V7419) V7420) ((cons? V7419) (cons lambda (cons (hd V7419) (cons (shen.goto-h (tl V7419) V7420) ())))) (true (shen.f-error shen.goto-h))))

(defun shen.invoke (V7421 V7422) (cond ((= () V7422) (cons thaw (cons V7421 ()))) (true (cons V7421 V7422))))

(defun shen.wildcard? (V7423) (= V7423 _))

(defun shen.pvar? (V7424) (trap-error (and (absvector? V7424) (= (<-address V7424 0) shen.pvar)) (lambda E false)))

(defun shen.lazyderef (V7425 V7426) (if (shen.pvar? V7425) (let Value (<-address V7426 (<-address V7425 1)) (if (= Value shen.-null-) V7425 (shen.lazyderef Value V7426))) V7425))

(defun shen.deref (V7427 V7428) (cond ((cons? V7427) (cons (shen.deref (hd V7427) V7428) (shen.deref (tl V7427) V7428))) (true (if (shen.pvar? V7427) (let Value (<-address V7428 (<-address V7427 1)) (if (= Value shen.-null-) V7427 (shen.deref Value V7428))) V7427))))

(defun shen.bind! (V7429 V7430 V7431 V7432) (let Bind (shen.bindv V7429 V7430 V7431) (let Compute (thaw V7432) (if (= Compute false) (shen.unwind V7429 V7431 Compute) Compute))))

(defun shen.bindv (V7433 V7434 V7435) (address-> V7435 (<-address V7433 1) V7434))

(defun shen.unwind (V7436 V7437 V7438) (do (address-> V7437 (<-address V7436 1) shen.-null-) V7438))

(defun shen.stpart (V7447 V7448 V7449) (cond ((= () V7447) V7448) ((cons? V7447) (cons let (cons (hd V7447) (cons (cons shen.newpv (cons V7449 ())) (cons (cons shen.gc (cons V7449 (cons (shen.stpart (tl V7447) V7448 V7449) ()))) ()))))) (true (simple-error "implementation error in shen.stpart"))))

(defun shen.gc (V7450 V7451) (if (= V7451 false) (let N (shen.ticket-number V7450) (do (shen.decrement-ticket N V7450) V7451)) V7451))

(defun shen.decrement-ticket (V7452 V7453) (address-> V7453 1 (- V7452 1)))

(defun shen.newpv (V7454) (let N (shen.ticket-number V7454) (let NewBindings (shen.make-prolog-variable N) (let NextTicket (shen.nextticket V7454 N) NewBindings))))

(defun shen.ticket-number (V7455) (<-address V7455 1))

(defun shen.nextticket (V7456 V7457) (let NewVector (address-> V7456 V7457 shen.-null-) (address-> NewVector 1 (+ V7457 1))))

(defun shen.make-prolog-variable (V7458) (address-> (address-> (absvector 2) 0 shen.pvar) 1 V7458))

(defun shen.pvar (V7459) (cn "Var" (shen.app (<-address V7459 1) "" shen.a)))

(defun shen.incinfs () (set shen.*infs* (+ 1 (value shen.*infs*))))

(defun shen.prolog-vector-size (V7460) (if (and (integer? V7460) (> V7460 0)) (set shen.*size-prolog-vector* V7460) (simple-error (cn "prolog vector size: size should be a positive integer; not " (shen.app V7460 "" shen.a)))))

(defun shen.lzy=! (V7472 V7473 V7474 V7475) (cond ((= V7472 V7473) (thaw V7475)) ((and (shen.pvar? V7472) (not (shen.occurs? V7472 (shen.deref V7473 V7474)))) (shen.bind! V7472 V7473 V7474 V7475)) ((and (shen.pvar? V7473) (not (shen.occurs? V7473 (shen.deref V7472 V7474)))) (shen.bind! V7473 V7472 V7474 V7475)) ((and (cons? V7472) (cons? V7473)) (shen.lzy=! (shen.lazyderef (hd V7472) V7474) (shen.lazyderef (hd V7473) V7474) V7474 (freeze (shen.lzy=! (shen.lazyderef (tl V7472) V7474) (shen.lazyderef (tl V7473) V7474) V7474 V7475)))) (true false)))

(defun shen.lzy= (V7487 V7488 V7489 V7490) (cond ((= V7487 V7488) (thaw V7490)) ((shen.pvar? V7487) (shen.bind! V7487 V7488 V7489 V7490)) ((shen.pvar? V7488) (shen.bind! V7488 V7487 V7489 V7490)) ((and (cons? V7487) (cons? V7488)) (shen.lzy= (shen.lazyderef (hd V7487) V7489) (shen.lazyderef (hd V7488) V7489) V7489 (freeze (shen.lzy= (shen.lazyderef (tl V7487) V7489) (shen.lazyderef (tl V7488) V7489) V7489 V7490)))) (true false)))

(defun shen.occurs? (V7496 V7497) (cond ((= V7496 V7497) true) ((cons? V7497) (or (shen.occurs? V7496 (hd V7497)) (shen.occurs? V7496 (tl V7497)))) (true false)))

(defun call (V7498 V7499 V7500 V7501 V7502) ((((V7498 V7499) V7500) V7501) V7502))

(defun return (V7509 V7510 V7511 V7512 V7513) (shen.deref V7509 V7510))

(defun when (V7520 V7521 V7522 V7523 V7524) (if V7520 (thaw V7524) false))

(defun is (V7525 V7526 V7527 V7528 V7529 V7530) (shen.lzy= (shen.lazyderef V7525 V7527) (shen.lazyderef V7526 V7527) V7527 V7530))

(defun is! (V7531 V7532 V7533 V7534 V7535 V7536) (shen.lzy=! (shen.lazyderef V7531 V7533) (shen.lazyderef V7532 V7533) V7533 V7536))

(defun bind (V7541 V7542 V7543 V7544 V7545 V7546) (shen.bind! V7541 V7542 V7543 V7546))

(defun var? (V7547 V7548 V7549 V7550 V7551) (if (shen.pvar? (shen.lazyderef V7547 V7548)) (thaw V7551) false))

(defun shen.print-prolog-vector (V7554) "|prolog vector|")

(defun fork (V7573 V7574 V7575 V7576 V7577) (cond ((= () V7573) false) ((cons? V7573) (let Case (((((hd V7573) V7574) V7575) V7576) V7577) (if (= Case false) (fork (tl V7573) V7574 V7575 V7576 V7577) Case))) (true (simple-error "fork expects a list of literals
"))))

(defun findall (V7578 V7579 V7580 V7581 V7582 V7583 V7584) (if (shen.unlocked? V7582) (let Store (shen.newpv V7581) (shen.gc V7581 (do (shen.incinfs) (is Store () V7581 V7582 V7583 (freeze (shen.findall-h V7578 V7579 V7580 Store V7581 V7582 V7583 V7584)))))) false))

(defun shen.findall-h (V7585 V7586 V7587 V7588 V7589 V7590 V7591 V7592) (let C6999 (if (shen.unlocked? V7590) (do (shen.incinfs) (call V7586 V7589 V7590 V7591 (freeze (shen.overbind V7585 V7588 V7589 V7590 V7591 V7592)))) false) (if (= C6999 false) (if (shen.unlocked? V7590) (do (shen.incinfs) (is! V7587 V7588 V7589 V7590 V7591 V7592)) false) C6999)))

(defun shen.overbind (V7599 V7600 V7601 V7602 V7603 V7604) (do (shen.bindv V7600 (cons (shen.deref V7599 V7601) (shen.lazyderef V7600 V7601)) V7601) false))

(defun occurs-check (V7607) (cond ((= + V7607) (set shen.*occurs* true)) ((= - V7607) (set shen.*occurs* false)) (true (simple-error "occurs-check expects a + or a -.
"))))

