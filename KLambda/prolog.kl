(defun shen.compile-prolog (V2432 V2433) (compile (lambda Z2434 (shen.<defprolog> Z2434)) (cons V2432 V2433)))

(defun dynamic (V2435) (set shen.*dynamic* (cons V2435 (value shen.*dynamic*))))

(defun shen.<defprolog> (V2436) (let W2437 (if (shen.non-empty-stream? V2436) (let W2438 (shen.hds V2436) (let W2439 (shen.tls V2436) (let W2440 (shen.<clauses> W2439) (if (shen.parse-failure? W2440) (shen.parse-failure) (shen.comb (shen.in-> W2440) (let W2441 (shen.prolog-arity-check W2438 (shen.<-out W2440)) (let W2442 (map (lambda Z2443 (shen.linearise-clause Z2443)) (shen.<-out W2440)) (let W2444 (shen.parameters W2441) (let W2445 (if (shen.dynamic? W2438) (append (shen.clauseA W2438 W2444) (append W2442 (shen.clauseZ W2438 W2444))) W2442) (shen.horn-clause-procedure W2438 W2445)))))))))) (shen.parse-failure)) (if (shen.parse-failure? W2437) (shen.parse-failure) W2437)))

(defun shen.dynamic? (V2446) (element? V2446 (value shen.*dynamic*)))

(defun shen.clauseA (V2447 V2448) (let W2449 (concat V2447 A) (let W2450 (cons (cons when (cons (cons shen.defined? (cons W2449 ())) ())) (cons (cons W2449 V2448) ())) (let W2451 (cons V2448 (cons W2450 ())) (cons W2451 ())))))

(defun shen.clauseZ (V2452 V2453) (let W2454 (concat V2452 Z) (let W2455 (cons (cons when (cons (cons shen.defined? (cons W2454 ())) ())) (cons (cons W2454 V2453) ())) (let W2456 (cons V2453 (cons W2455 ())) (cons W2456 ())))))

(defun shen.defined? (V2457) (not (= (arity V2457) -1)))

(defun asserta (V2458 V2459 V2460 V2461 V2462) (if (shen.unlocked? V2460) (do (shen.incinfs) (shen.execute (shen.asserta-h (shen.deref V2458 V2459) (shen.deref V2458 V2459)) V2459 V2460 V2461 V2462)) false))

(defun shen.asserta-h (V2465 V2466) (cond ((and (cons? V2465) (and (cons? (hd V2465)) (and (cons? (tl V2465)) (and (= <-- (hd (tl V2465))) (not (shen.defined? (hd (hd V2465)))))))) (shen.dynamically-assert V2465 V2466)) ((and (cons? V2466) (and (cons? (hd V2466)) (and (cons? (tl V2466)) (= <-- (hd (tl V2466)))))) (let W2467 (concat (hd (hd V2466)) A) (if (shen.defined? (hd (hd V2466))) (shen.asserta-h V2465 (cons (cons W2467 (tl (hd V2466))) (tl V2466))) (shen.dynamically-assert V2465 V2466)))) (true (simple-error (cn "
non-clause " (shen.app V2465 " given to asserta
" shen.r))))))

(defun shen.dynamically-assert (V2468 V2469) (cond ((and (cons? V2469) (and (cons? (hd V2469)) (and (cons? (tl V2469)) (= <-- (hd (tl V2469)))))) (let W2470 (dynamic (hd (hd V2469))) (let W2471 (shen.flag-unretracted (hd (hd V2469))) (let W2472 (put V2468 shen.procedure-name (hd (hd V2469)) (value *property-vector*)) (eval (cons defprolog (cons (hd (hd V2469)) (append (tl (hd V2469)) (append (cons <-- ()) (append (cons (cons when (cons (cons shen.unretracted? (cons (hd (hd V2469)) ())) ())) ()) (tl (tl V2469)))))))))))) (true (shen.f-error shen.dynamically-assert))))

(defun assertz (V2473 V2474 V2475 V2476 V2477) (if (shen.unlocked? V2475) (do (shen.incinfs) (shen.execute (shen.assertz-h (shen.deref V2473 V2474) (shen.deref V2473 V2474)) V2474 V2475 V2476 V2477)) false))

(defun shen.execute (V2478 V2479 V2480 V2481 V2482) (if (shen.unlocked? V2480) (do (shen.incinfs) (thaw V2482)) false))

(defun shen.assertz-h (V2485 V2486) (cond ((and (cons? V2485) (and (cons? (hd V2485)) (and (cons? (tl V2485)) (and (= <-- (hd (tl V2485))) (not (shen.defined? (hd (hd V2485)))))))) (shen.dynamically-assert V2485 V2486)) ((and (cons? V2486) (and (cons? (hd V2486)) (and (cons? (tl V2486)) (= <-- (hd (tl V2486)))))) (let W2487 (concat (hd (hd V2486)) Z) (if (shen.defined? (hd (hd V2486))) (shen.assertz-h V2485 (cons (cons W2487 (tl (hd V2486))) (tl V2486))) (shen.dynamically-assert V2485 V2486)))) (true (simple-error (cn "
non-clause " (shen.app V2485 " given to assertz
" shen.r))))))

(defun shen.flag-unretracted (V2488) (put V2488 shen.retracted false (value *property-vector*)))

(defun shen.flag-retracted (V2489) (put V2489 shen.retracted true (value *property-vector*)))

(defun shen.unretracted? (V2490) (trap-error (not (get V2490 shen.retracted (value *property-vector*))) (lambda Z2491 true)))

(defun retract (V2492 V2493 V2494 V2495 V2496) (if (shen.unlocked? V2494) (do (shen.incinfs) (shen.execute (shen.retract-h (shen.deref V2492 V2493)) V2493 V2494 V2495 V2496)) false))

(defun shen.retract-h (V2497) (let W2498 (trap-error (get V2497 shen.procedure-name (value *property-vector*)) (lambda Z2499 shen.skip)) (if (= W2498 shen.skip) shen.skip (shen.flag-retracted W2498))))

(defun shen.prolog-arity-check (V2502 V2503) (cond ((and (cons? V2503) (and (cons? (hd V2503)) (and (cons? (tl (hd V2503))) (and (= () (tl (tl (hd V2503)))) (= () (tl V2503)))))) (length (hd (hd V2503)))) ((and (cons? V2503) (and (cons? (hd V2503)) (and (cons? (tl (hd V2503))) (= () (tl (tl (hd V2503))))))) (shen.pac-h V2502 (length (hd (hd V2503))) (tl V2503))) (true (shen.f-error shen.prolog-arity-check))))

(defun shen.pac-h (V2508 V2509 V2510) (cond ((= () V2510) V2509) ((and (cons? V2510) (cons? (hd V2510))) (if (= V2509 (length (hd (hd V2510)))) (shen.pac-h V2508 V2509 (tl V2510)) (simple-error (cn "arity error in prolog procedure " (shen.app V2508 "
" shen.a))))) (true (shen.f-error shen.pac-h))))

(defun shen.<clauses> (V2511) (let W2512 (let W2513 (shen.<clause> V2511) (if (shen.parse-failure? W2513) (shen.parse-failure) (let W2514 (shen.<clauses> W2513) (if (shen.parse-failure? W2514) (shen.parse-failure) (shen.comb (shen.in-> W2514) (cons (shen.<-out W2513) (shen.<-out W2514))))))) (if (shen.parse-failure? W2512) (let W2515 (let W2516 (<!> V2511) (if (shen.parse-failure? W2516) (shen.parse-failure) (shen.comb (shen.in-> W2516) (if (empty? (shen.<-out W2516)) () (simple-error (cn "Prolog syntax error here:
 " (shen.app (shen.<-out W2516) "
 ..." shen.r))))))) (if (shen.parse-failure? W2515) (shen.parse-failure) W2515)) W2512)))

(defun shen.linearise-clause (V2517) (cond ((and (cons? V2517) (and (cons? (tl V2517)) (= () (tl (tl V2517))))) (shen.lch (shen.linearise (@p (hd V2517) (hd (tl V2517)))))) (true (shen.f-error shen.linearise-clause))))

(defun shen.lch (V2518) (cond ((tuple? V2518) (cons (fst V2518) (cons (shen.lchh (snd V2518)) ()))) (true (shen.f-error shen.lch))))

(defun shen.lchh (V2519) (cond ((and (cons? V2519) (and (= where (hd V2519)) (and (cons? (tl V2519)) (and (cons? (hd (tl V2519))) (and (= = (hd (hd (tl V2519)))) (and (cons? (tl (hd (tl V2519)))) (and (cons? (tl (tl (hd (tl V2519))))) (and (= () (tl (tl (tl (hd (tl V2519)))))) (and (cons? (tl (tl V2519))) (= () (tl (tl (tl V2519))))))))))))) (cons (cons (if (value shen.*occurs*) is! is) (tl (hd (tl V2519)))) (shen.lchh (hd (tl (tl V2519)))))) (true V2519)))

(defun shen.<clause> (V2520) (let W2521 (let W2522 (shen.<head> V2520) (if (shen.parse-failure? W2522) (shen.parse-failure) (if (shen.=hd? W2522 <--) (let W2523 (shen.tls W2522) (let W2524 (shen.<body> W2523) (if (shen.parse-failure? W2524) (shen.parse-failure) (let W2525 (shen.<sc> W2524) (if (shen.parse-failure? W2525) (shen.parse-failure) (shen.comb (shen.in-> W2525) (cons (shen.<-out W2522) (cons (shen.<-out W2524) ())))))))) (shen.parse-failure)))) (if (shen.parse-failure? W2521) (shen.parse-failure) W2521)))

(defun shen.<head> (V2526) (let W2527 (let W2528 (shen.<hterm> V2526) (if (shen.parse-failure? W2528) (shen.parse-failure) (let W2529 (shen.<head> W2528) (if (shen.parse-failure? W2529) (shen.parse-failure) (shen.comb (shen.in-> W2529) (cons (shen.<-out W2528) (shen.<-out W2529))))))) (if (shen.parse-failure? W2527) (let W2530 (let W2531 (<e> V2526) (if (shen.parse-failure? W2531) (shen.parse-failure) (shen.comb (shen.in-> W2531) ()))) (if (shen.parse-failure? W2530) (shen.parse-failure) W2530)) W2527)))

(defun shen.<hterm> (V2532) (let W2533 (if (shen.non-empty-stream? V2532) (let W2534 (shen.hds V2532) (let W2535 (shen.tls V2532) (if (and (atom? W2534) (not (shen.prolog-keyword? W2534))) (shen.comb (shen.in-> W2535) W2534) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W2533) (let W2536 (if (shen.non-empty-stream? V2532) (let W2537 (shen.hds V2532) (let W2538 (shen.tls V2532) (if (= W2537 (intern ":")) (shen.comb (shen.in-> W2538) W2537) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W2536) (let W2539 (if (shen.ccons? V2532) (let W2540 (shen.comb (shen.hds V2532) (shen.<-out V2532)) (if (shen.=hd? W2540 cons) (let W2541 (shen.tls W2540) (let W2542 (shen.<hterm1> W2541) (if (shen.parse-failure? W2542) (shen.parse-failure) (let W2543 (shen.<hterm2> W2542) (if (shen.parse-failure? W2543) (shen.parse-failure) (let W2544 (shen.<end> W2543) (if (shen.parse-failure? W2544) (shen.parse-failure) (shen.comb (shen.in-> (shen.tlstream V2532)) (cons cons (cons (shen.<-out W2542) (cons (shen.<-out W2543) ()))))))))))) (shen.parse-failure))) (shen.parse-failure)) (if (shen.parse-failure? W2539) (let W2545 (if (shen.ccons? V2532) (let W2546 (shen.comb (shen.hds V2532) (shen.<-out V2532)) (if (shen.=hd? W2546 +) (let W2547 (shen.tls W2546) (let W2548 (shen.<hterm> W2547) (if (shen.parse-failure? W2548) (shen.parse-failure) (let W2549 (shen.<end> W2548) (if (shen.parse-failure? W2549) (shen.parse-failure) (shen.comb (shen.in-> (shen.tlstream V2532)) (cons shen.+m (cons (shen.<-out W2548) ())))))))) (shen.parse-failure))) (shen.parse-failure)) (if (shen.parse-failure? W2545) (let W2550 (if (shen.ccons? V2532) (let W2551 (shen.comb (shen.hds V2532) (shen.<-out V2532)) (if (shen.=hd? W2551 -) (let W2552 (shen.tls W2551) (let W2553 (shen.<hterm> W2552) (if (shen.parse-failure? W2553) (shen.parse-failure) (let W2554 (shen.<end> W2553) (if (shen.parse-failure? W2554) (shen.parse-failure) (shen.comb (shen.in-> (shen.tlstream V2532)) (cons shen.-m (cons (shen.<-out W2553) ())))))))) (shen.parse-failure))) (shen.parse-failure)) (if (shen.parse-failure? W2550) (let W2555 (if (shen.ccons? V2532) (let W2556 (shen.comb (shen.hds V2532) (shen.<-out V2532)) (if (shen.=hd? W2556 mode) (let W2557 (shen.tls W2556) (let W2558 (shen.<hterm> W2557) (if (shen.parse-failure? W2558) (shen.parse-failure) (if (shen.=hd? W2558 +) (let W2559 (shen.tls W2558) (let W2560 (shen.<end> W2559) (if (shen.parse-failure? W2560) (shen.parse-failure) (shen.comb (shen.in-> (shen.tlstream V2532)) (cons shen.+m (cons (shen.<-out W2558) ())))))) (shen.parse-failure))))) (shen.parse-failure))) (shen.parse-failure)) (if (shen.parse-failure? W2555) (let W2561 (if (shen.ccons? V2532) (let W2562 (shen.comb (shen.hds V2532) (shen.<-out V2532)) (if (shen.=hd? W2562 mode) (let W2563 (shen.tls W2562) (let W2564 (shen.<hterm> W2563) (if (shen.parse-failure? W2564) (shen.parse-failure) (if (shen.=hd? W2564 -) (let W2565 (shen.tls W2564) (let W2566 (shen.<end> W2565) (if (shen.parse-failure? W2566) (shen.parse-failure) (shen.comb (shen.in-> (shen.tlstream V2532)) (cons shen.-m (cons (shen.<-out W2564) ())))))) (shen.parse-failure))))) (shen.parse-failure))) (shen.parse-failure)) (if (shen.parse-failure? W2561) (shen.parse-failure) W2561)) W2555)) W2550)) W2545)) W2539)) W2536)) W2533)))

(defun shen.prolog-keyword? (V2567) (element? V2567 (cons (intern ";") (cons <-- ()))))

(defun atom? (V2568) (or (symbol? V2568) (or (string? V2568) (or (boolean? V2568) (or (number? V2568) (empty? V2568))))))

(defun shen.<hterm1> (V2569) (let W2570 (let W2571 (shen.<hterm> V2569) (if (shen.parse-failure? W2571) (shen.parse-failure) (shen.comb (shen.in-> W2571) (shen.<-out W2571)))) (if (shen.parse-failure? W2570) (shen.parse-failure) W2570)))

(defun shen.<hterm2> (V2572) (let W2573 (let W2574 (shen.<hterm> V2572) (if (shen.parse-failure? W2574) (shen.parse-failure) (shen.comb (shen.in-> W2574) (shen.<-out W2574)))) (if (shen.parse-failure? W2573) (shen.parse-failure) W2573)))

(defun shen.<body> (V2575) (let W2576 (let W2577 (shen.<literal> V2575) (if (shen.parse-failure? W2577) (shen.parse-failure) (let W2578 (shen.<body> W2577) (if (shen.parse-failure? W2578) (shen.parse-failure) (shen.comb (shen.in-> W2578) (cons (shen.<-out W2577) (shen.<-out W2578))))))) (if (shen.parse-failure? W2576) (let W2579 (let W2580 (<e> V2575) (if (shen.parse-failure? W2580) (shen.parse-failure) (shen.comb (shen.in-> W2580) ()))) (if (shen.parse-failure? W2579) (shen.parse-failure) W2579)) W2576)))

(defun shen.<literal> (V2581) (let W2582 (if (shen.=hd? V2581 !) (let W2583 (shen.tls V2581) (shen.comb (shen.in-> W2583) !)) (shen.parse-failure)) (if (shen.parse-failure? W2582) (let W2584 (if (shen.ccons? V2581) (let W2585 (shen.comb (shen.hds V2581) (shen.<-out V2581)) (let W2586 (shen.<bterms> W2585) (if (shen.parse-failure? W2586) (shen.parse-failure) (let W2587 (shen.<end> W2586) (if (shen.parse-failure? W2587) (shen.parse-failure) (shen.comb (shen.in-> (shen.tlstream V2581)) (shen.<-out W2586))))))) (shen.parse-failure)) (if (shen.parse-failure? W2584) (shen.parse-failure) W2584)) W2582)))

(defun shen.<bterms> (V2588) (let W2589 (let W2590 (shen.<bterm> V2588) (if (shen.parse-failure? W2590) (shen.parse-failure) (let W2591 (shen.<bterms> W2590) (if (shen.parse-failure? W2591) (shen.parse-failure) (shen.comb (shen.in-> W2591) (cons (shen.<-out W2590) (shen.<-out W2591))))))) (if (shen.parse-failure? W2589) (let W2592 (let W2593 (<e> V2588) (if (shen.parse-failure? W2593) (shen.parse-failure) (shen.comb (shen.in-> W2593) ()))) (if (shen.parse-failure? W2592) (shen.parse-failure) W2592)) W2589)))

(defun shen.<bterm> (V2594) (let W2595 (let W2596 (shen.<wildcard> V2594) (if (shen.parse-failure? W2596) (shen.parse-failure) (shen.comb (shen.in-> W2596) (shen.<-out W2596)))) (if (shen.parse-failure? W2595) (let W2597 (if (shen.non-empty-stream? V2594) (let W2598 (shen.hds V2594) (let W2599 (shen.tls V2594) (if (atom? W2598) (shen.comb (shen.in-> W2599) W2598) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W2597) (let W2600 (if (shen.ccons? V2594) (let W2601 (shen.comb (shen.hds V2594) (shen.<-out V2594)) (let W2602 (shen.<bterms> W2601) (if (shen.parse-failure? W2602) (shen.parse-failure) (let W2603 (shen.<end> W2602) (if (shen.parse-failure? W2603) (shen.parse-failure) (shen.comb (shen.in-> (shen.tlstream V2594)) (shen.<-out W2602))))))) (shen.parse-failure)) (if (shen.parse-failure? W2600) (shen.parse-failure) W2600)) W2597)) W2595)))

(defun shen.<wildcard> (V2604) (let W2605 (if (shen.non-empty-stream? V2604) (let W2606 (shen.hds V2604) (let W2607 (shen.tls V2604) (if (= W2606 _) (shen.comb (shen.in-> W2607) (gensym Y)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W2605) (shen.parse-failure) W2605)))

(defun shen.<sc> (V2608) (let W2609 (if (shen.non-empty-stream? V2608) (let W2610 (shen.hds V2608) (let W2611 (shen.tls V2608) (if (shen.semicolon? W2610) (shen.comb (shen.in-> W2611) W2610) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W2609) (shen.parse-failure) W2609)))

(defun shen.semicolon? (V2612) (= V2612 (intern ";")))

(defun shen.horn-clause-procedure (V2613 V2614) (let W2615 (gensym B) (let W2616 (gensym L) (let W2617 (gensym K) (let W2618 (gensym C) (let W2619 (shen.prolog-parameters V2614) (let W2620 (shen.hascut? V2614) (let W2621 (shen.prolog-fbody V2614 W2619 W2615 W2616 W2617 W2618 W2620) (let W2622 (if W2620 (cons let (cons W2617 (cons (cons + (cons W2617 (cons 1 ()))) (cons W2621 ())))) W2621) (let W2623 (cons define (cons V2613 (append W2619 (append (cons W2615 (cons W2616 (cons W2617 (cons W2618 (cons -> ()))))) (cons W2622 ()))))) W2623))))))))))

(defun shen.hascut? (V2626) (cond ((= ! V2626) true) ((cons? V2626) (or (shen.hascut? (hd V2626)) (shen.hascut? (tl V2626)))) (true false)))

(defun shen.prolog-parameters (V2631) (cond ((and (cons? V2631) (cons? (hd V2631))) (shen.parameters (length (hd (hd V2631))))) (true (shen.f-error shen.prolog-parameters))))

(defun shen.prolog-fbody (V2652 V2653 V2654 V2655 V2656 V2657 V2658) (cond ((and (= () V2652) (= true V2658)) (cons shen.unlock (cons V2655 (cons V2656 ())))) ((and (cons? V2652) (and (cons? (hd V2652)) (and (cons? (tl (hd V2652))) (and (= () (tl (tl (hd V2652)))) (and (= () (tl V2652)) (= false V2658)))))) (let W2659 (shen.continue (hd (hd V2652)) (hd (tl (hd V2652))) V2654 V2655 V2656 V2657) (cons if (cons (cons shen.unlocked? (cons V2655 ())) (cons (shen.compile-head shen.+m (hd (hd V2652)) V2653 V2654 W2659) (cons false ())))))) ((and (cons? V2652) (and (cons? (hd V2652)) (and (cons? (tl (hd V2652))) (= () (tl (tl (hd V2652))))))) (let W2660 (gensym C) (let W2661 (shen.continue (hd (hd V2652)) (hd (tl (hd V2652))) V2654 V2655 V2656 V2657) (cons let (cons W2660 (cons (cons if (cons (cons shen.unlocked? (cons V2655 ())) (cons (shen.compile-head shen.+m (hd (hd V2652)) V2653 V2654 W2661) (cons false ())))) (cons (cons if (cons (cons = (cons W2660 (cons false ()))) (cons (shen.prolog-fbody (tl V2652) V2653 V2654 V2655 V2656 V2657 V2658) (cons W2660 ())))) ()))))))) (true (simple-error "implementation error in shen.prolog-fbody"))))

(defun shen.unlock (V2662 V2663) (if (and (shen.locked? V2662) (shen.fits? V2663 V2662)) (shen.openlock V2662) false))

(defun shen.locked? (V2664) (not (shen.unlocked? V2664)))

(defun shen.unlocked? (V2665) (<-address V2665 1))

(defun shen.openlock (V2666) (do (address-> V2666 1 true) false))

(defun shen.fits? (V2667 V2668) (= V2667 (<-address V2668 2)))

(defun shen.cut (V2671 V2672 V2673 V2674) (let W2675 (thaw V2674) (if (and (= W2675 false) (shen.unlocked? V2672)) (shen.lock V2673 V2672) W2675)))

(defun shen.lock (V2676 V2677) (let W2678 (address-> V2677 1 false) (let W2679 (address-> V2677 2 V2676) false)))

(defun shen.continue (V2680 V2681 V2682 V2683 V2684 V2685) (let W2686 (shen.extract-vars V2680) (let W2687 (shen.extract-free-vars V2681) (let W2688 (difference W2687 W2686) (let W2689 (cons do (cons (cons shen.incinfs ()) (cons (shen.compile-body V2681 V2682 V2683 V2684 V2685) ()))) (shen.stpart W2688 W2689 V2682))))))

(defun shen.extract-free-vars (V2692) (cond ((and (cons? V2692) (and (= lambda (hd V2692)) (and (cons? (tl V2692)) (and (cons? (tl (tl V2692))) (= () (tl (tl (tl V2692)))))))) (remove (hd (tl V2692)) (shen.extract-free-vars (hd (tl (tl V2692)))))) ((cons? V2692) (union (shen.extract-free-vars (hd V2692)) (shen.extract-free-vars (tl V2692)))) ((variable? V2692) (cons V2692 ())) (true ())))

(defun shen.compile-body (V2709 V2710 V2711 V2712 V2713) (cond ((= () V2709) (cons thaw (cons V2713 ()))) ((and (cons? V2709) (= ! (hd V2709))) (shen.compile-body (cons (cons shen.cut ()) (tl V2709)) V2710 V2711 V2712 V2713)) ((and (cons? V2709) (= () (tl V2709))) (append (shen.deref-calls (hd V2709) V2710) (cons V2710 (cons V2711 (cons V2712 (cons V2713 ())))))) ((cons? V2709) (let W2714 (shen.deref-calls (hd V2709) V2710) (append W2714 (cons V2710 (cons V2711 (cons V2712 (cons (shen.freeze-literals (tl V2709) V2710 V2711 V2712 V2713) ()))))))) (true (simple-error "implementation error in shen.compile-fbody"))))

(defun shen.freeze-literals (V2731 V2732 V2733 V2734 V2735) (cond ((= () V2731) V2735) ((and (cons? V2731) (= ! (hd V2731))) (shen.freeze-literals (cons (cons shen.cut ()) (tl V2731)) V2732 V2733 V2734 V2735)) ((cons? V2731) (let W2736 (shen.deref-calls (hd V2731) V2732) (cons freeze (cons (append W2736 (cons V2732 (cons V2733 (cons V2734 (cons (shen.freeze-literals (tl V2731) V2732 V2733 V2734 V2735) ()))))) ())))) (true (simple-error "implementation error in shen.freeze-literals"))))

(defun shen.deref-calls (V2741 V2742) (cond ((and (cons? V2741) (= fork (hd V2741))) (cons fork (cons (shen.deref-forked-literals (tl V2741) V2742) ()))) ((cons? V2741) (cons (hd V2741) (map (lambda Z2743 (shen.function-calls Z2743 V2742)) (tl V2741)))) (true (simple-error "implementation error in shen.deref-calls"))))

(defun shen.deref-forked-literals (V2750 V2751) (cond ((= () V2750) ()) ((cons? V2750) (cons cons (cons (shen.deref-calls (hd V2750) V2751) (cons (shen.deref-forked-literals (tl V2750) V2751) ())))) (true (simple-error "fork requires a list of literals
"))))

(defun shen.function-calls (V2754 V2755) (cond ((and (cons? V2754) (and (= cons (hd V2754)) (and (cons? (tl V2754)) (and (cons? (tl (tl V2754))) (= () (tl (tl (tl V2754)))))))) (cons cons (cons (shen.function-calls (hd (tl V2754)) V2755) (cons (shen.function-calls (hd (tl (tl V2754))) V2755) ())))) ((cons? V2754) (shen.deref-terms V2754 V2755 ())) (true V2754)))

(defun shen.deref-terms (V2764 V2765 V2766) (cond ((and (cons? V2764) (and (= 0 (hd V2764)) (and (cons? (tl V2764)) (= () (tl (tl V2764)))))) (if (variable? (hd (tl V2764))) (hd (tl V2764)) (simple-error (cn "attempt to optimise a non-variable " (shen.app (hd (tl V2764)) "
" shen.s))))) ((and (cons? V2764) (and (= 1 (hd V2764)) (and (cons? (tl V2764)) (= () (tl (tl V2764)))))) (if (variable? (hd (tl V2764))) (cons shen.lazyderef (cons (hd (tl V2764)) (cons V2765 ()))) (simple-error (cn "attempt to optimise a non-variable " (shen.app (hd (tl V2764)) "
" shen.s))))) ((and (not (element? V2764 V2766)) (variable? V2764)) (cons shen.deref (cons V2764 (cons V2765 ())))) ((and (cons? V2764) (and (= lambda (hd V2764)) (and (cons? (tl V2764)) (and (cons? (tl (tl V2764))) (= () (tl (tl (tl V2764)))))))) (cons lambda (cons (hd (tl V2764)) (cons (shen.deref-terms (hd (tl (tl V2764))) V2765 (cons (hd (tl V2764)) V2766)) ())))) ((cons? V2764) (map (lambda Z2767 (shen.deref-terms Z2767 V2765 V2766)) V2764)) (true V2764)))

(defun shen.compile-head (V2785 V2786 V2787 V2788 V2789) (cond ((and (= () V2786) (= () V2787)) V2789) ((and (cons? V2786) (and (cons? (hd V2786)) (and (= shen.+m (hd (hd V2786))) (and (cons? (tl (hd V2786))) (= () (tl (tl (hd V2786)))))))) (shen.compile-head V2785 (cons shen.+m (cons (hd (tl (hd V2786))) (cons V2785 (tl V2786)))) V2787 V2788 V2789)) ((and (cons? V2786) (and (cons? (hd V2786)) (and (= shen.-m (hd (hd V2786))) (and (cons? (tl (hd V2786))) (= () (tl (tl (hd V2786)))))))) (shen.compile-head V2785 (cons shen.-m (cons (hd (tl (hd V2786))) (cons V2785 (tl V2786)))) V2787 V2788 V2789)) ((and (cons? V2786) (= shen.-m (hd V2786))) (shen.compile-head shen.-m (tl V2786) V2787 V2788 V2789)) ((and (cons? V2786) (= shen.+m (hd V2786))) (shen.compile-head shen.+m (tl V2786) V2787 V2788 V2789)) ((and (cons? V2786) (and (cons? V2787) (shen.wildcard? (hd V2786)))) (shen.compile-head V2785 (tl V2786) (tl V2787) V2788 V2789)) ((and (cons? V2786) (variable? (hd V2786))) (shen.variable-case V2785 V2786 V2787 V2788 V2789)) ((and (= shen.-m V2785) (and (cons? V2786) (atom? (hd V2786)))) (shen.atom-case-minus V2786 V2787 V2788 V2789)) ((and (= shen.-m V2785) (and (cons? V2786) (and (cons? (hd V2786)) (and (= cons (hd (hd V2786))) (and (cons? (tl (hd V2786))) (and (cons? (tl (tl (hd V2786)))) (= () (tl (tl (tl (hd V2786))))))))))) (shen.cons-case-minus V2786 V2787 V2788 V2789)) ((and (= shen.+m V2785) (and (cons? V2786) (atom? (hd V2786)))) (shen.atom-case-plus V2786 V2787 V2788 V2789)) ((and (= shen.+m V2785) (and (cons? V2786) (and (cons? (hd V2786)) (and (= cons (hd (hd V2786))) (and (cons? (tl (hd V2786))) (and (cons? (tl (tl (hd V2786)))) (= () (tl (tl (tl (hd V2786))))))))))) (shen.cons-case-plus V2786 V2787 V2788 V2789)) (true (simple-error "implementation error in shen.compile-head"))))

(defun shen.variable-case (V2800 V2801 V2802 V2803 V2804) (cond ((and (cons? V2801) (cons? V2802)) (if (variable? (hd V2802)) (shen.compile-head V2800 (tl V2801) (tl V2802) V2803 (subst (hd V2802) (hd V2801) V2804)) (cons let (cons (hd V2801) (cons (hd V2802) (cons (shen.compile-head V2800 (tl V2801) (tl V2802) V2803 V2804) ())))))) (true (simple-error "implementation error in shen.variable-case"))))

(defun shen.atom-case-minus (V2813 V2814 V2815 V2816) (cond ((and (cons? V2813) (cons? V2814)) (let W2817 (gensym Tm) (cons let (cons W2817 (cons (cons shen.lazyderef (cons (hd V2814) (cons V2815 ()))) (cons (cons if (cons (cons = (cons W2817 (cons (hd V2813) ()))) (cons (shen.compile-head shen.-m (tl V2813) (tl V2814) V2815 V2816) (cons false ())))) ())))))) (true (simple-error "implementation error in shen.atom-case-minus"))))

(defun shen.cons-case-minus (V2826 V2827 V2828 V2829) (cond ((and (cons? V2826) (and (cons? (hd V2826)) (and (= cons (hd (hd V2826))) (and (cons? (tl (hd V2826))) (and (cons? (tl (tl (hd V2826)))) (and (= () (tl (tl (tl (hd V2826))))) (cons? V2827))))))) (let W2830 (gensym Tm) (cons let (cons W2830 (cons (cons shen.lazyderef (cons (hd V2827) (cons V2828 ()))) (cons (cons if (cons (cons cons? (cons W2830 ())) (cons (shen.compile-head shen.-m (cons (hd (tl (hd V2826))) (cons (hd (tl (tl (hd V2826)))) (tl V2826))) (cons (cons hd (cons W2830 ())) (cons (cons tl (cons W2830 ())) (tl V2827))) V2828 V2829) (cons false ())))) ())))))) (true (simple-error "implementation error in shen.cons-case-minus"))))

(defun shen.atom-case-plus (V2839 V2840 V2841 V2842) (cond ((and (cons? V2839) (cons? V2840)) (let W2843 (gensym Tm) (let W2844 (gensym GoTo) (cons let (cons W2843 (cons (cons shen.lazyderef (cons (hd V2840) (cons V2841 ()))) (cons W2844 (cons (cons freeze (cons (shen.compile-head shen.+m (tl V2839) (tl V2840) V2841 V2842) ())) (cons (cons if (cons (cons = (cons W2843 (cons (hd V2839) ()))) (cons (cons thaw (cons W2844 ())) (cons (cons if (cons (cons shen.pvar? (cons W2843 ())) (cons (cons shen.bind! (cons W2843 (cons (shen.demode (hd V2839)) (cons V2841 (cons W2844 ()))))) (cons false ())))) ())))) ()))))))))) (true (simple-error "implementation error in shen.atom-case-plus"))))

(defun shen.cons-case-plus (V2853 V2854 V2855 V2856) (cond ((and (cons? V2853) (and (cons? (hd V2853)) (and (= cons (hd (hd V2853))) (and (cons? (tl (hd V2853))) (and (cons? (tl (tl (hd V2853)))) (and (= () (tl (tl (tl (hd V2853))))) (cons? V2854))))))) (let W2857 (gensym Tm) (let W2858 (gensym GoTo) (let W2859 (shen.extract-vars (cons (hd (tl (hd V2853))) (hd (tl (tl (hd V2853)))))) (let W2860 (shen.tame (hd V2853)) (let W2861 (shen.extract-vars W2860) (cons let (cons W2857 (cons (cons shen.lazyderef (cons (hd V2854) (cons V2855 ()))) (cons W2858 (cons (shen.goto W2859 (shen.compile-head shen.+m (tl V2853) (tl V2854) V2855 V2856)) (cons (cons if (cons (cons cons? (cons W2857 ())) (cons (shen.compile-head shen.+m (tl (hd V2853)) (cons (cons hd (cons W2857 ())) (cons (cons tl (cons W2857 ())) ())) V2855 (shen.invoke W2858 W2859)) (cons (cons if (cons (cons shen.pvar? (cons W2857 ())) (cons (shen.stpart W2861 (cons shen.bind! (cons W2857 (cons (shen.demode W2860) (cons V2855 (cons (cons freeze (cons (shen.invoke W2858 W2859) ())) ()))))) V2855) (cons false ())))) ())))) ())))))))))))) (true (simple-error "implementation error in shen.cons-case-plus"))))

(defun shen.demode (V2862) (cond ((and (cons? V2862) (and (= shen.+m (hd V2862)) (and (cons? (tl V2862)) (= () (tl (tl V2862)))))) (shen.demode (hd (tl V2862)))) ((and (cons? V2862) (and (= shen.-m (hd V2862)) (and (cons? (tl V2862)) (= () (tl (tl V2862)))))) (shen.demode (hd (tl V2862)))) ((cons? V2862) (map (lambda Z2863 (shen.demode Z2863)) V2862)) (true V2862)))

(defun shen.tame (V2864) (cond ((shen.wildcard? V2864) (gensym Y)) ((cons? V2864) (map (lambda Z2865 (shen.tame Z2865)) V2864)) (true V2864)))

(defun shen.goto (V2866 V2867) (cond ((= () V2866) (cons freeze (cons V2867 ()))) (true (shen.goto-h V2866 V2867))))

(defun shen.goto-h (V2868 V2869) (cond ((= () V2868) V2869) ((cons? V2868) (cons lambda (cons (hd V2868) (cons (shen.goto-h (tl V2868) V2869) ())))) (true (shen.f-error shen.goto-h))))

(defun shen.invoke (V2870 V2871) (cond ((= () V2871) (cons thaw (cons V2870 ()))) (true (cons V2870 V2871))))

(defun shen.wildcard? (V2872) (= V2872 _))

(defun shen.pvar? (V2873) (trap-error (and (absvector? V2873) (= (<-address V2873 0) shen.pvar)) (lambda Z2874 false)))

(defun shen.lazyderef (V2875 V2876) (if (shen.pvar? V2875) (let W2877 (<-address V2876 (<-address V2875 1)) (if (= W2877 shen.-null-) V2875 (shen.lazyderef W2877 V2876))) V2875))

(defun shen.deref (V2878 V2879) (cond ((cons? V2878) (cons (shen.deref (hd V2878) V2879) (shen.deref (tl V2878) V2879))) (true (if (shen.pvar? V2878) (let W2880 (<-address V2879 (<-address V2878 1)) (if (= W2880 shen.-null-) V2878 (shen.deref W2880 V2879))) V2878))))

(defun shen.bind! (V2881 V2882 V2883 V2884) (let W2885 (shen.bindv V2881 V2882 V2883) (let W2886 (thaw V2884) (if (= W2886 false) (shen.unwind V2881 V2883 W2886) W2886))))

(defun shen.bindv (V2887 V2888 V2889) (address-> V2889 (<-address V2887 1) V2888))

(defun shen.unwind (V2890 V2891 V2892) (do (address-> V2891 (<-address V2890 1) shen.-null-) V2892))

(defun shen.stpart (V2901 V2902 V2903) (cond ((= () V2901) V2902) ((cons? V2901) (cons let (cons (hd V2901) (cons (cons shen.newpv (cons V2903 ())) (cons (cons shen.gc (cons V2903 (cons (shen.stpart (tl V2901) V2902 V2903) ()))) ()))))) (true (simple-error "implementation error in shen.stpart"))))

(defun shen.gc (V2904 V2905) (if (= V2905 false) (let W2906 (shen.ticket-number V2904) (do (shen.decrement-ticket W2906 V2904) V2905)) V2905))

(defun shen.decrement-ticket (V2907 V2908) (address-> V2908 1 (- V2907 1)))

(defun shen.newpv (V2909) (let W2910 (shen.ticket-number V2909) (let W2911 (shen.make-prolog-variable W2910) (let W2912 (shen.nextticket V2909 W2910) W2911))))

(defun shen.ticket-number (V2913) (<-address V2913 1))

(defun shen.nextticket (V2914 V2915) (let W2916 (address-> V2914 V2915 shen.-null-) (address-> W2916 1 (+ V2915 1))))

(defun shen.make-prolog-variable (V2917) (address-> (address-> (absvector 2) 0 shen.pvar) 1 V2917))

(defun shen.pvar (V2918) (cn "Var" (shen.app (<-address V2918 1) "" shen.a)))

(defun shen.incinfs () (set shen.*infs* (+ 1 (value shen.*infs*))))

(defun shen.prolog-vector-size (V2919) (if (and (integer? V2919) (> V2919 0)) (set shen.*size-prolog-vector* V2919) (simple-error (cn "prolog vector size: size should be a positive integer; not " (shen.app V2919 "" shen.a)))))

(defun shen.lzy=! (V2931 V2932 V2933 V2934) (cond ((= V2931 V2932) (thaw V2934)) ((and (shen.pvar? V2931) (not (shen.occurs? V2931 (shen.deref V2932 V2933)))) (shen.bind! V2931 V2932 V2933 V2934)) ((and (shen.pvar? V2932) (not (shen.occurs? V2932 (shen.deref V2931 V2933)))) (shen.bind! V2932 V2931 V2933 V2934)) ((and (cons? V2931) (cons? V2932)) (shen.lzy=! (shen.lazyderef (hd V2931) V2933) (shen.lazyderef (hd V2932) V2933) V2933 (freeze (shen.lzy=! (shen.lazyderef (tl V2931) V2933) (shen.lazyderef (tl V2932) V2933) V2933 V2934)))) (true false)))

(defun shen.lzy= (V2946 V2947 V2948 V2949) (cond ((= V2946 V2947) (thaw V2949)) ((shen.pvar? V2946) (shen.bind! V2946 V2947 V2948 V2949)) ((shen.pvar? V2947) (shen.bind! V2947 V2946 V2948 V2949)) ((and (cons? V2946) (cons? V2947)) (shen.lzy= (shen.lazyderef (hd V2946) V2948) (shen.lazyderef (hd V2947) V2948) V2948 (freeze (shen.lzy= (shen.lazyderef (tl V2946) V2948) (shen.lazyderef (tl V2947) V2948) V2948 V2949)))) (true false)))

(defun shen.occurs? (V2955 V2956) (cond ((= V2955 V2956) true) ((cons? V2956) (or (shen.occurs? V2955 (hd V2956)) (shen.occurs? V2955 (tl V2956)))) (true false)))

(defun call (V2957 V2958 V2959 V2960 V2961) ((((V2957 V2958) V2959) V2960) V2961))

(defun return (V2968 V2969 V2970 V2971 V2972) (shen.deref V2968 V2969))

(defun when (V2979 V2980 V2981 V2982 V2983) (if V2979 (thaw V2983) false))

(defun is (V2984 V2985 V2986 V2987 V2988 V2989) (shen.lzy= (shen.lazyderef V2984 V2986) (shen.lazyderef V2985 V2986) V2986 V2989))

(defun is! (V2990 V2991 V2992 V2993 V2994 V2995) (shen.lzy=! (shen.lazyderef V2990 V2992) (shen.lazyderef V2991 V2992) V2992 V2995))

(defun bind (V3000 V3001 V3002 V3003 V3004 V3005) (shen.bind! V3000 V3001 V3002 V3005))

(defun var? (V3006 V3007 V3008 V3009 V3010) (if (shen.pvar? (shen.lazyderef V3006 V3007)) (thaw V3010) false))

(defun shen.print-prolog-vector (V3013) "|prolog vector|")

(defun fork (V3032 V3033 V3034 V3035 V3036) (cond ((= () V3032) false) ((cons? V3032) (let W3037 (((((hd V3032) V3033) V3034) V3035) V3036) (if (= W3037 false) (fork (tl V3032) V3033 V3034 V3035 V3036) W3037))) (true (simple-error "fork expects a list of literals
"))))

(defun findall (V3038 V3039 V3040 V3041 V3042 V3043 V3044) (if (shen.unlocked? V3042) (let W3045 (shen.newpv V3041) (shen.gc V3041 (do (shen.incinfs) (is W3045 () V3041 V3042 V3043 (freeze (shen.findall-h V3038 V3039 V3040 W3045 V3041 V3042 V3043 V3044)))))) false))

(defun shen.findall-h (V3046 V3047 V3048 V3049 V3050 V3051 V3052 V3053) (let W3054 (if (shen.unlocked? V3051) (do (shen.incinfs) (call V3047 V3050 V3051 V3052 (freeze (shen.overbind V3046 V3049 V3050 V3051 V3052 V3053)))) false) (if (= W3054 false) (if (shen.unlocked? V3051) (do (shen.incinfs) (is! V3048 V3049 V3050 V3051 V3052 V3053)) false) W3054)))

(defun shen.overbind (V3061 V3062 V3063 V3064 V3065 V3066) (do (shen.bindv V3062 (cons (shen.deref V3061 V3063) (shen.lazyderef V3062 V3063)) V3063) false))

(defun occurs-check (V3069) (cond ((= + V3069) (set shen.*occurs* true)) ((= - V3069) (set shen.*occurs* false)) (true (simple-error "occurs-check expects a + or a -.
"))))

