(defun read-file (V8922) (let W8923 (read-file-as-bytelist V8922) (let W8924 (trap-error (compile (lambda Z8925 (shen.<s-exprs> Z8925)) W8923) (lambda Z8926 (shen.print-residue (value shen.*residue*)))) (let W8927 (shen.process-sexprs W8924) W8927))))

(defun shen.print-residue (V8928) (let W8929 (pr "syntax error here:
" (stoutput)) (shen.nchars 50 V8928)))

(defun shen.nchars (V8934 V8935) (cond ((= 0 V8934) (do (pr " ..." (stoutput)) (abort))) ((= () V8935) (do (pr " ..." (stoutput)) (abort))) ((cons? V8935) (do (pr (n->string (hd V8935)) (stoutput)) (shen.nchars (- V8934 1) (tl V8935)))) (true (shen.f-error shen.nchars))))

(defun it () (value shen.*it*))

(defun read-file-as-bytelist (V8936) (let W8937 (open V8936 in) (let W8938 (read-byte W8937) (let W8939 (shen.read-file-as-bytelist-help W8937 W8938 ()) (let W8940 (close W8937) (reverse W8939))))))

(defun shen.read-file-as-bytelist-help (V8941 V8942 V8943) (cond ((= -1 V8942) V8943) (true (shen.read-file-as-bytelist-help V8941 (read-byte V8941) (cons V8942 V8943)))))

(defun read-file-as-string (V8944) (let W8945 (open V8944 in) (shen.rfas-h W8945 (read-byte W8945) "")))

(defun shen.rfas-h (V8946 V8947 V8948) (cond ((= -1 V8947) (do (close V8946) V8948)) (true (shen.rfas-h V8946 (read-byte V8946) (cn V8948 (n->string V8947))))))

(defun input (V8949) (eval-kl (read V8949)))

(defun input+ (V8950 V8951) (let W8952 (shen.monotype V8950) (let W8953 (read V8951) (if (= false (shen.typecheck W8953 (shen.rectify-type V8950))) (simple-error (cn "type error: " (shen.app W8953 (cn " is not of type " (shen.app V8950 "
" shen.r)) shen.r))) (eval-kl W8953)))))

(defun shen.monotype (V8954) (cond ((cons? V8954) (map (lambda Z8955 (shen.monotype Z8955)) V8954)) (true (if (variable? V8954) (simple-error (cn "input+ expects a monotype: not " (shen.app V8954 "
" shen.a))) V8954))))

(defun lineread (V8956) (shen.read-loop V8956 (shen.my-read-byte V8956) () (lambda Z8957 (shen.return? Z8957))))

(defun read-from-string (V8958) (let W8959 (shen.str->bytes V8958) (let W8960 (compile (lambda Z8961 (shen.<s-exprs> Z8961)) W8959) (let W8962 (shen.process-sexprs W8960) W8962))))

(defun read-from-string-unprocessed (V8963) (let W8964 (shen.str->bytes V8963) (let W8965 (compile (lambda Z8966 (shen.<s-exprs> Z8966)) W8964) W8965)))

(defun shen.str->bytes (V8967) (cond ((= "" V8967) ()) ((shen.+string? V8967) (cons (string->n (hdstr V8967)) (shen.str->bytes (tlstr V8967)))) (true (shen.f-error shen.str->bytes))))

(defun read (V8968) (hd (shen.read-loop V8968 (shen.my-read-byte V8968) () (lambda Z8969 (shen.whitespace? Z8969)))))

(defun shen.my-read-byte (V8970) (if (shen.char-stinput? V8970) (string->n (shen.read-unit-string V8970)) (read-byte V8970)))

(defun shen.read-loop (V8975 V8976 V8977 V8978) (cond ((= 94 V8976) (simple-error "read aborted")) ((= -1 V8976) (if (empty? V8977) (simple-error "error: empty stream") (compile (lambda Z8979 (shen.<s-exprs> Z8979)) V8977))) ((= 0 V8976) (shen.read-loop V8975 (shen.my-read-byte V8975) V8977 V8978)) (true (if (V8978 V8976) (let W8980 (shen.try-parse V8977) (if (shen.nothing-doing? W8980) (shen.read-loop V8975 (shen.my-read-byte V8975) (append V8977 (cons V8976 ())) V8978) (do (shen.record-it V8977) W8980))) (shen.read-loop V8975 (shen.my-read-byte V8975) (append V8977 (cons V8976 ())) V8978)))))

(defun shen.try-parse (V8981) (let W8982 (trap-error (compile (lambda Z8983 (shen.<s-exprs> Z8983)) V8981) (lambda Z8984 shen.i-failed!)) (if (shen.nothing-doing? W8982) shen.i-failed! (shen.process-sexprs W8982))))

(defun shen.nothing-doing? (V8987) (cond ((= shen.i-failed! V8987) true) ((= () V8987) true) (true false)))

(defun shen.record-it (V8988) (set shen.*it* (shen.bytes->string V8988)))

(defun shen.bytes->string (V8989) (cond ((= () V8989) "") ((cons? V8989) (cn (n->string (hd V8989)) (shen.bytes->string (tl V8989)))) (true (shen.f-error shen.bytes->string))))

(defun shen.process-sexprs (V8990) (let W8991 (shen.unpackage&macroexpand V8990) (let W8992 (shen.find-arities W8991) (let W8993 (shen.find-types W8991) (map (lambda Z8994 (shen.process-applications Z8994 W8993)) W8991)))))

(defun shen.find-types (V8995) (cond ((and (cons? V8995) (and (cons? (tl V8995)) (= (hd V8995) (intern ":")))) (cons (hd (tl V8995)) (shen.find-types (tl (tl V8995))))) ((cons? V8995) (append (shen.find-types (hd V8995)) (shen.find-types (tl V8995)))) (true ())))

(defun shen.find-arities (V8998) (cond ((and (cons? V8998) (and (= define (hd V8998)) (and (cons? (tl V8998)) (and (cons? (tl (tl V8998))) (= { (hd (tl (tl V8998)))))))) (shen.store-arity (hd (tl V8998)) (shen.find-arity (hd (tl V8998)) 1 (tl (tl (tl V8998)))))) ((and (cons? V8998) (and (= define (hd V8998)) (cons? (tl V8998)))) (shen.store-arity (hd (tl V8998)) (shen.find-arity (hd (tl V8998)) 0 (tl (tl V8998))))) ((cons? V8998) (map (lambda Z8999 (shen.find-arities Z8999)) V8998)) (true shen.skip)))

(defun shen.store-arity (V9000 V9001) (let W9002 (arity V9000) (if (= W9002 -1) (shen.execute-store-arity V9000 V9001) (if (= W9002 V9001) shen.skip (if (shen.sysfunc? V9000) (simple-error (shen.app V9000 " is a system function
" shen.a)) (do (pr (cn "changing the arity of " (shen.app V9000 " may cause errors
" shen.a)) (stoutput)) (shen.execute-store-arity V9000 V9001)))))))

(defun shen.execute-store-arity (V9003 V9004) (cond ((= 0 V9004) (put V9003 arity 0 (value *property-vector*))) (true (do (put V9003 arity V9004 (value *property-vector*)) (shen.update-lambdatable V9003 V9004)))))

(defun shen.update-lambdatable (V9005 V9006) (let W9007 (value shen.*lambdatable*) (let W9008 (eval-kl (shen.lambda-function (cons V9005 ()) V9006)) (let W9009 (shen.assoc-> V9005 W9008 W9007) (let W9010 (set shen.*lambdatable* W9009) W9010)))))

(defun shen.lambda-function (V9013 V9014) (cond ((= 0 V9014) shen.skip) ((= 1 V9014) (let W9015 (gensym Y) (cons lambda (cons W9015 (cons (append V9013 (cons W9015 ())) ()))))) (true (let W9016 (gensym Y) (cons lambda (cons W9016 (cons (shen.lambda-function (append V9013 (cons W9016 ())) (- V9014 1)) ())))))))

(defun shen.assoc-> (V9026 V9027 V9028) (cond ((= () V9028) (cons (cons V9026 V9027) ())) ((and (cons? V9028) (and (cons? (hd V9028)) (= V9026 (hd (hd V9028))))) (cons (cons (hd (hd V9028)) V9027) (tl V9028))) ((cons? V9028) (cons (hd V9028) (shen.assoc-> V9026 V9027 (tl V9028)))) (true (simple-error "implementation error in shen.assoc->"))))

(defun shen.find-arity (V9043 V9044 V9045) (cond ((and (= 0 V9044) (and (cons? V9045) (= (hd V9045) ->))) 0) ((and (= 0 V9044) (and (cons? V9045) (= (hd V9045) <-))) 0) ((and (= 0 V9044) (cons? V9045)) (+ 1 (shen.find-arity V9043 0 (tl V9045)))) ((and (= 1 V9044) (and (cons? V9045) (= } (hd V9045)))) (shen.find-arity V9043 0 (tl V9045))) ((and (= 1 V9044) (cons? V9045)) (shen.find-arity V9043 1 (tl V9045))) ((= 1 V9044) (simple-error (cn "syntax error in " (shen.app V9043 " definition: missing }
" shen.a)))) (true (simple-error (cn "syntax error in " (shen.app V9043 " definition: missing -> or <-
" shen.a))))))

(defun shen.<s-exprs> (V9046) (let W9047 (let W9048 (shen.<lsb> V9046) (if (shen.parse-failure? W9048) (shen.parse-failure) (let W9049 (shen.<s-exprs1> W9048) (if (shen.parse-failure? W9049) (shen.parse-failure) (let W9050 (shen.<rsb> W9049) (if (shen.parse-failure? W9050) (shen.parse-failure) (let W9051 (shen.<s-exprs2> W9050) (if (shen.parse-failure? W9051) (shen.parse-failure) (shen.comb (shen.in-> W9051) (cons (shen.cons-form (shen.<-out W9049)) (shen.<-out W9051))))))))))) (if (shen.parse-failure? W9047) (let W9052 (let W9053 (shen.<lrb> V9046) (if (shen.parse-failure? W9053) (shen.parse-failure) (let W9054 (shen.<s-exprs1> W9053) (if (shen.parse-failure? W9054) (shen.parse-failure) (let W9055 (shen.<rrb> W9054) (if (shen.parse-failure? W9055) (shen.parse-failure) (let W9056 (shen.<s-exprs2> W9055) (if (shen.parse-failure? W9056) (shen.parse-failure) (shen.comb (shen.in-> W9056) (shen.add-sexpr (shen.<-out W9054) (shen.<-out W9056))))))))))) (if (shen.parse-failure? W9052) (let W9057 (let W9058 (shen.<lcurly> V9046) (if (shen.parse-failure? W9058) (shen.parse-failure) (let W9059 (shen.<s-exprs> W9058) (if (shen.parse-failure? W9059) (shen.parse-failure) (shen.comb (shen.in-> W9059) (cons { (shen.<-out W9059))))))) (if (shen.parse-failure? W9057) (let W9060 (let W9061 (shen.<rcurly> V9046) (if (shen.parse-failure? W9061) (shen.parse-failure) (let W9062 (shen.<s-exprs> W9061) (if (shen.parse-failure? W9062) (shen.parse-failure) (shen.comb (shen.in-> W9062) (cons } (shen.<-out W9062))))))) (if (shen.parse-failure? W9060) (let W9063 (let W9064 (shen.<bar> V9046) (if (shen.parse-failure? W9064) (shen.parse-failure) (let W9065 (shen.<s-exprs> W9064) (if (shen.parse-failure? W9065) (shen.parse-failure) (shen.comb (shen.in-> W9065) (cons bar! (shen.<-out W9065))))))) (if (shen.parse-failure? W9063) (let W9066 (let W9067 (shen.<semicolon> V9046) (if (shen.parse-failure? W9067) (shen.parse-failure) (let W9068 (shen.<s-exprs> W9067) (if (shen.parse-failure? W9068) (shen.parse-failure) (shen.comb (shen.in-> W9068) (cons (intern ";") (shen.<-out W9068))))))) (if (shen.parse-failure? W9066) (let W9069 (let W9070 (shen.<colon> V9046) (if (shen.parse-failure? W9070) (shen.parse-failure) (let W9071 (shen.<equal> W9070) (if (shen.parse-failure? W9071) (shen.parse-failure) (let W9072 (shen.<s-exprs> W9071) (if (shen.parse-failure? W9072) (shen.parse-failure) (shen.comb (shen.in-> W9072) (cons (intern ":=") (shen.<-out W9072))))))))) (if (shen.parse-failure? W9069) (let W9073 (let W9074 (shen.<colon> V9046) (if (shen.parse-failure? W9074) (shen.parse-failure) (let W9075 (shen.<s-exprs> W9074) (if (shen.parse-failure? W9075) (shen.parse-failure) (shen.comb (shen.in-> W9075) (cons (intern ":") (shen.<-out W9075))))))) (if (shen.parse-failure? W9073) (let W9076 (let W9077 (shen.<comma> V9046) (if (shen.parse-failure? W9077) (shen.parse-failure) (let W9078 (shen.<s-exprs> W9077) (if (shen.parse-failure? W9078) (shen.parse-failure) (shen.comb (shen.in-> W9078) (cons (intern ",") (shen.<-out W9078))))))) (if (shen.parse-failure? W9076) (let W9079 (let W9080 (shen.<comment> V9046) (if (shen.parse-failure? W9080) (shen.parse-failure) (let W9081 (shen.<s-exprs> W9080) (if (shen.parse-failure? W9081) (shen.parse-failure) (shen.comb (shen.in-> W9081) (shen.<-out W9081)))))) (if (shen.parse-failure? W9079) (let W9082 (let W9083 (shen.<atom> V9046) (if (shen.parse-failure? W9083) (shen.parse-failure) (let W9084 (shen.<s-exprs> W9083) (if (shen.parse-failure? W9084) (shen.parse-failure) (shen.comb (shen.in-> W9084) (cons (shen.<-out W9083) (shen.<-out W9084))))))) (if (shen.parse-failure? W9082) (let W9085 (let W9086 (shen.<whitespaces> V9046) (if (shen.parse-failure? W9086) (shen.parse-failure) (let W9087 (shen.<s-exprs> W9086) (if (shen.parse-failure? W9087) (shen.parse-failure) (shen.comb (shen.in-> W9087) (shen.<-out W9087)))))) (if (shen.parse-failure? W9085) (let W9088 (let W9089 (<e> V9046) (if (shen.parse-failure? W9089) (shen.parse-failure) (shen.comb (shen.in-> W9089) ()))) (if (shen.parse-failure? W9088) (shen.parse-failure) W9088)) W9085)) W9082)) W9079)) W9076)) W9073)) W9069)) W9066)) W9063)) W9060)) W9057)) W9052)) W9047)))

(defun shen.add-sexpr (V9090 V9091) (cond ((and (cons? V9090) (and (= $ (hd V9090)) (and (cons? (tl V9090)) (= () (tl (tl V9090)))))) (append (explode (hd (tl V9090))) V9091)) (true (cons V9090 V9091))))

(defun shen.<lsb> (V9092) (let W9093 (if (shen.=hd? V9092 91) (let W9094 (shen.tls V9092) (shen.comb (shen.in-> W9094) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W9093) (shen.parse-failure) W9093)))

(defun shen.<rsb> (V9095) (let W9096 (if (shen.=hd? V9095 93) (let W9097 (shen.tls V9095) (shen.comb (shen.in-> W9097) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W9096) (shen.parse-failure) W9096)))

(defun shen.<s-exprs1> (V9098) (let W9099 (let W9100 (shen.<s-exprs> V9098) (if (shen.parse-failure? W9100) (shen.parse-failure) (shen.comb (shen.in-> W9100) (shen.<-out W9100)))) (if (shen.parse-failure? W9099) (shen.parse-failure) W9099)))

(defun shen.<s-exprs2> (V9101) (let W9102 (let W9103 (shen.<s-exprs> V9101) (if (shen.parse-failure? W9103) (shen.parse-failure) (shen.comb (shen.in-> W9103) (shen.<-out W9103)))) (if (shen.parse-failure? W9102) (shen.parse-failure) W9102)))

(defun shen.cons-form (V9105) (cond ((= () V9105) ()) ((and (cons? V9105) (and (cons? (tl V9105)) (and (cons? (tl (tl V9105))) (and (= () (tl (tl (tl V9105)))) (= (hd (tl V9105)) bar!))))) (cons cons (cons (hd V9105) (tl (tl V9105))))) ((and (cons? V9105) (and (cons? (tl V9105)) (and (cons? (tl (tl V9105))) (and (cons? (tl (tl (tl V9105)))) (= (hd (tl V9105)) bar!))))) (simple-error "misapplication of |
")) ((cons? V9105) (cons cons (cons (hd V9105) (cons (shen.cons-form (tl V9105)) ())))) (true (shen.f-error shen.cons-form))))

(defun shen.<lrb> (V9106) (let W9107 (if (shen.=hd? V9106 40) (let W9108 (shen.tls V9106) (shen.comb (shen.in-> W9108) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W9107) (shen.parse-failure) W9107)))

(defun shen.<rrb> (V9109) (let W9110 (if (shen.=hd? V9109 41) (let W9111 (shen.tls V9109) (shen.comb (shen.in-> W9111) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W9110) (shen.parse-failure) W9110)))

(defun shen.<lcurly> (V9112) (let W9113 (if (shen.=hd? V9112 123) (let W9114 (shen.tls V9112) (shen.comb (shen.in-> W9114) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W9113) (shen.parse-failure) W9113)))

(defun shen.<rcurly> (V9115) (let W9116 (if (shen.=hd? V9115 125) (let W9117 (shen.tls V9115) (shen.comb (shen.in-> W9117) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W9116) (shen.parse-failure) W9116)))

(defun shen.<bar> (V9118) (let W9119 (if (shen.=hd? V9118 124) (let W9120 (shen.tls V9118) (shen.comb (shen.in-> W9120) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W9119) (shen.parse-failure) W9119)))

(defun shen.<semicolon> (V9121) (let W9122 (if (shen.=hd? V9121 59) (let W9123 (shen.tls V9121) (shen.comb (shen.in-> W9123) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W9122) (shen.parse-failure) W9122)))

(defun shen.<colon> (V9124) (let W9125 (if (shen.=hd? V9124 58) (let W9126 (shen.tls V9124) (shen.comb (shen.in-> W9126) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W9125) (shen.parse-failure) W9125)))

(defun shen.<comma> (V9127) (let W9128 (if (shen.=hd? V9127 44) (let W9129 (shen.tls V9127) (shen.comb (shen.in-> W9129) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W9128) (shen.parse-failure) W9128)))

(defun shen.<equal> (V9130) (let W9131 (if (shen.=hd? V9130 61) (let W9132 (shen.tls V9130) (shen.comb (shen.in-> W9132) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W9131) (shen.parse-failure) W9131)))

(defun shen.<comment> (V9133) (let W9134 (let W9135 (shen.<singleline> V9133) (if (shen.parse-failure? W9135) (shen.parse-failure) (shen.comb (shen.in-> W9135) shen.skip))) (if (shen.parse-failure? W9134) (let W9136 (let W9137 (shen.<multiline> V9133) (if (shen.parse-failure? W9137) (shen.parse-failure) (shen.comb (shen.in-> W9137) shen.skip))) (if (shen.parse-failure? W9136) (shen.parse-failure) W9136)) W9134)))

(defun shen.<singleline> (V9138) (let W9139 (let W9140 (shen.<backslash> V9138) (if (shen.parse-failure? W9140) (shen.parse-failure) (let W9141 (shen.<backslash> W9140) (if (shen.parse-failure? W9141) (shen.parse-failure) (let W9142 (shen.<shortnatters> W9141) (if (shen.parse-failure? W9142) (shen.parse-failure) (let W9143 (shen.<returns> W9142) (if (shen.parse-failure? W9143) (shen.parse-failure) (shen.comb (shen.in-> W9143) shen.skip))))))))) (if (shen.parse-failure? W9139) (shen.parse-failure) W9139)))

(defun shen.<backslash> (V9144) (let W9145 (if (shen.=hd? V9144 92) (let W9146 (shen.tls V9144) (shen.comb (shen.in-> W9146) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W9145) (shen.parse-failure) W9145)))

(defun shen.<shortnatters> (V9147) (let W9148 (let W9149 (shen.<shortnatter> V9147) (if (shen.parse-failure? W9149) (shen.parse-failure) (let W9150 (shen.<shortnatters> W9149) (if (shen.parse-failure? W9150) (shen.parse-failure) (shen.comb (shen.in-> W9150) shen.skip))))) (if (shen.parse-failure? W9148) (let W9151 (let W9152 (<e> V9147) (if (shen.parse-failure? W9152) (shen.parse-failure) (shen.comb (shen.in-> W9152) shen.skip))) (if (shen.parse-failure? W9151) (shen.parse-failure) W9151)) W9148)))

(defun shen.<shortnatter> (V9153) (let W9154 (if (shen.non-empty-stream? V9153) (let W9155 (shen.hds V9153) (let W9156 (shen.tls V9153) (if (not (shen.return? W9155)) (shen.comb (shen.in-> W9156) shen.skip) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W9154) (shen.parse-failure) W9154)))

(defun shen.<returns> (V9157) (let W9158 (let W9159 (shen.<return> V9157) (if (shen.parse-failure? W9159) (shen.parse-failure) (let W9160 (shen.<returns> W9159) (if (shen.parse-failure? W9160) (shen.parse-failure) (shen.comb (shen.in-> W9160) shen.skip))))) (if (shen.parse-failure? W9158) (let W9161 (let W9162 (shen.<return> V9157) (if (shen.parse-failure? W9162) (shen.parse-failure) (shen.comb (shen.in-> W9162) shen.skip))) (if (shen.parse-failure? W9161) (shen.parse-failure) W9161)) W9158)))

(defun shen.<return> (V9163) (let W9164 (if (shen.non-empty-stream? V9163) (let W9165 (shen.hds V9163) (let W9166 (shen.tls V9163) (if (shen.return? W9165) (shen.comb (shen.in-> W9166) shen.skip) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W9164) (shen.parse-failure) W9164)))

(defun shen.return? (V9167) (element? V9167 (cons 9 (cons 10 (cons 13 ())))))

(defun shen.<multiline> (V9168) (let W9169 (let W9170 (shen.<backslash> V9168) (if (shen.parse-failure? W9170) (shen.parse-failure) (let W9171 (shen.<times> W9170) (if (shen.parse-failure? W9171) (shen.parse-failure) (let W9172 (shen.<longnatter> W9171) (if (shen.parse-failure? W9172) (shen.parse-failure) (shen.comb (shen.in-> W9172) shen.skip))))))) (if (shen.parse-failure? W9169) (shen.parse-failure) W9169)))

(defun shen.<times> (V9173) (let W9174 (if (shen.=hd? V9173 42) (let W9175 (shen.tls V9173) (shen.comb (shen.in-> W9175) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W9174) (shen.parse-failure) W9174)))

(defun shen.<longnatter> (V9176) (let W9177 (let W9178 (shen.<comment> V9176) (if (shen.parse-failure? W9178) (shen.parse-failure) (let W9179 (shen.<longnatter> W9178) (if (shen.parse-failure? W9179) (shen.parse-failure) (shen.comb (shen.in-> W9179) shen.skip))))) (if (shen.parse-failure? W9177) (let W9180 (let W9181 (shen.<times> V9176) (if (shen.parse-failure? W9181) (shen.parse-failure) (let W9182 (shen.<backslash> W9181) (if (shen.parse-failure? W9182) (shen.parse-failure) (shen.comb (shen.in-> W9182) shen.skip))))) (if (shen.parse-failure? W9180) (let W9183 (if (shen.non-empty-stream? V9176) (let W9184 (shen.tls V9176) (let W9185 (shen.<longnatter> W9184) (if (shen.parse-failure? W9185) (shen.parse-failure) (shen.comb (shen.in-> W9185) shen.skip)))) (shen.parse-failure)) (if (shen.parse-failure? W9183) (shen.parse-failure) W9183)) W9180)) W9177)))

(defun shen.<atom> (V9186) (let W9187 (let W9188 (shen.<str> V9186) (if (shen.parse-failure? W9188) (shen.parse-failure) (shen.comb (shen.in-> W9188) (shen.<-out W9188)))) (if (shen.parse-failure? W9187) (let W9189 (let W9190 (shen.<number> V9186) (if (shen.parse-failure? W9190) (shen.parse-failure) (shen.comb (shen.in-> W9190) (shen.<-out W9190)))) (if (shen.parse-failure? W9189) (let W9191 (let W9192 (shen.<sym> V9186) (if (shen.parse-failure? W9192) (shen.parse-failure) (shen.comb (shen.in-> W9192) (if (= (shen.<-out W9192) "<>") (cons vector (cons 0 ())) (intern (shen.<-out W9192)))))) (if (shen.parse-failure? W9191) (shen.parse-failure) W9191)) W9189)) W9187)))

(defun shen.<sym> (V9193) (let W9194 (let W9195 (shen.<alpha> V9193) (if (shen.parse-failure? W9195) (shen.parse-failure) (let W9196 (shen.<alphanums> W9195) (if (shen.parse-failure? W9196) (shen.parse-failure) (shen.comb (shen.in-> W9196) (cn (shen.<-out W9195) (shen.<-out W9196))))))) (if (shen.parse-failure? W9194) (shen.parse-failure) W9194)))

(defun shen.<alpha> (V9197) (let W9198 (if (shen.non-empty-stream? V9197) (let W9199 (shen.hds V9197) (let W9200 (shen.tls V9197) (if (shen.alpha? W9199) (shen.comb (shen.in-> W9200) (n->string W9199)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W9198) (shen.parse-failure) W9198)))

(defun shen.alpha? (V9201) (or (shen.lowercase? V9201) (or (shen.uppercase? V9201) (shen.misc? V9201))))

(defun shen.lowercase? (V9202) (and (>= V9202 97) (<= V9202 122)))

(defun shen.uppercase? (V9203) (and (>= V9203 65) (<= V9203 90)))

(defun shen.misc? (V9204) (element? V9204 (cons 61 (cons 45 (cons 42 (cons 47 (cons 43 (cons 95 (cons 63 (cons 36 (cons 33 (cons 64 (cons 126 (cons 46 (cons 62 (cons 60 (cons 38 (cons 37 (cons 39 (cons 35 (cons 96 ())))))))))))))))))))))

(defun shen.<alphanums> (V9205) (let W9206 (let W9207 (shen.<alphanum> V9205) (if (shen.parse-failure? W9207) (shen.parse-failure) (let W9208 (shen.<alphanums> W9207) (if (shen.parse-failure? W9208) (shen.parse-failure) (shen.comb (shen.in-> W9208) (cn (shen.<-out W9207) (shen.<-out W9208))))))) (if (shen.parse-failure? W9206) (let W9209 (let W9210 (<e> V9205) (if (shen.parse-failure? W9210) (shen.parse-failure) (shen.comb (shen.in-> W9210) ""))) (if (shen.parse-failure? W9209) (shen.parse-failure) W9209)) W9206)))

(defun shen.<alphanum> (V9211) (let W9212 (let W9213 (shen.<alpha> V9211) (if (shen.parse-failure? W9213) (shen.parse-failure) (shen.comb (shen.in-> W9213) (shen.<-out W9213)))) (if (shen.parse-failure? W9212) (let W9214 (let W9215 (shen.<numeral> V9211) (if (shen.parse-failure? W9215) (shen.parse-failure) (shen.comb (shen.in-> W9215) (shen.<-out W9215)))) (if (shen.parse-failure? W9214) (shen.parse-failure) W9214)) W9212)))

(defun shen.<numeral> (V9216) (let W9217 (if (shen.non-empty-stream? V9216) (let W9218 (shen.hds V9216) (let W9219 (shen.tls V9216) (if (shen.digit? W9218) (shen.comb (shen.in-> W9219) (n->string W9218)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W9217) (shen.parse-failure) W9217)))

(defun shen.digit? (V9220) (and (>= V9220 48) (<= V9220 57)))

(defun shen.<str> (V9221) (let W9222 (let W9223 (shen.<dbq> V9221) (if (shen.parse-failure? W9223) (shen.parse-failure) (let W9224 (shen.<strcontents> W9223) (if (shen.parse-failure? W9224) (shen.parse-failure) (let W9225 (shen.<dbq> W9224) (if (shen.parse-failure? W9225) (shen.parse-failure) (shen.comb (shen.in-> W9225) (shen.<-out W9224)))))))) (if (shen.parse-failure? W9222) (shen.parse-failure) W9222)))

(defun shen.<dbq> (V9226) (let W9227 (if (shen.=hd? V9226 34) (let W9228 (shen.tls V9226) (shen.comb (shen.in-> W9228) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W9227) (shen.parse-failure) W9227)))

(defun shen.<strcontents> (V9229) (let W9230 (let W9231 (shen.<strc> V9229) (if (shen.parse-failure? W9231) (shen.parse-failure) (let W9232 (shen.<strcontents> W9231) (if (shen.parse-failure? W9232) (shen.parse-failure) (shen.comb (shen.in-> W9232) (cn (shen.<-out W9231) (shen.<-out W9232))))))) (if (shen.parse-failure? W9230) (let W9233 (let W9234 (<e> V9229) (if (shen.parse-failure? W9234) (shen.parse-failure) (shen.comb (shen.in-> W9234) ""))) (if (shen.parse-failure? W9233) (shen.parse-failure) W9233)) W9230)))

(defun shen.<strc> (V9235) (let W9236 (let W9237 (shen.<control> V9235) (if (shen.parse-failure? W9237) (shen.parse-failure) (shen.comb (shen.in-> W9237) (shen.<-out W9237)))) (if (shen.parse-failure? W9236) (let W9238 (let W9239 (shen.<notdbq> V9235) (if (shen.parse-failure? W9239) (shen.parse-failure) (shen.comb (shen.in-> W9239) (shen.<-out W9239)))) (if (shen.parse-failure? W9238) (shen.parse-failure) W9238)) W9236)))

(defun shen.<control> (V9240) (let W9241 (let W9242 (shen.<lowC> V9240) (if (shen.parse-failure? W9242) (shen.parse-failure) (let W9243 (shen.<hash> W9242) (if (shen.parse-failure? W9243) (shen.parse-failure) (let W9244 (shen.<integer> W9243) (if (shen.parse-failure? W9244) (shen.parse-failure) (let W9245 (shen.<semicolon> W9244) (if (shen.parse-failure? W9245) (shen.parse-failure) (shen.comb (shen.in-> W9245) (n->string (shen.<-out W9244))))))))))) (if (shen.parse-failure? W9241) (shen.parse-failure) W9241)))

(defun shen.<notdbq> (V9246) (let W9247 (if (shen.non-empty-stream? V9246) (let W9248 (shen.hds V9246) (let W9249 (shen.tls V9246) (if (not (= W9248 34)) (shen.comb (shen.in-> W9249) (n->string W9248)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W9247) (shen.parse-failure) W9247)))

(defun shen.<lowC> (V9250) (let W9251 (if (shen.=hd? V9250 99) (let W9252 (shen.tls V9250) (shen.comb (shen.in-> W9252) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W9251) (shen.parse-failure) W9251)))

(defun shen.<hash> (V9253) (let W9254 (if (shen.=hd? V9253 35) (let W9255 (shen.tls V9253) (shen.comb (shen.in-> W9255) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W9254) (shen.parse-failure) W9254)))

(defun shen.<number> (V9256) (let W9257 (let W9258 (shen.<minus> V9256) (if (shen.parse-failure? W9258) (shen.parse-failure) (let W9259 (shen.<number> W9258) (if (shen.parse-failure? W9259) (shen.parse-failure) (shen.comb (shen.in-> W9259) (- 0 (shen.<-out W9259))))))) (if (shen.parse-failure? W9257) (let W9260 (let W9261 (shen.<plus> V9256) (if (shen.parse-failure? W9261) (shen.parse-failure) (let W9262 (shen.<number> W9261) (if (shen.parse-failure? W9262) (shen.parse-failure) (shen.comb (shen.in-> W9262) (shen.<-out W9262)))))) (if (shen.parse-failure? W9260) (let W9263 (let W9264 (shen.<e-number> V9256) (if (shen.parse-failure? W9264) (shen.parse-failure) (shen.comb (shen.in-> W9264) (shen.<-out W9264)))) (if (shen.parse-failure? W9263) (let W9265 (let W9266 (shen.<float> V9256) (if (shen.parse-failure? W9266) (shen.parse-failure) (shen.comb (shen.in-> W9266) (shen.<-out W9266)))) (if (shen.parse-failure? W9265) (let W9267 (let W9268 (shen.<integer> V9256) (if (shen.parse-failure? W9268) (shen.parse-failure) (shen.comb (shen.in-> W9268) (shen.<-out W9268)))) (if (shen.parse-failure? W9267) (shen.parse-failure) W9267)) W9265)) W9263)) W9260)) W9257)))

(defun shen.<minus> (V9269) (let W9270 (if (shen.=hd? V9269 45) (let W9271 (shen.tls V9269) (shen.comb (shen.in-> W9271) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W9270) (shen.parse-failure) W9270)))

(defun shen.<plus> (V9272) (let W9273 (if (shen.=hd? V9272 43) (let W9274 (shen.tls V9272) (shen.comb (shen.in-> W9274) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W9273) (shen.parse-failure) W9273)))

(defun shen.<integer> (V9275) (let W9276 (let W9277 (shen.<digits> V9275) (if (shen.parse-failure? W9277) (shen.parse-failure) (shen.comb (shen.in-> W9277) (shen.compute-integer (shen.<-out W9277))))) (if (shen.parse-failure? W9276) (shen.parse-failure) W9276)))

(defun shen.<digits> (V9278) (let W9279 (let W9280 (shen.<digit> V9278) (if (shen.parse-failure? W9280) (shen.parse-failure) (let W9281 (shen.<digits> W9280) (if (shen.parse-failure? W9281) (shen.parse-failure) (shen.comb (shen.in-> W9281) (cons (shen.<-out W9280) (shen.<-out W9281))))))) (if (shen.parse-failure? W9279) (let W9282 (let W9283 (shen.<digit> V9278) (if (shen.parse-failure? W9283) (shen.parse-failure) (shen.comb (shen.in-> W9283) (cons (shen.<-out W9283) ())))) (if (shen.parse-failure? W9282) (shen.parse-failure) W9282)) W9279)))

(defun shen.<digit> (V9284) (let W9285 (if (shen.non-empty-stream? V9284) (let W9286 (shen.hds V9284) (let W9287 (shen.tls V9284) (if (shen.digit? W9286) (shen.comb (shen.in-> W9287) (shen.byte->digit W9286)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W9285) (shen.parse-failure) W9285)))

(defun shen.byte->digit (V9288) (- V9288 48))

(defun shen.compute-integer (V9289) (shen.compute-integer-h (reverse V9289) 0))

(defun shen.compute-integer-h (V9292 V9293) (cond ((= () V9292) 0) ((cons? V9292) (+ (* (shen.expt 10 V9293) (hd V9292)) (shen.compute-integer-h (tl V9292) (+ V9293 1)))) (true (shen.f-error shen.compute-integer-h))))

(defun shen.expt (V9296 V9297) (cond ((= 0 V9297) 1) ((> V9297 0) (* V9296 (shen.expt V9296 (- V9297 1)))) (true (/ (shen.expt V9296 (+ V9297 1)) V9296))))

(defun shen.<float> (V9298) (let W9299 (let W9300 (shen.<integer> V9298) (if (shen.parse-failure? W9300) (shen.parse-failure) (let W9301 (shen.<stop> W9300) (if (shen.parse-failure? W9301) (shen.parse-failure) (let W9302 (shen.<fraction> W9301) (if (shen.parse-failure? W9302) (shen.parse-failure) (shen.comb (shen.in-> W9302) (+ (shen.<-out W9300) (shen.<-out W9302))))))))) (if (shen.parse-failure? W9299) (let W9303 (let W9304 (shen.<stop> V9298) (if (shen.parse-failure? W9304) (shen.parse-failure) (let W9305 (shen.<fraction> W9304) (if (shen.parse-failure? W9305) (shen.parse-failure) (shen.comb (shen.in-> W9305) (shen.<-out W9305)))))) (if (shen.parse-failure? W9303) (shen.parse-failure) W9303)) W9299)))

(defun shen.<stop> (V9306) (let W9307 (if (shen.=hd? V9306 46) (let W9308 (shen.tls V9306) (shen.comb (shen.in-> W9308) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W9307) (shen.parse-failure) W9307)))

(defun shen.<fraction> (V9309) (let W9310 (let W9311 (shen.<digits> V9309) (if (shen.parse-failure? W9311) (shen.parse-failure) (shen.comb (shen.in-> W9311) (shen.compute-fraction (shen.<-out W9311))))) (if (shen.parse-failure? W9310) (shen.parse-failure) W9310)))

(defun shen.compute-fraction (V9312) (shen.compute-fraction-h V9312 -1))

(defun shen.compute-fraction-h (V9315 V9316) (cond ((= () V9315) 0) ((cons? V9315) (+ (* (shen.expt 10 V9316) (hd V9315)) (shen.compute-fraction-h (tl V9315) (- V9316 1)))) (true (shen.f-error shen.compute-fraction-h))))

(defun shen.<e-number> (V9317) (let W9318 (let W9319 (shen.<float> V9317) (if (shen.parse-failure? W9319) (shen.parse-failure) (let W9320 (shen.<lowE> W9319) (if (shen.parse-failure? W9320) (shen.parse-failure) (let W9321 (shen.<log10> W9320) (if (shen.parse-failure? W9321) (shen.parse-failure) (shen.comb (shen.in-> W9321) (shen.compute-E (shen.<-out W9319) (shen.<-out W9321))))))))) (if (shen.parse-failure? W9318) (let W9322 (let W9323 (shen.<integer> V9317) (if (shen.parse-failure? W9323) (shen.parse-failure) (let W9324 (shen.<lowE> W9323) (if (shen.parse-failure? W9324) (shen.parse-failure) (let W9325 (shen.<log10> W9324) (if (shen.parse-failure? W9325) (shen.parse-failure) (shen.comb (shen.in-> W9325) (shen.compute-E (shen.<-out W9323) (shen.<-out W9325))))))))) (if (shen.parse-failure? W9322) (shen.parse-failure) W9322)) W9318)))

(defun shen.<log10> (V9326) (let W9327 (let W9328 (shen.<plus> V9326) (if (shen.parse-failure? W9328) (shen.parse-failure) (let W9329 (shen.<log10> W9328) (if (shen.parse-failure? W9329) (shen.parse-failure) (shen.comb (shen.in-> W9329) (shen.<-out W9329)))))) (if (shen.parse-failure? W9327) (let W9330 (let W9331 (shen.<minus> V9326) (if (shen.parse-failure? W9331) (shen.parse-failure) (let W9332 (shen.<log10> W9331) (if (shen.parse-failure? W9332) (shen.parse-failure) (shen.comb (shen.in-> W9332) (- 0 (shen.<-out W9332))))))) (if (shen.parse-failure? W9330) (let W9333 (let W9334 (shen.<integer> V9326) (if (shen.parse-failure? W9334) (shen.parse-failure) (shen.comb (shen.in-> W9334) (shen.<-out W9334)))) (if (shen.parse-failure? W9333) (shen.parse-failure) W9333)) W9330)) W9327)))

(defun shen.<lowE> (V9335) (let W9336 (if (shen.=hd? V9335 101) (let W9337 (shen.tls V9335) (shen.comb (shen.in-> W9337) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W9336) (shen.parse-failure) W9336)))

(defun shen.compute-E (V9338 V9339) (* V9338 (shen.expt 10 V9339)))

(defun shen.<whitespaces> (V9340) (let W9341 (let W9342 (shen.<whitespace> V9340) (if (shen.parse-failure? W9342) (shen.parse-failure) (let W9343 (shen.<whitespaces> W9342) (if (shen.parse-failure? W9343) (shen.parse-failure) (shen.comb (shen.in-> W9343) shen.skip))))) (if (shen.parse-failure? W9341) (let W9344 (let W9345 (shen.<whitespace> V9340) (if (shen.parse-failure? W9345) (shen.parse-failure) (shen.comb (shen.in-> W9345) shen.skip))) (if (shen.parse-failure? W9344) (shen.parse-failure) W9344)) W9341)))

(defun shen.<whitespace> (V9346) (let W9347 (if (shen.non-empty-stream? V9346) (let W9348 (shen.hds V9346) (let W9349 (shen.tls V9346) (if (shen.whitespace? W9348) (shen.comb (shen.in-> W9349) shen.skip) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W9347) (shen.parse-failure) W9347)))

(defun shen.whitespace? (V9352) (cond ((= 32 V9352) true) ((= 13 V9352) true) ((= 10 V9352) true) ((= 9 V9352) true) (true false)))

(defun shen.unpackage&macroexpand (V9353) (cond ((= () V9353) ()) ((and (cons? V9353) (shen.packaged? (hd V9353))) (shen.unpackage&macroexpand (append (shen.unpackage (hd V9353)) (tl V9353)))) ((cons? V9353) (let W9354 (macroexpand (hd V9353)) (if (shen.packaged? W9354) (shen.unpackage&macroexpand (cons W9354 (tl V9353))) (cons W9354 (shen.unpackage&macroexpand (tl V9353)))))) (true (shen.f-error shen.unpackage&macroexpand))))

(defun shen.packaged? (V9357) (cond ((and (cons? V9357) (and (= package (hd V9357)) (and (cons? (tl V9357)) (cons? (tl (tl V9357)))))) true) (true false)))

(defun shen.unpackage (V9360) (cond ((and (cons? V9360) (and (= package (hd V9360)) (and (cons? (tl V9360)) (and (= null (hd (tl V9360))) (cons? (tl (tl V9360))))))) (tl (tl (tl V9360)))) ((and (cons? V9360) (and (= package (hd V9360)) (and (cons? (tl V9360)) (cons? (tl (tl V9360)))))) (let W9361 (eval (hd (tl (tl V9360)))) (let W9362 (shen.package-symbols (str (hd (tl V9360))) W9361 (tl (tl (tl V9360)))) (let W9363 (shen.record-external (hd (tl V9360)) W9361) (let W9364 (shen.record-internal (hd (tl V9360)) W9361 (tl (tl (tl V9360)))) W9362))))) (true (shen.f-error shen.unpackage))))

(defun shen.record-internal (V9365 V9366 V9367) (put V9365 shen.internal-symbols (shen.internal-symbols (str V9365) V9366 V9367) (value *property-vector*)))

(defun shen.internal-symbols (V9374 V9375 V9376) (cond ((cons? V9376) (union (shen.internal-symbols V9374 V9375 (hd V9376)) (shen.internal-symbols V9374 V9375 (tl V9376)))) ((shen.internal? V9376 V9374 V9375) (cons (shen.intern-in-package V9374 V9376) ())) (true ())))

(defun shen.record-external (V9377 V9378) (let W9379 (trap-error (get V9377 shen.external-symbols (value *property-vector*)) (lambda Z9380 ())) (put V9377 shen.external-symbols (union V9378 W9379) (value *property-vector*))))

(defun shen.package-symbols (V9385 V9386 V9387) (cond ((cons? V9387) (map (lambda Z9388 (shen.package-symbols V9385 V9386 Z9388)) V9387)) ((shen.internal? V9387 V9385 V9386) (shen.intern-in-package V9385 V9387)) (true V9387)))

(defun shen.intern-in-package (V9389 V9390) (intern (@s V9389 (@s "." (str V9390)))))

(defun shen.internal? (V9391 V9392 V9393) (and (not (element? V9391 V9393)) (and (not (shen.sng? V9391)) (and (not (shen.dbl? V9391)) (and (symbol? V9391) (and (not (shen.sysfunc? V9391)) (and (not (variable? V9391)) (and (not (shen.internal-to-shen? (str V9391))) (not (shen.internal-to-P? V9392 (str V9391)))))))))))

(defun shen.internal-to-shen? (V9398) (cond ((and (shen.+string? V9398) (and (= "s" (hdstr V9398)) (and (shen.+string? (tlstr V9398)) (and (= "h" (hdstr (tlstr V9398))) (and (shen.+string? (tlstr (tlstr V9398))) (and (= "e" (hdstr (tlstr (tlstr V9398)))) (and (shen.+string? (tlstr (tlstr (tlstr V9398)))) (and (= "n" (hdstr (tlstr (tlstr (tlstr V9398))))) (and (shen.+string? (tlstr (tlstr (tlstr (tlstr V9398))))) (= "." (hdstr (tlstr (tlstr (tlstr (tlstr V9398))))))))))))))) true) (true false)))

(defun shen.sysfunc? (V9399) (element? V9399 (get shen shen.external-symbols (value *property-vector*))))

(defun shen.internal-to-P? (V9407 V9408) (cond ((and (= "" V9407) (and (shen.+string? V9408) (= "." (hdstr V9408)))) true) ((and (shen.+string? V9407) (and (shen.+string? V9408) (= (hdstr V9407) (hdstr V9408)))) (shen.internal-to-P? (tlstr V9407) (tlstr V9408))) (true false)))

(defun shen.process-applications (V9411 V9412) (cond ((element? V9411 V9412) V9411) ((and (cons? V9411) (shen.non-application? (hd V9411))) (shen.special-case (hd V9411) V9411 V9412)) ((cons? V9411) (shen.process-application (map (lambda Z9413 (shen.process-applications Z9413 V9412)) V9411) V9412)) (true V9411)))

(defun shen.non-application? (V9416) (cond ((= define V9416) true) ((= defun V9416) true) ((= synonyms V9416) true) ((shen.special? V9416) true) ((shen.extraspecial? V9416) true) (true false)))

(defun shen.special-case (V9421 V9422 V9423) (cond ((and (= lambda V9421) (and (cons? V9422) (and (= lambda (hd V9422)) (and (cons? (tl V9422)) (and (cons? (tl (tl V9422))) (= () (tl (tl (tl V9422))))))))) (cons lambda (cons (hd (tl V9422)) (cons (shen.process-applications (hd (tl (tl V9422))) V9423) ())))) ((and (= let V9421) (and (cons? V9422) (and (= let (hd V9422)) (and (cons? (tl V9422)) (and (cons? (tl (tl V9422))) (and (cons? (tl (tl (tl V9422)))) (= () (tl (tl (tl (tl V9422))))))))))) (cons let (cons (hd (tl V9422)) (cons (shen.process-applications (hd (tl (tl V9422))) V9423) (cons (shen.process-applications (hd (tl (tl (tl V9422)))) V9423) ()))))) ((and (= defun V9421) (and (cons? V9422) (and (= defun (hd V9422)) (and (cons? (tl V9422)) (and (cons? (tl (tl V9422))) (and (cons? (tl (tl (tl V9422)))) (= () (tl (tl (tl (tl V9422))))))))))) V9422) ((and (= define V9421) (and (cons? V9422) (and (= define (hd V9422)) (and (cons? (tl V9422)) (and (cons? (tl (tl V9422))) (= { (hd (tl (tl V9422))))))))) (cons define (cons (hd (tl V9422)) (cons { (shen.process-after-type (hd (tl V9422)) (tl (tl (tl V9422))) V9423))))) ((and (= define V9421) (and (cons? V9422) (and (= define (hd V9422)) (cons? (tl V9422))))) (cons define (cons (hd (tl V9422)) (map (lambda Z9424 (shen.process-applications Z9424 V9423)) (tl (tl V9422)))))) ((= synonyms V9421) (cons synonyms V9422)) ((and (= type V9421) (and (cons? V9422) (and (= type (hd V9422)) (and (cons? (tl V9422)) (and (cons? (tl (tl V9422))) (= () (tl (tl (tl V9422))))))))) (cons type (cons (shen.process-applications (hd (tl V9422)) V9423) (tl (tl V9422))))) ((and (= input+ V9421) (and (cons? V9422) (and (= input+ (hd V9422)) (and (cons? (tl V9422)) (and (cons? (tl (tl V9422))) (= () (tl (tl (tl V9422))))))))) (cons input+ (cons (hd (tl V9422)) (cons (shen.process-applications (hd (tl (tl V9422))) V9423) ())))) ((and (cons? V9422) (shen.special? (hd V9422))) (cons (hd V9422) (map (lambda Z9425 (shen.process-applications Z9425 V9423)) (tl V9422)))) ((and (cons? V9422) (shen.extraspecial? (hd V9422))) V9422) (true (shen.f-error shen.special-case))))

(defun shen.process-after-type (V9428 V9429 V9430) (cond ((and (cons? V9429) (= } (hd V9429))) (cons } (map (lambda Z9431 (shen.process-applications Z9431 V9430)) (tl V9429)))) ((cons? V9429) (cons (hd V9429) (shen.process-after-type V9428 (tl V9429) V9430))) (true (simple-error (cn "missing } in " (shen.app V9428 "
" shen.a))))))

(defun shen.process-application (V9432 V9433) (cond ((cons? V9432) (let W9434 (arity (hd V9432)) (let W9435 (length (tl V9432)) (if (element? V9432 V9433) V9432 (if (shen.shen-call? (hd V9432)) V9432 (if (shen.foreign? V9432) (shen.unpack-foreign V9432) (if (shen.fn-call? V9432) (shen.fn-call V9432) (if (shen.zero-place? V9432) V9432 (if (shen.undefined-f? (hd V9432) W9434) (shen.simple-curry (cons (cons fn (cons (hd V9432) ())) (tl V9432))) (if (variable? (hd V9432)) (shen.simple-curry V9432) (if (shen.application? (hd V9432)) (shen.simple-curry V9432) (if (shen.partial-application*? (hd V9432) W9434 W9435) (shen.lambda-function V9432 (- W9434 W9435)) (if (shen.overapplication? (hd V9432) W9434 W9435) (shen.simple-curry (cons (cons fn (cons (hd V9432) ())) (tl V9432))) V9432))))))))))))) (true (shen.f-error shen.process-application))))

(defun shen.unpack-foreign (V9436) (cond ((and (cons? V9436) (and (cons? (hd V9436)) (and (= foreign (hd (hd V9436))) (and (cons? (tl (hd V9436))) (= () (tl (tl (hd V9436)))))))) (cons (hd (tl (hd V9436))) (tl V9436))) (true (shen.f-error shen.unpack-foreign))))

(defun shen.foreign? (V9439) (cond ((and (cons? V9439) (and (cons? (hd V9439)) (and (= foreign (hd (hd V9439))) (and (cons? (tl (hd V9439))) (= () (tl (tl (hd V9439)))))))) true) (true false)))

(defun shen.zero-place? (V9442) (cond ((and (cons? V9442) (= () (tl V9442))) true) (true false)))

(defun shen.shen-call? (V9443) (and (symbol? V9443) (shen.internal-to-shen? (str V9443))))

(defun shen.internal-to-shen? (V9448) (cond ((and (shen.+string? V9448) (and (= "s" (hdstr V9448)) (and (shen.+string? (tlstr V9448)) (and (= "h" (hdstr (tlstr V9448))) (and (shen.+string? (tlstr (tlstr V9448))) (and (= "e" (hdstr (tlstr (tlstr V9448)))) (and (shen.+string? (tlstr (tlstr (tlstr V9448)))) (and (= "n" (hdstr (tlstr (tlstr (tlstr V9448))))) (and (shen.+string? (tlstr (tlstr (tlstr (tlstr V9448))))) (= "." (hdstr (tlstr (tlstr (tlstr (tlstr V9448))))))))))))))) true) (true false)))

(defun shen.application? (V9453) (cond ((and (cons? V9453) (and (= protect (hd V9453)) (and (cons? (tl V9453)) (= () (tl (tl V9453)))))) false) ((and (cons? V9453) (and (= foreign (hd V9453)) (and (cons? (tl V9453)) (= () (tl (tl V9453)))))) false) (true (cons? V9453))))

(defun shen.undefined-f? (V9458 V9459) (cond ((= -1 V9459) (and (shen.lowercase-symbol? V9458) (not (element? V9458 (external shen))))) (true false)))

(defun shen.lowercase-symbol? (V9460) (and (symbol? V9460) (not (variable? V9460))))

(defun shen.simple-curry (V9461) (cond ((and (cons? V9461) (and (cons? (tl V9461)) (= () (tl (tl V9461))))) V9461) ((and (cons? V9461) (and (cons? (tl V9461)) (cons? (tl (tl V9461))))) (shen.simple-curry (cons (cons (hd V9461) (cons (hd (tl V9461)) ())) (tl (tl V9461))))) (true V9461)))

(defun function (V9462) (fn V9462))

(defun fn (V9463) (let W9464 (assoc V9463 (value shen.*lambdatable*)) (if (empty? W9464) (simple-error (cn "fn: " (shen.app V9463 " is undefined
" shen.a))) (tl W9464))))

(defun shen.fn-call? (V9467) (cond ((and (cons? V9467) (and (= fn (hd V9467)) (and (cons? (tl V9467)) (= () (tl (tl V9467)))))) true) ((and (cons? V9467) (and (= function (hd V9467)) (and (cons? (tl V9467)) (= () (tl (tl V9467)))))) true) (true false)))

(defun shen.fn-call (V9468) (cond ((and (cons? V9468) (and (= function (hd V9468)) (and (cons? (tl V9468)) (= () (tl (tl V9468)))))) (shen.fn-call (cons fn (tl V9468)))) ((and (cons? V9468) (and (= fn (hd V9468)) (and (cons? (tl V9468)) (= () (tl (tl V9468)))))) (let W9469 (arity (hd (tl V9468))) (if (= W9469 -1) V9468 (if (= W9469 0) (simple-error "fn cannot be applied to a zero place function
") (shen.lambda-function (tl V9468) W9469))))) (true (shen.f-error shen.fn-call))))

(defun shen.partial-application*? (V9470 V9471 V9472) (let W9473 (> V9471 V9472) (let W9474 (if (and W9473 (and (shen.loading?) (not (element? V9470 (cons + (cons - ())))))) (pr (cn "partial application of " (shen.app V9470 "
" shen.a)) (stoutput)) shen.skip) W9473)))

(defun shen.loading? () (value shen.*loading?*))

(defun shen.overapplication? (V9479 V9480 V9481) (cond ((= -1 V9480) false) (true (let W9482 (< V9480 V9481) (let W9483 (if (and W9482 (shen.loading?)) (pr (shen.app V9479 (cn " might not like " (shen.app V9481 (cn " argument" (shen.app (if (= V9481 1) "" "s") "
" shen.a)) shen.a)) shen.a) (stoutput)) shen.skip) W9482)))))

