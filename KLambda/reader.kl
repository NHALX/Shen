(defun read-file (V3311) (let W3312 (read-file-as-bytelist V3311) (let W3313 (trap-error (compile (lambda Z3314 (shen.<s-exprs> Z3314)) W3312) (lambda Z3315 (shen.print-residue (value shen.*residue*)))) (let W3316 (shen.process-sexprs W3313) W3316))))

(defun shen.print-residue (V3317) (let W3318 (pr "syntax error here:
" (stoutput)) (shen.nchars 50 V3317)))

(defun shen.nchars (V3323 V3324) (cond ((= 0 V3323) (do (pr " ..." (stoutput)) (abort))) ((= () V3324) (do (pr " ..." (stoutput)) (abort))) ((cons? V3324) (do (pr (n->string (hd V3324)) (stoutput)) (shen.nchars (- V3323 1) (tl V3324)))) (true (shen.f-error shen.nchars))))

(defun it () (value shen.*it*))

(defun read-file-as-bytelist (V3325) (let W3326 (open V3325 in) (let W3327 (read-byte W3326) (let W3328 (shen.read-file-as-bytelist-help W3326 W3327 ()) (let W3329 (close W3326) (reverse W3328))))))

(defun shen.read-file-as-bytelist-help (V3330 V3331 V3332) (cond ((= -1 V3331) V3332) (true (shen.read-file-as-bytelist-help V3330 (read-byte V3330) (cons V3331 V3332)))))

(defun read-file-as-string (V3333) (let W3334 (open V3333 in) (shen.rfas-h W3334 (read-byte W3334) "")))

(defun shen.rfas-h (V3335 V3336 V3337) (cond ((= -1 V3336) (do (close V3335) V3337)) (true (shen.rfas-h V3335 (read-byte V3335) (cn V3337 (n->string V3336))))))

(defun input (V3338) (eval-kl (read V3338)))

(defun input+ (V3339 V3340) (let W3341 (shen.monotype V3339) (let W3342 (read V3340) (if (= false (shen.typecheck W3342 (shen.rectify-type V3339))) (simple-error (cn "type error: " (shen.app W3342 (cn " is not of type " (shen.app V3339 "
" shen.r)) shen.r))) (eval-kl W3342)))))

(defun shen.monotype (V3343) (cond ((cons? V3343) (map (lambda Z3344 (shen.monotype Z3344)) V3343)) (true (if (variable? V3343) (simple-error (cn "input+ expects a monotype: not " (shen.app V3343 "
" shen.a))) V3343))))

(defun lineread (V3345) (shen.read-loop V3345 (shen.my-read-byte V3345) () (lambda Z3346 (shen.return? Z3346))))

(defun read-from-string (V3347) (let W3348 (shen.str->bytes V3347) (let W3349 (compile (lambda Z3350 (shen.<s-exprs> Z3350)) W3348) (let W3351 (shen.process-sexprs W3349) W3351))))

(defun read-from-string-unprocessed (V3352) (let W3353 (shen.str->bytes V3352) (let W3354 (compile (lambda Z3355 (shen.<s-exprs> Z3355)) W3353) W3354)))

(defun shen.str->bytes (V3356) (cond ((= "" V3356) ()) ((shen.+string? V3356) (cons (string->n (hdstr V3356)) (shen.str->bytes (tlstr V3356)))) (true (shen.f-error shen.str->bytes))))

(defun read (V3357) (hd (shen.read-loop V3357 (shen.my-read-byte V3357) () (lambda Z3358 (shen.whitespace? Z3358)))))

(defun shen.my-read-byte (V3359) (if (shen.char-stinput? V3359) (string->n (shen.read-unit-string V3359)) (read-byte V3359)))

(defun shen.read-loop (V3364 V3365 V3366 V3367) (cond ((= 94 V3365) (simple-error "read aborted")) ((= -1 V3365) (if (empty? V3366) (simple-error "error: empty stream") (compile (lambda Z3368 (shen.<s-exprs> Z3368)) V3366))) ((= 0 V3365) (shen.read-loop V3364 (shen.my-read-byte V3364) V3366 V3367)) (true (if (V3367 V3365) (let W3369 (shen.try-parse V3366) (if (shen.nothing-doing? W3369) (shen.read-loop V3364 (shen.my-read-byte V3364) (append V3366 (cons V3365 ())) V3367) (do (shen.record-it V3366) W3369))) (shen.read-loop V3364 (shen.my-read-byte V3364) (append V3366 (cons V3365 ())) V3367)))))

(defun shen.try-parse (V3370) (let W3371 (trap-error (compile (lambda Z3372 (shen.<s-exprs> Z3372)) V3370) (lambda Z3373 shen.i-failed!)) (if (shen.nothing-doing? W3371) shen.i-failed! (shen.process-sexprs W3371))))

(defun shen.nothing-doing? (V3376) (cond ((= shen.i-failed! V3376) true) ((= () V3376) true) (true false)))

(defun shen.record-it (V3377) (set shen.*it* (shen.bytes->string V3377)))

(defun shen.bytes->string (V3378) (cond ((= () V3378) "") ((cons? V3378) (cn (n->string (hd V3378)) (shen.bytes->string (tl V3378)))) (true (shen.f-error shen.bytes->string))))

(defun shen.process-sexprs (V3379) (let W3380 (shen.unpackage&macroexpand V3379) (let W3381 (shen.find-arities W3380) (let W3382 (shen.find-types W3380) (map (lambda Z3383 (shen.process-applications Z3383 W3382)) W3380)))))

(defun shen.find-types (V3384) (cond ((and (cons? V3384) (and (cons? (tl V3384)) (= (hd V3384) (intern ":")))) (cons (hd (tl V3384)) (shen.find-types (tl (tl V3384))))) ((cons? V3384) (append (shen.find-types (hd V3384)) (shen.find-types (tl V3384)))) (true ())))

(defun shen.find-arities (V3387) (cond ((and (cons? V3387) (and (= define (hd V3387)) (and (cons? (tl V3387)) (and (cons? (tl (tl V3387))) (= { (hd (tl (tl V3387)))))))) (shen.store-arity (hd (tl V3387)) (shen.find-arity (hd (tl V3387)) 1 (tl (tl (tl V3387)))))) ((and (cons? V3387) (and (= define (hd V3387)) (cons? (tl V3387)))) (shen.store-arity (hd (tl V3387)) (shen.find-arity (hd (tl V3387)) 0 (tl (tl V3387))))) ((cons? V3387) (map (lambda Z3388 (shen.find-arities Z3388)) V3387)) (true shen.skip)))

(defun shen.store-arity (V3389 V3390) (let W3391 (arity V3389) (if (= W3391 -1) (shen.execute-store-arity V3389 V3390) (if (= W3391 V3390) shen.skip (if (shen.sysfunc? V3389) (simple-error (shen.app V3389 " is a system function
" shen.a)) (do (pr (cn "changing the arity of " (shen.app V3389 " may cause errors
" shen.a)) (stoutput)) (shen.execute-store-arity V3389 V3390)))))))

(defun shen.execute-store-arity (V3392 V3393) (cond ((= 0 V3393) (put V3392 arity 0 (value *property-vector*))) (true (do (put V3392 arity V3393 (value *property-vector*)) (shen.update-lambdatable V3392 V3393)))))

(defun shen.update-lambdatable (V3394 V3395) (let W3396 (value shen.*lambdatable*) (let W3397 (eval-kl (shen.lambda-function (cons V3394 ()) V3395)) (let W3398 (shen.assoc-> V3394 W3397 W3396) (let W3399 (set shen.*lambdatable* W3398) W3399)))))

(defun shen.lambda-function (V3402 V3403) (cond ((= 0 V3403) shen.skip) ((= 1 V3403) (let W3404 (gensym Y) (cons lambda (cons W3404 (cons (append V3402 (cons W3404 ())) ()))))) (true (let W3405 (gensym Y) (cons lambda (cons W3405 (cons (shen.lambda-function (append V3402 (cons W3405 ())) (- V3403 1)) ())))))))

(defun shen.assoc-> (V3415 V3416 V3417) (cond ((= () V3417) (cons (cons V3415 V3416) ())) ((and (cons? V3417) (and (cons? (hd V3417)) (= V3415 (hd (hd V3417))))) (cons (cons (hd (hd V3417)) V3416) (tl V3417))) ((cons? V3417) (cons (hd V3417) (shen.assoc-> V3415 V3416 (tl V3417)))) (true (simple-error "implementation error in shen.assoc->"))))

(defun shen.find-arity (V3432 V3433 V3434) (cond ((and (= 0 V3433) (and (cons? V3434) (= (hd V3434) ->))) 0) ((and (= 0 V3433) (and (cons? V3434) (= (hd V3434) <-))) 0) ((and (= 0 V3433) (cons? V3434)) (+ 1 (shen.find-arity V3432 0 (tl V3434)))) ((and (= 1 V3433) (and (cons? V3434) (= } (hd V3434)))) (shen.find-arity V3432 0 (tl V3434))) ((and (= 1 V3433) (cons? V3434)) (shen.find-arity V3432 1 (tl V3434))) ((= 1 V3433) (simple-error (cn "syntax error in " (shen.app V3432 " definition: missing }
" shen.a)))) (true (simple-error (cn "syntax error in " (shen.app V3432 " definition: missing -> or <-
" shen.a))))))

(defun shen.<s-exprs> (V3435) (let W3436 (let W3437 (shen.<lsb> V3435) (if (shen.parse-failure? W3437) (shen.parse-failure) (let W3438 (shen.<s-exprs1> W3437) (if (shen.parse-failure? W3438) (shen.parse-failure) (let W3439 (shen.<rsb> W3438) (if (shen.parse-failure? W3439) (shen.parse-failure) (let W3440 (shen.<s-exprs2> W3439) (if (shen.parse-failure? W3440) (shen.parse-failure) (shen.comb (shen.in-> W3440) (cons (shen.cons-form (shen.<-out W3438)) (shen.<-out W3440))))))))))) (if (shen.parse-failure? W3436) (let W3441 (let W3442 (shen.<lrb> V3435) (if (shen.parse-failure? W3442) (shen.parse-failure) (let W3443 (shen.<s-exprs1> W3442) (if (shen.parse-failure? W3443) (shen.parse-failure) (let W3444 (shen.<rrb> W3443) (if (shen.parse-failure? W3444) (shen.parse-failure) (let W3445 (shen.<s-exprs2> W3444) (if (shen.parse-failure? W3445) (shen.parse-failure) (shen.comb (shen.in-> W3445) (shen.add-sexpr (shen.<-out W3443) (shen.<-out W3445))))))))))) (if (shen.parse-failure? W3441) (let W3446 (let W3447 (shen.<lcurly> V3435) (if (shen.parse-failure? W3447) (shen.parse-failure) (let W3448 (shen.<s-exprs> W3447) (if (shen.parse-failure? W3448) (shen.parse-failure) (shen.comb (shen.in-> W3448) (cons { (shen.<-out W3448))))))) (if (shen.parse-failure? W3446) (let W3449 (let W3450 (shen.<rcurly> V3435) (if (shen.parse-failure? W3450) (shen.parse-failure) (let W3451 (shen.<s-exprs> W3450) (if (shen.parse-failure? W3451) (shen.parse-failure) (shen.comb (shen.in-> W3451) (cons } (shen.<-out W3451))))))) (if (shen.parse-failure? W3449) (let W3452 (let W3453 (shen.<bar> V3435) (if (shen.parse-failure? W3453) (shen.parse-failure) (let W3454 (shen.<s-exprs> W3453) (if (shen.parse-failure? W3454) (shen.parse-failure) (shen.comb (shen.in-> W3454) (cons bar! (shen.<-out W3454))))))) (if (shen.parse-failure? W3452) (let W3455 (let W3456 (shen.<semicolon> V3435) (if (shen.parse-failure? W3456) (shen.parse-failure) (let W3457 (shen.<s-exprs> W3456) (if (shen.parse-failure? W3457) (shen.parse-failure) (shen.comb (shen.in-> W3457) (cons (intern ";") (shen.<-out W3457))))))) (if (shen.parse-failure? W3455) (let W3458 (let W3459 (shen.<colon> V3435) (if (shen.parse-failure? W3459) (shen.parse-failure) (let W3460 (shen.<equal> W3459) (if (shen.parse-failure? W3460) (shen.parse-failure) (let W3461 (shen.<s-exprs> W3460) (if (shen.parse-failure? W3461) (shen.parse-failure) (shen.comb (shen.in-> W3461) (cons (intern ":=") (shen.<-out W3461))))))))) (if (shen.parse-failure? W3458) (let W3462 (let W3463 (shen.<colon> V3435) (if (shen.parse-failure? W3463) (shen.parse-failure) (let W3464 (shen.<s-exprs> W3463) (if (shen.parse-failure? W3464) (shen.parse-failure) (shen.comb (shen.in-> W3464) (cons (intern ":") (shen.<-out W3464))))))) (if (shen.parse-failure? W3462) (let W3465 (let W3466 (shen.<comma> V3435) (if (shen.parse-failure? W3466) (shen.parse-failure) (let W3467 (shen.<s-exprs> W3466) (if (shen.parse-failure? W3467) (shen.parse-failure) (shen.comb (shen.in-> W3467) (cons (intern ",") (shen.<-out W3467))))))) (if (shen.parse-failure? W3465) (let W3468 (let W3469 (shen.<comment> V3435) (if (shen.parse-failure? W3469) (shen.parse-failure) (let W3470 (shen.<s-exprs> W3469) (if (shen.parse-failure? W3470) (shen.parse-failure) (shen.comb (shen.in-> W3470) (shen.<-out W3470)))))) (if (shen.parse-failure? W3468) (let W3471 (let W3472 (shen.<atom> V3435) (if (shen.parse-failure? W3472) (shen.parse-failure) (let W3473 (shen.<s-exprs> W3472) (if (shen.parse-failure? W3473) (shen.parse-failure) (shen.comb (shen.in-> W3473) (cons (shen.<-out W3472) (shen.<-out W3473))))))) (if (shen.parse-failure? W3471) (let W3474 (let W3475 (shen.<whitespaces> V3435) (if (shen.parse-failure? W3475) (shen.parse-failure) (let W3476 (shen.<s-exprs> W3475) (if (shen.parse-failure? W3476) (shen.parse-failure) (shen.comb (shen.in-> W3476) (shen.<-out W3476)))))) (if (shen.parse-failure? W3474) (let W3477 (let W3478 (<e> V3435) (if (shen.parse-failure? W3478) (shen.parse-failure) (shen.comb (shen.in-> W3478) ()))) (if (shen.parse-failure? W3477) (shen.parse-failure) W3477)) W3474)) W3471)) W3468)) W3465)) W3462)) W3458)) W3455)) W3452)) W3449)) W3446)) W3441)) W3436)))

(defun shen.add-sexpr (V3479 V3480) (cond ((and (cons? V3479) (and (= $ (hd V3479)) (and (cons? (tl V3479)) (= () (tl (tl V3479)))))) (append (explode (hd (tl V3479))) V3480)) (true (cons V3479 V3480))))

(defun shen.<lsb> (V3481) (let W3482 (if (shen.=hd? V3481 91) (let W3483 (shen.tls V3481) (shen.comb (shen.in-> W3483) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W3482) (shen.parse-failure) W3482)))

(defun shen.<rsb> (V3484) (let W3485 (if (shen.=hd? V3484 93) (let W3486 (shen.tls V3484) (shen.comb (shen.in-> W3486) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W3485) (shen.parse-failure) W3485)))

(defun shen.<s-exprs1> (V3487) (let W3488 (let W3489 (shen.<s-exprs> V3487) (if (shen.parse-failure? W3489) (shen.parse-failure) (shen.comb (shen.in-> W3489) (shen.<-out W3489)))) (if (shen.parse-failure? W3488) (shen.parse-failure) W3488)))

(defun shen.<s-exprs2> (V3490) (let W3491 (let W3492 (shen.<s-exprs> V3490) (if (shen.parse-failure? W3492) (shen.parse-failure) (shen.comb (shen.in-> W3492) (shen.<-out W3492)))) (if (shen.parse-failure? W3491) (shen.parse-failure) W3491)))

(defun shen.cons-form (V3494) (cond ((= () V3494) ()) ((and (cons? V3494) (and (cons? (tl V3494)) (and (cons? (tl (tl V3494))) (and (= () (tl (tl (tl V3494)))) (= (hd (tl V3494)) bar!))))) (cons cons (cons (hd V3494) (tl (tl V3494))))) ((and (cons? V3494) (and (cons? (tl V3494)) (and (cons? (tl (tl V3494))) (and (cons? (tl (tl (tl V3494)))) (= (hd (tl V3494)) bar!))))) (simple-error "misapplication of |
")) ((cons? V3494) (cons cons (cons (hd V3494) (cons (shen.cons-form (tl V3494)) ())))) (true (shen.f-error shen.cons-form))))

(defun shen.<lrb> (V3495) (let W3496 (if (shen.=hd? V3495 40) (let W3497 (shen.tls V3495) (shen.comb (shen.in-> W3497) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W3496) (shen.parse-failure) W3496)))

(defun shen.<rrb> (V3498) (let W3499 (if (shen.=hd? V3498 41) (let W3500 (shen.tls V3498) (shen.comb (shen.in-> W3500) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W3499) (shen.parse-failure) W3499)))

(defun shen.<lcurly> (V3501) (let W3502 (if (shen.=hd? V3501 123) (let W3503 (shen.tls V3501) (shen.comb (shen.in-> W3503) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W3502) (shen.parse-failure) W3502)))

(defun shen.<rcurly> (V3504) (let W3505 (if (shen.=hd? V3504 125) (let W3506 (shen.tls V3504) (shen.comb (shen.in-> W3506) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W3505) (shen.parse-failure) W3505)))

(defun shen.<bar> (V3507) (let W3508 (if (shen.=hd? V3507 124) (let W3509 (shen.tls V3507) (shen.comb (shen.in-> W3509) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W3508) (shen.parse-failure) W3508)))

(defun shen.<semicolon> (V3510) (let W3511 (if (shen.=hd? V3510 59) (let W3512 (shen.tls V3510) (shen.comb (shen.in-> W3512) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W3511) (shen.parse-failure) W3511)))

(defun shen.<colon> (V3513) (let W3514 (if (shen.=hd? V3513 58) (let W3515 (shen.tls V3513) (shen.comb (shen.in-> W3515) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W3514) (shen.parse-failure) W3514)))

(defun shen.<comma> (V3516) (let W3517 (if (shen.=hd? V3516 44) (let W3518 (shen.tls V3516) (shen.comb (shen.in-> W3518) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W3517) (shen.parse-failure) W3517)))

(defun shen.<equal> (V3519) (let W3520 (if (shen.=hd? V3519 61) (let W3521 (shen.tls V3519) (shen.comb (shen.in-> W3521) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W3520) (shen.parse-failure) W3520)))

(defun shen.<comment> (V3522) (let W3523 (let W3524 (shen.<singleline> V3522) (if (shen.parse-failure? W3524) (shen.parse-failure) (shen.comb (shen.in-> W3524) shen.skip))) (if (shen.parse-failure? W3523) (let W3525 (let W3526 (shen.<multiline> V3522) (if (shen.parse-failure? W3526) (shen.parse-failure) (shen.comb (shen.in-> W3526) shen.skip))) (if (shen.parse-failure? W3525) (shen.parse-failure) W3525)) W3523)))

(defun shen.<singleline> (V3527) (let W3528 (let W3529 (shen.<backslash> V3527) (if (shen.parse-failure? W3529) (shen.parse-failure) (let W3530 (shen.<backslash> W3529) (if (shen.parse-failure? W3530) (shen.parse-failure) (let W3531 (shen.<shortnatters> W3530) (if (shen.parse-failure? W3531) (shen.parse-failure) (let W3532 (shen.<returns> W3531) (if (shen.parse-failure? W3532) (shen.parse-failure) (shen.comb (shen.in-> W3532) shen.skip))))))))) (if (shen.parse-failure? W3528) (shen.parse-failure) W3528)))

(defun shen.<backslash> (V3533) (let W3534 (if (shen.=hd? V3533 92) (let W3535 (shen.tls V3533) (shen.comb (shen.in-> W3535) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W3534) (shen.parse-failure) W3534)))

(defun shen.<shortnatters> (V3536) (let W3537 (let W3538 (shen.<shortnatter> V3536) (if (shen.parse-failure? W3538) (shen.parse-failure) (let W3539 (shen.<shortnatters> W3538) (if (shen.parse-failure? W3539) (shen.parse-failure) (shen.comb (shen.in-> W3539) shen.skip))))) (if (shen.parse-failure? W3537) (let W3540 (let W3541 (<e> V3536) (if (shen.parse-failure? W3541) (shen.parse-failure) (shen.comb (shen.in-> W3541) shen.skip))) (if (shen.parse-failure? W3540) (shen.parse-failure) W3540)) W3537)))

(defun shen.<shortnatter> (V3542) (let W3543 (if (shen.non-empty-stream? V3542) (let W3544 (shen.hds V3542) (let W3545 (shen.tls V3542) (if (not (shen.return? W3544)) (shen.comb (shen.in-> W3545) shen.skip) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W3543) (shen.parse-failure) W3543)))

(defun shen.<returns> (V3546) (let W3547 (let W3548 (shen.<return> V3546) (if (shen.parse-failure? W3548) (shen.parse-failure) (let W3549 (shen.<returns> W3548) (if (shen.parse-failure? W3549) (shen.parse-failure) (shen.comb (shen.in-> W3549) shen.skip))))) (if (shen.parse-failure? W3547) (let W3550 (let W3551 (shen.<return> V3546) (if (shen.parse-failure? W3551) (shen.parse-failure) (shen.comb (shen.in-> W3551) shen.skip))) (if (shen.parse-failure? W3550) (shen.parse-failure) W3550)) W3547)))

(defun shen.<return> (V3552) (let W3553 (if (shen.non-empty-stream? V3552) (let W3554 (shen.hds V3552) (let W3555 (shen.tls V3552) (if (shen.return? W3554) (shen.comb (shen.in-> W3555) shen.skip) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W3553) (shen.parse-failure) W3553)))

(defun shen.return? (V3556) (element? V3556 (cons 9 (cons 10 (cons 13 ())))))

(defun shen.<multiline> (V3557) (let W3558 (let W3559 (shen.<backslash> V3557) (if (shen.parse-failure? W3559) (shen.parse-failure) (let W3560 (shen.<times> W3559) (if (shen.parse-failure? W3560) (shen.parse-failure) (let W3561 (shen.<longnatter> W3560) (if (shen.parse-failure? W3561) (shen.parse-failure) (shen.comb (shen.in-> W3561) shen.skip))))))) (if (shen.parse-failure? W3558) (shen.parse-failure) W3558)))

(defun shen.<times> (V3562) (let W3563 (if (shen.=hd? V3562 42) (let W3564 (shen.tls V3562) (shen.comb (shen.in-> W3564) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W3563) (shen.parse-failure) W3563)))

(defun shen.<longnatter> (V3565) (let W3566 (let W3567 (shen.<comment> V3565) (if (shen.parse-failure? W3567) (shen.parse-failure) (let W3568 (shen.<longnatter> W3567) (if (shen.parse-failure? W3568) (shen.parse-failure) (shen.comb (shen.in-> W3568) shen.skip))))) (if (shen.parse-failure? W3566) (let W3569 (let W3570 (shen.<times> V3565) (if (shen.parse-failure? W3570) (shen.parse-failure) (let W3571 (shen.<backslash> W3570) (if (shen.parse-failure? W3571) (shen.parse-failure) (shen.comb (shen.in-> W3571) shen.skip))))) (if (shen.parse-failure? W3569) (let W3572 (if (shen.non-empty-stream? V3565) (let W3573 (shen.tls V3565) (let W3574 (shen.<longnatter> W3573) (if (shen.parse-failure? W3574) (shen.parse-failure) (shen.comb (shen.in-> W3574) shen.skip)))) (shen.parse-failure)) (if (shen.parse-failure? W3572) (shen.parse-failure) W3572)) W3569)) W3566)))

(defun shen.<atom> (V3575) (let W3576 (let W3577 (shen.<str> V3575) (if (shen.parse-failure? W3577) (shen.parse-failure) (shen.comb (shen.in-> W3577) (shen.<-out W3577)))) (if (shen.parse-failure? W3576) (let W3578 (let W3579 (shen.<number> V3575) (if (shen.parse-failure? W3579) (shen.parse-failure) (shen.comb (shen.in-> W3579) (shen.<-out W3579)))) (if (shen.parse-failure? W3578) (let W3580 (let W3581 (shen.<sym> V3575) (if (shen.parse-failure? W3581) (shen.parse-failure) (shen.comb (shen.in-> W3581) (if (= (shen.<-out W3581) "<>") (cons vector (cons 0 ())) (intern (shen.<-out W3581)))))) (if (shen.parse-failure? W3580) (shen.parse-failure) W3580)) W3578)) W3576)))

(defun shen.<sym> (V3582) (let W3583 (let W3584 (shen.<alpha> V3582) (if (shen.parse-failure? W3584) (shen.parse-failure) (let W3585 (shen.<alphanums> W3584) (if (shen.parse-failure? W3585) (shen.parse-failure) (shen.comb (shen.in-> W3585) (cn (shen.<-out W3584) (shen.<-out W3585))))))) (if (shen.parse-failure? W3583) (shen.parse-failure) W3583)))

(defun shen.<alpha> (V3586) (let W3587 (if (shen.non-empty-stream? V3586) (let W3588 (shen.hds V3586) (let W3589 (shen.tls V3586) (if (shen.alpha? W3588) (shen.comb (shen.in-> W3589) (n->string W3588)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W3587) (shen.parse-failure) W3587)))

(defun shen.alpha? (V3590) (or (shen.lowercase? V3590) (or (shen.uppercase? V3590) (shen.misc? V3590))))

(defun shen.lowercase? (V3591) (and (>= V3591 97) (<= V3591 122)))

(defun shen.uppercase? (V3592) (and (>= V3592 65) (<= V3592 90)))

(defun shen.misc? (V3593) (element? V3593 (cons 61 (cons 45 (cons 42 (cons 47 (cons 43 (cons 95 (cons 63 (cons 36 (cons 33 (cons 64 (cons 126 (cons 46 (cons 62 (cons 60 (cons 38 (cons 37 (cons 39 (cons 35 (cons 96 ())))))))))))))))))))))

(defun shen.<alphanums> (V3594) (let W3595 (let W3596 (shen.<alphanum> V3594) (if (shen.parse-failure? W3596) (shen.parse-failure) (let W3597 (shen.<alphanums> W3596) (if (shen.parse-failure? W3597) (shen.parse-failure) (shen.comb (shen.in-> W3597) (cn (shen.<-out W3596) (shen.<-out W3597))))))) (if (shen.parse-failure? W3595) (let W3598 (let W3599 (<e> V3594) (if (shen.parse-failure? W3599) (shen.parse-failure) (shen.comb (shen.in-> W3599) ""))) (if (shen.parse-failure? W3598) (shen.parse-failure) W3598)) W3595)))

(defun shen.<alphanum> (V3600) (let W3601 (let W3602 (shen.<alpha> V3600) (if (shen.parse-failure? W3602) (shen.parse-failure) (shen.comb (shen.in-> W3602) (shen.<-out W3602)))) (if (shen.parse-failure? W3601) (let W3603 (let W3604 (shen.<numeral> V3600) (if (shen.parse-failure? W3604) (shen.parse-failure) (shen.comb (shen.in-> W3604) (shen.<-out W3604)))) (if (shen.parse-failure? W3603) (shen.parse-failure) W3603)) W3601)))

(defun shen.<numeral> (V3605) (let W3606 (if (shen.non-empty-stream? V3605) (let W3607 (shen.hds V3605) (let W3608 (shen.tls V3605) (if (shen.digit? W3607) (shen.comb (shen.in-> W3608) (n->string W3607)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W3606) (shen.parse-failure) W3606)))

(defun shen.digit? (V3609) (and (>= V3609 48) (<= V3609 57)))

(defun shen.<str> (V3610) (let W3611 (let W3612 (shen.<dbq> V3610) (if (shen.parse-failure? W3612) (shen.parse-failure) (let W3613 (shen.<strcontents> W3612) (if (shen.parse-failure? W3613) (shen.parse-failure) (let W3614 (shen.<dbq> W3613) (if (shen.parse-failure? W3614) (shen.parse-failure) (shen.comb (shen.in-> W3614) (shen.<-out W3613)))))))) (if (shen.parse-failure? W3611) (shen.parse-failure) W3611)))

(defun shen.<dbq> (V3615) (let W3616 (if (shen.=hd? V3615 34) (let W3617 (shen.tls V3615) (shen.comb (shen.in-> W3617) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W3616) (shen.parse-failure) W3616)))

(defun shen.<strcontents> (V3618) (let W3619 (let W3620 (shen.<strc> V3618) (if (shen.parse-failure? W3620) (shen.parse-failure) (let W3621 (shen.<strcontents> W3620) (if (shen.parse-failure? W3621) (shen.parse-failure) (shen.comb (shen.in-> W3621) (cn (shen.<-out W3620) (shen.<-out W3621))))))) (if (shen.parse-failure? W3619) (let W3622 (let W3623 (<e> V3618) (if (shen.parse-failure? W3623) (shen.parse-failure) (shen.comb (shen.in-> W3623) ""))) (if (shen.parse-failure? W3622) (shen.parse-failure) W3622)) W3619)))

(defun shen.<strc> (V3624) (let W3625 (let W3626 (shen.<control> V3624) (if (shen.parse-failure? W3626) (shen.parse-failure) (shen.comb (shen.in-> W3626) (shen.<-out W3626)))) (if (shen.parse-failure? W3625) (let W3627 (let W3628 (shen.<notdbq> V3624) (if (shen.parse-failure? W3628) (shen.parse-failure) (shen.comb (shen.in-> W3628) (shen.<-out W3628)))) (if (shen.parse-failure? W3627) (shen.parse-failure) W3627)) W3625)))

(defun shen.<control> (V3629) (let W3630 (let W3631 (shen.<lowC> V3629) (if (shen.parse-failure? W3631) (shen.parse-failure) (let W3632 (shen.<hash> W3631) (if (shen.parse-failure? W3632) (shen.parse-failure) (let W3633 (shen.<integer> W3632) (if (shen.parse-failure? W3633) (shen.parse-failure) (let W3634 (shen.<semicolon> W3633) (if (shen.parse-failure? W3634) (shen.parse-failure) (shen.comb (shen.in-> W3634) (n->string (shen.<-out W3633))))))))))) (if (shen.parse-failure? W3630) (shen.parse-failure) W3630)))

(defun shen.<notdbq> (V3635) (let W3636 (if (shen.non-empty-stream? V3635) (let W3637 (shen.hds V3635) (let W3638 (shen.tls V3635) (if (not (= W3637 34)) (shen.comb (shen.in-> W3638) (n->string W3637)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W3636) (shen.parse-failure) W3636)))

(defun shen.<lowC> (V3639) (let W3640 (if (shen.=hd? V3639 99) (let W3641 (shen.tls V3639) (shen.comb (shen.in-> W3641) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W3640) (shen.parse-failure) W3640)))

(defun shen.<hash> (V3642) (let W3643 (if (shen.=hd? V3642 35) (let W3644 (shen.tls V3642) (shen.comb (shen.in-> W3644) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W3643) (shen.parse-failure) W3643)))

(defun shen.<number> (V3645) (let W3646 (let W3647 (shen.<minus> V3645) (if (shen.parse-failure? W3647) (shen.parse-failure) (let W3648 (shen.<number> W3647) (if (shen.parse-failure? W3648) (shen.parse-failure) (shen.comb (shen.in-> W3648) (- 0 (shen.<-out W3648))))))) (if (shen.parse-failure? W3646) (let W3649 (let W3650 (shen.<plus> V3645) (if (shen.parse-failure? W3650) (shen.parse-failure) (let W3651 (shen.<number> W3650) (if (shen.parse-failure? W3651) (shen.parse-failure) (shen.comb (shen.in-> W3651) (shen.<-out W3651)))))) (if (shen.parse-failure? W3649) (let W3652 (let W3653 (shen.<e-number> V3645) (if (shen.parse-failure? W3653) (shen.parse-failure) (shen.comb (shen.in-> W3653) (shen.<-out W3653)))) (if (shen.parse-failure? W3652) (let W3654 (let W3655 (shen.<float> V3645) (if (shen.parse-failure? W3655) (shen.parse-failure) (shen.comb (shen.in-> W3655) (shen.<-out W3655)))) (if (shen.parse-failure? W3654) (let W3656 (let W3657 (shen.<integer> V3645) (if (shen.parse-failure? W3657) (shen.parse-failure) (shen.comb (shen.in-> W3657) (shen.<-out W3657)))) (if (shen.parse-failure? W3656) (shen.parse-failure) W3656)) W3654)) W3652)) W3649)) W3646)))

(defun shen.<minus> (V3658) (let W3659 (if (shen.=hd? V3658 45) (let W3660 (shen.tls V3658) (shen.comb (shen.in-> W3660) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W3659) (shen.parse-failure) W3659)))

(defun shen.<plus> (V3661) (let W3662 (if (shen.=hd? V3661 43) (let W3663 (shen.tls V3661) (shen.comb (shen.in-> W3663) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W3662) (shen.parse-failure) W3662)))

(defun shen.<integer> (V3664) (let W3665 (let W3666 (shen.<digits> V3664) (if (shen.parse-failure? W3666) (shen.parse-failure) (shen.comb (shen.in-> W3666) (shen.compute-integer (shen.<-out W3666))))) (if (shen.parse-failure? W3665) (shen.parse-failure) W3665)))

(defun shen.<digits> (V3667) (let W3668 (let W3669 (shen.<digit> V3667) (if (shen.parse-failure? W3669) (shen.parse-failure) (let W3670 (shen.<digits> W3669) (if (shen.parse-failure? W3670) (shen.parse-failure) (shen.comb (shen.in-> W3670) (cons (shen.<-out W3669) (shen.<-out W3670))))))) (if (shen.parse-failure? W3668) (let W3671 (let W3672 (shen.<digit> V3667) (if (shen.parse-failure? W3672) (shen.parse-failure) (shen.comb (shen.in-> W3672) (cons (shen.<-out W3672) ())))) (if (shen.parse-failure? W3671) (shen.parse-failure) W3671)) W3668)))

(defun shen.<digit> (V3673) (let W3674 (if (shen.non-empty-stream? V3673) (let W3675 (shen.hds V3673) (let W3676 (shen.tls V3673) (if (shen.digit? W3675) (shen.comb (shen.in-> W3676) (shen.byte->digit W3675)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W3674) (shen.parse-failure) W3674)))

(defun shen.byte->digit (V3677) (- V3677 48))

(defun shen.compute-integer (V3678) (shen.compute-integer-h (reverse V3678) 0))

(defun shen.compute-integer-h (V3681 V3682) (cond ((= () V3681) 0) ((cons? V3681) (+ (* (shen.expt 10 V3682) (hd V3681)) (shen.compute-integer-h (tl V3681) (+ V3682 1)))) (true (shen.f-error shen.compute-integer-h))))

(defun shen.expt (V3685 V3686) (cond ((= 0 V3686) 1) ((> V3686 0) (* V3685 (shen.expt V3685 (- V3686 1)))) (true (/ (shen.expt V3685 (+ V3686 1)) V3685))))

(defun shen.<float> (V3687) (let W3688 (let W3689 (shen.<integer> V3687) (if (shen.parse-failure? W3689) (shen.parse-failure) (let W3690 (shen.<stop> W3689) (if (shen.parse-failure? W3690) (shen.parse-failure) (let W3691 (shen.<fraction> W3690) (if (shen.parse-failure? W3691) (shen.parse-failure) (shen.comb (shen.in-> W3691) (+ (shen.<-out W3689) (shen.<-out W3691))))))))) (if (shen.parse-failure? W3688) (let W3692 (let W3693 (shen.<stop> V3687) (if (shen.parse-failure? W3693) (shen.parse-failure) (let W3694 (shen.<fraction> W3693) (if (shen.parse-failure? W3694) (shen.parse-failure) (shen.comb (shen.in-> W3694) (shen.<-out W3694)))))) (if (shen.parse-failure? W3692) (shen.parse-failure) W3692)) W3688)))

(defun shen.<stop> (V3695) (let W3696 (if (shen.=hd? V3695 46) (let W3697 (shen.tls V3695) (shen.comb (shen.in-> W3697) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W3696) (shen.parse-failure) W3696)))

(defun shen.<fraction> (V3698) (let W3699 (let W3700 (shen.<digits> V3698) (if (shen.parse-failure? W3700) (shen.parse-failure) (shen.comb (shen.in-> W3700) (shen.compute-fraction (shen.<-out W3700))))) (if (shen.parse-failure? W3699) (shen.parse-failure) W3699)))

(defun shen.compute-fraction (V3701) (shen.compute-fraction-h V3701 -1))

(defun shen.compute-fraction-h (V3704 V3705) (cond ((= () V3704) 0) ((cons? V3704) (+ (* (shen.expt 10 V3705) (hd V3704)) (shen.compute-fraction-h (tl V3704) (- V3705 1)))) (true (shen.f-error shen.compute-fraction-h))))

(defun shen.<e-number> (V3706) (let W3707 (let W3708 (shen.<float> V3706) (if (shen.parse-failure? W3708) (shen.parse-failure) (let W3709 (shen.<lowE> W3708) (if (shen.parse-failure? W3709) (shen.parse-failure) (let W3710 (shen.<log10> W3709) (if (shen.parse-failure? W3710) (shen.parse-failure) (shen.comb (shen.in-> W3710) (shen.compute-E (shen.<-out W3708) (shen.<-out W3710))))))))) (if (shen.parse-failure? W3707) (let W3711 (let W3712 (shen.<integer> V3706) (if (shen.parse-failure? W3712) (shen.parse-failure) (let W3713 (shen.<lowE> W3712) (if (shen.parse-failure? W3713) (shen.parse-failure) (let W3714 (shen.<log10> W3713) (if (shen.parse-failure? W3714) (shen.parse-failure) (shen.comb (shen.in-> W3714) (shen.compute-E (shen.<-out W3712) (shen.<-out W3714))))))))) (if (shen.parse-failure? W3711) (shen.parse-failure) W3711)) W3707)))

(defun shen.<log10> (V3715) (let W3716 (let W3717 (shen.<plus> V3715) (if (shen.parse-failure? W3717) (shen.parse-failure) (let W3718 (shen.<log10> W3717) (if (shen.parse-failure? W3718) (shen.parse-failure) (shen.comb (shen.in-> W3718) (shen.<-out W3718)))))) (if (shen.parse-failure? W3716) (let W3719 (let W3720 (shen.<minus> V3715) (if (shen.parse-failure? W3720) (shen.parse-failure) (let W3721 (shen.<log10> W3720) (if (shen.parse-failure? W3721) (shen.parse-failure) (shen.comb (shen.in-> W3721) (- 0 (shen.<-out W3721))))))) (if (shen.parse-failure? W3719) (let W3722 (let W3723 (shen.<integer> V3715) (if (shen.parse-failure? W3723) (shen.parse-failure) (shen.comb (shen.in-> W3723) (shen.<-out W3723)))) (if (shen.parse-failure? W3722) (shen.parse-failure) W3722)) W3719)) W3716)))

(defun shen.<lowE> (V3724) (let W3725 (if (shen.=hd? V3724 101) (let W3726 (shen.tls V3724) (shen.comb (shen.in-> W3726) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W3725) (shen.parse-failure) W3725)))

(defun shen.compute-E (V3727 V3728) (* V3727 (shen.expt 10 V3728)))

(defun shen.<whitespaces> (V3729) (let W3730 (let W3731 (shen.<whitespace> V3729) (if (shen.parse-failure? W3731) (shen.parse-failure) (let W3732 (shen.<whitespaces> W3731) (if (shen.parse-failure? W3732) (shen.parse-failure) (shen.comb (shen.in-> W3732) shen.skip))))) (if (shen.parse-failure? W3730) (let W3733 (let W3734 (shen.<whitespace> V3729) (if (shen.parse-failure? W3734) (shen.parse-failure) (shen.comb (shen.in-> W3734) shen.skip))) (if (shen.parse-failure? W3733) (shen.parse-failure) W3733)) W3730)))

(defun shen.<whitespace> (V3735) (let W3736 (if (shen.non-empty-stream? V3735) (let W3737 (shen.hds V3735) (let W3738 (shen.tls V3735) (if (shen.whitespace? W3737) (shen.comb (shen.in-> W3738) shen.skip) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W3736) (shen.parse-failure) W3736)))

(defun shen.whitespace? (V3741) (cond ((= 32 V3741) true) ((= 13 V3741) true) ((= 10 V3741) true) ((= 9 V3741) true) (true false)))

(defun shen.unpackage&macroexpand (V3742) (cond ((= () V3742) ()) ((and (cons? V3742) (shen.packaged? (hd V3742))) (shen.unpackage&macroexpand (append (shen.unpackage (hd V3742)) (tl V3742)))) ((cons? V3742) (let W3743 (macroexpand (hd V3742)) (if (shen.packaged? W3743) (shen.unpackage&macroexpand (cons W3743 (tl V3742))) (cons W3743 (shen.unpackage&macroexpand (tl V3742)))))) (true (shen.f-error shen.unpackage&macroexpand))))

(defun shen.packaged? (V3746) (cond ((and (cons? V3746) (and (= package (hd V3746)) (and (cons? (tl V3746)) (cons? (tl (tl V3746)))))) true) (true false)))

(defun shen.unpackage (V3749) (cond ((and (cons? V3749) (and (= package (hd V3749)) (and (cons? (tl V3749)) (and (= null (hd (tl V3749))) (cons? (tl (tl V3749))))))) (tl (tl (tl V3749)))) ((and (cons? V3749) (and (= package (hd V3749)) (and (cons? (tl V3749)) (cons? (tl (tl V3749)))))) (let W3750 (eval (hd (tl (tl V3749)))) (let W3751 (shen.package-symbols (str (hd (tl V3749))) W3750 (tl (tl (tl V3749)))) (let W3752 (shen.record-external (hd (tl V3749)) W3750) (let W3753 (shen.record-internal (hd (tl V3749)) W3750 (tl (tl (tl V3749)))) W3751))))) (true (shen.f-error shen.unpackage))))

(defun shen.record-internal (V3754 V3755 V3756) (put V3754 shen.internal-symbols (shen.internal-symbols (str V3754) V3755 V3756) (value *property-vector*)))

(defun shen.internal-symbols (V3763 V3764 V3765) (cond ((cons? V3765) (union (shen.internal-symbols V3763 V3764 (hd V3765)) (shen.internal-symbols V3763 V3764 (tl V3765)))) ((shen.internal? V3765 V3763 V3764) (cons (shen.intern-in-package V3763 V3765) ())) (true ())))

(defun shen.record-external (V3766 V3767) (let W3768 (trap-error (get V3766 shen.external-symbols (value *property-vector*)) (lambda Z3769 ())) (put V3766 shen.external-symbols (union V3767 W3768) (value *property-vector*))))

(defun shen.package-symbols (V3774 V3775 V3776) (cond ((cons? V3776) (map (lambda Z3777 (shen.package-symbols V3774 V3775 Z3777)) V3776)) ((shen.internal? V3776 V3774 V3775) (shen.intern-in-package V3774 V3776)) (true V3776)))

(defun shen.intern-in-package (V3778 V3779) (intern (@s V3778 (@s "." (str V3779)))))

(defun shen.internal? (V3780 V3781 V3782) (and (not (element? V3780 V3782)) (and (not (shen.sng? V3780)) (and (not (shen.dbl? V3780)) (and (symbol? V3780) (and (not (shen.sysfunc? V3780)) (and (not (variable? V3780)) (and (not (shen.internal-to-shen? (str V3780))) (not (shen.internal-to-P? V3781 (str V3780)))))))))))

(defun shen.internal-to-shen? (V3787) (cond ((and (shen.+string? V3787) (and (= "s" (hdstr V3787)) (and (shen.+string? (tlstr V3787)) (and (= "h" (hdstr (tlstr V3787))) (and (shen.+string? (tlstr (tlstr V3787))) (and (= "e" (hdstr (tlstr (tlstr V3787)))) (and (shen.+string? (tlstr (tlstr (tlstr V3787)))) (and (= "n" (hdstr (tlstr (tlstr (tlstr V3787))))) (and (shen.+string? (tlstr (tlstr (tlstr (tlstr V3787))))) (= "." (hdstr (tlstr (tlstr (tlstr (tlstr V3787))))))))))))))) true) (true false)))

(defun shen.sysfunc? (V3788) (element? V3788 (get shen shen.external-symbols (value *property-vector*))))

(defun shen.internal-to-P? (V3796 V3797) (cond ((and (= "" V3796) (and (shen.+string? V3797) (= "." (hdstr V3797)))) true) ((and (shen.+string? V3796) (and (shen.+string? V3797) (= (hdstr V3796) (hdstr V3797)))) (shen.internal-to-P? (tlstr V3796) (tlstr V3797))) (true false)))

(defun shen.process-applications (V3800 V3801) (cond ((element? V3800 V3801) V3800) ((and (cons? V3800) (shen.non-application? (hd V3800))) (shen.special-case (hd V3800) V3800 V3801)) ((cons? V3800) (shen.process-application (map (lambda Z3802 (shen.process-applications Z3802 V3801)) V3800) V3801)) (true V3800)))

(defun shen.non-application? (V3805) (cond ((= define V3805) true) ((= defun V3805) true) ((= synonyms V3805) true) ((shen.special? V3805) true) ((shen.extraspecial? V3805) true) (true false)))

(defun shen.special-case (V3810 V3811 V3812) (cond ((and (= lambda V3810) (and (cons? V3811) (and (= lambda (hd V3811)) (and (cons? (tl V3811)) (and (cons? (tl (tl V3811))) (= () (tl (tl (tl V3811))))))))) (cons lambda (cons (hd (tl V3811)) (cons (shen.process-applications (hd (tl (tl V3811))) V3812) ())))) ((and (= let V3810) (and (cons? V3811) (and (= let (hd V3811)) (and (cons? (tl V3811)) (and (cons? (tl (tl V3811))) (and (cons? (tl (tl (tl V3811)))) (= () (tl (tl (tl (tl V3811))))))))))) (cons let (cons (hd (tl V3811)) (cons (shen.process-applications (hd (tl (tl V3811))) V3812) (cons (shen.process-applications (hd (tl (tl (tl V3811)))) V3812) ()))))) ((and (= defun V3810) (and (cons? V3811) (and (= defun (hd V3811)) (and (cons? (tl V3811)) (and (cons? (tl (tl V3811))) (and (cons? (tl (tl (tl V3811)))) (= () (tl (tl (tl (tl V3811))))))))))) V3811) ((and (= define V3810) (and (cons? V3811) (and (= define (hd V3811)) (and (cons? (tl V3811)) (and (cons? (tl (tl V3811))) (= { (hd (tl (tl V3811))))))))) (cons define (cons (hd (tl V3811)) (cons { (shen.process-after-type (hd (tl V3811)) (tl (tl (tl V3811))) V3812))))) ((and (= define V3810) (and (cons? V3811) (and (= define (hd V3811)) (cons? (tl V3811))))) (cons define (cons (hd (tl V3811)) (map (lambda Z3813 (shen.process-applications Z3813 V3812)) (tl (tl V3811)))))) ((= synonyms V3810) (cons synonyms V3811)) ((and (= type V3810) (and (cons? V3811) (and (= type (hd V3811)) (and (cons? (tl V3811)) (and (cons? (tl (tl V3811))) (= () (tl (tl (tl V3811))))))))) (cons type (cons (shen.process-applications (hd (tl V3811)) V3812) (tl (tl V3811))))) ((and (= input+ V3810) (and (cons? V3811) (and (= input+ (hd V3811)) (and (cons? (tl V3811)) (and (cons? (tl (tl V3811))) (= () (tl (tl (tl V3811))))))))) (cons input+ (cons (hd (tl V3811)) (cons (shen.process-applications (hd (tl (tl V3811))) V3812) ())))) ((and (cons? V3811) (shen.special? (hd V3811))) (cons (hd V3811) (map (lambda Z3814 (shen.process-applications Z3814 V3812)) (tl V3811)))) ((and (cons? V3811) (shen.extraspecial? (hd V3811))) V3811) (true (shen.f-error shen.special-case))))

(defun shen.process-after-type (V3817 V3818 V3819) (cond ((and (cons? V3818) (= } (hd V3818))) (cons } (map (lambda Z3820 (shen.process-applications Z3820 V3819)) (tl V3818)))) ((cons? V3818) (cons (hd V3818) (shen.process-after-type V3817 (tl V3818) V3819))) (true (simple-error (cn "missing } in " (shen.app V3817 "
" shen.a))))))

(defun shen.process-application (V3821 V3822) (cond ((cons? V3821) (let W3823 (arity (hd V3821)) (let W3824 (length (tl V3821)) (if (element? V3821 V3822) V3821 (if (shen.shen-call? (hd V3821)) V3821 (if (shen.foreign? V3821) (shen.unpack-foreign V3821) (if (shen.fn-call? V3821) (shen.fn-call V3821) (if (shen.zero-place? V3821) V3821 (if (shen.undefined-f? (hd V3821) W3823) (shen.simple-curry (cons (cons fn (cons (hd V3821) ())) (tl V3821))) (if (variable? (hd V3821)) (shen.simple-curry V3821) (if (shen.application? (hd V3821)) (shen.simple-curry V3821) (if (shen.partial-application*? (hd V3821) W3823 W3824) (shen.lambda-function V3821 (- W3823 W3824)) (if (shen.overapplication? (hd V3821) W3823 W3824) (shen.simple-curry (cons (cons fn (cons (hd V3821) ())) (tl V3821))) V3821))))))))))))) (true (shen.f-error shen.process-application))))

(defun shen.unpack-foreign (V3825) (cond ((and (cons? V3825) (and (cons? (hd V3825)) (and (= foreign (hd (hd V3825))) (and (cons? (tl (hd V3825))) (= () (tl (tl (hd V3825)))))))) (cons (hd (tl (hd V3825))) (tl V3825))) (true (shen.f-error shen.unpack-foreign))))

(defun shen.foreign? (V3828) (cond ((and (cons? V3828) (and (cons? (hd V3828)) (and (= foreign (hd (hd V3828))) (and (cons? (tl (hd V3828))) (= () (tl (tl (hd V3828)))))))) true) (true false)))

(defun shen.zero-place? (V3831) (cond ((and (cons? V3831) (= () (tl V3831))) true) (true false)))

(defun shen.shen-call? (V3832) (and (symbol? V3832) (shen.internal-to-shen? (str V3832))))

(defun shen.internal-to-shen? (V3837) (cond ((and (shen.+string? V3837) (and (= "s" (hdstr V3837)) (and (shen.+string? (tlstr V3837)) (and (= "h" (hdstr (tlstr V3837))) (and (shen.+string? (tlstr (tlstr V3837))) (and (= "e" (hdstr (tlstr (tlstr V3837)))) (and (shen.+string? (tlstr (tlstr (tlstr V3837)))) (and (= "n" (hdstr (tlstr (tlstr (tlstr V3837))))) (and (shen.+string? (tlstr (tlstr (tlstr (tlstr V3837))))) (= "." (hdstr (tlstr (tlstr (tlstr (tlstr V3837))))))))))))))) true) (true false)))

(defun shen.application? (V3842) (cond ((and (cons? V3842) (and (= protect (hd V3842)) (and (cons? (tl V3842)) (= () (tl (tl V3842)))))) false) ((and (cons? V3842) (and (= foreign (hd V3842)) (and (cons? (tl V3842)) (= () (tl (tl V3842)))))) false) (true (cons? V3842))))

(defun shen.undefined-f? (V3847 V3848) (cond ((= -1 V3848) (and (shen.lowercase-symbol? V3847) (not (element? V3847 (external shen))))) (true false)))

(defun shen.lowercase-symbol? (V3849) (and (symbol? V3849) (not (variable? V3849))))

(defun shen.simple-curry (V3850) (cond ((and (cons? V3850) (and (cons? (tl V3850)) (= () (tl (tl V3850))))) V3850) ((and (cons? V3850) (and (cons? (tl V3850)) (cons? (tl (tl V3850))))) (shen.simple-curry (cons (cons (hd V3850) (cons (hd (tl V3850)) ())) (tl (tl V3850))))) (true V3850)))

(defun function (V3851) (fn V3851))

(defun fn (V3852) (let W3853 (assoc V3852 (value shen.*lambdatable*)) (if (empty? W3853) (simple-error (cn "fn: " (shen.app V3852 " is undefined
" shen.a))) (tl W3853))))

(defun shen.fn-call? (V3856) (cond ((and (cons? V3856) (and (= fn (hd V3856)) (and (cons? (tl V3856)) (= () (tl (tl V3856)))))) true) ((and (cons? V3856) (and (= function (hd V3856)) (and (cons? (tl V3856)) (= () (tl (tl V3856)))))) true) (true false)))

(defun shen.fn-call (V3857) (cond ((and (cons? V3857) (and (= function (hd V3857)) (and (cons? (tl V3857)) (= () (tl (tl V3857)))))) (shen.fn-call (cons fn (tl V3857)))) ((and (cons? V3857) (and (= fn (hd V3857)) (and (cons? (tl V3857)) (= () (tl (tl V3857)))))) (let W3858 (arity (hd (tl V3857))) (if (= W3858 -1) V3857 (if (= W3858 0) (simple-error "fn cannot be applied to a zero place function
") (shen.lambda-function (tl V3857) W3858))))) (true (shen.f-error shen.fn-call))))

(defun shen.partial-application*? (V3859 V3860 V3861) (let W3862 (> V3860 V3861) (let W3863 (if (and W3862 (and (shen.loading?) (not (element? V3859 (cons + (cons - ())))))) (pr (cn "partial application of " (shen.app V3859 "
" shen.a)) (stoutput)) shen.skip) W3862)))

(defun shen.loading? () (value shen.*loading?*))

(defun shen.overapplication? (V3868 V3869 V3870) (cond ((= -1 V3869) false) (true (let W3871 (< V3869 V3870) (let W3872 (if (and W3871 (shen.loading?)) (pr (shen.app V3868 (cn " might not like " (shen.app V3870 (cn " argument" (shen.app (if (= V3870 1) "" "s") "
" shen.a)) shen.a)) shen.a) (stoutput)) shen.skip) W3871)))))

