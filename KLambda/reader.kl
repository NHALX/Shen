(defun read-file (V7841) (let Bytelist (read-file-as-bytelist V7841) (let S-exprs (trap-error (compile (lambda X (shen.<s-exprs> X)) Bytelist) (lambda E (shen.print-residue (value shen.*residue*)))) (let Process (shen.process-sexprs S-exprs) Process))))

(defun shen.print-residue (V7842) (let Err (pr "syntax error here:
" (stoutput)) (shen.nchars 50 V7842)))

(defun shen.nchars (V7847 V7848) (cond ((= 0 V7847) (do (pr " ..." (stoutput)) (abort))) ((= () V7848) (do (pr " ..." (stoutput)) (abort))) ((cons? V7848) (do (pr (n->string (hd V7848)) (stoutput)) (shen.nchars (- V7847 1) (tl V7848)))) (true (shen.f-error shen.nchars))))

(defun it () (value shen.*it*))

(defun read-file-as-bytelist (V7849) (let Stream (open V7849 in) (let Byte (read-byte Stream) (let Bytes (shen.read-file-as-bytelist-help Stream Byte ()) (let Close (close Stream) (reverse Bytes))))))

(defun shen.read-file-as-bytelist-help (V7850 V7851 V7852) (cond ((= -1 V7851) V7852) (true (shen.read-file-as-bytelist-help V7850 (read-byte V7850) (cons V7851 V7852)))))

(defun read-file-as-string (V7853) (let Stream (open V7853 in) (shen.rfas-h Stream (read-byte Stream) "")))

(defun shen.rfas-h (V7854 V7855 V7856) (cond ((= -1 V7855) (do (close V7854) V7856)) (true (shen.rfas-h V7854 (read-byte V7854) (cn V7856 (n->string V7855))))))

(defun input (V7857) (eval-kl (read V7857)))

(defun input+ (V7858 V7859) (let Mono? (shen.monotype V7858) (let Input (read V7859) (if (= false (shen.typecheck Input (shen.rectify-type V7858))) (simple-error (cn "type error: " (shen.app Input (cn " is not of type " (shen.app V7858 "
" shen.r)) shen.r))) (eval-kl Input)))))

(defun shen.monotype (V7860) (cond ((cons? V7860) (map (lambda Z (shen.monotype Z)) V7860)) (true (if (variable? V7860) (simple-error (cn "input+ expects a monotype: not " (shen.app V7860 "
" shen.a))) V7860))))

(defun lineread (V7861) (shen.read-loop V7861 (shen.my-read-byte V7861) () (lambda X (shen.return? X))))

(defun read-from-string (V7862) (let Bytelist (shen.str->bytes V7862) (let S-exprs (compile (lambda X (shen.<s-exprs> X)) Bytelist) (let Process (shen.process-sexprs S-exprs) Process))))

(defun read-from-string-unprocessed (V7863) (let Bytelist (shen.str->bytes V7863) (let S-exprs (compile (lambda X (shen.<s-exprs> X)) Bytelist) S-exprs)))

(defun shen.str->bytes (V7864) (cond ((= "" V7864) ()) ((shen.+string? V7864) (cons (string->n (hdstr V7864)) (shen.str->bytes (tlstr V7864)))) (true (shen.f-error shen.str->bytes))))

(defun read (V7865) (hd (shen.read-loop V7865 (shen.my-read-byte V7865) () (lambda X (shen.whitespace? X)))))

(defun shen.my-read-byte (V7866) (if (shen.char-stinput? V7866) (string->n (shen.read-unit-string V7866)) (read-byte V7866)))

(defun shen.read-loop (V7871 V7872 V7873 V7874) (cond ((= 94 V7872) (simple-error "read aborted")) ((= -1 V7872) (if (empty? V7873) (simple-error "error: empty stream") (compile (lambda X (shen.<s-exprs> X)) V7873))) ((= 0 V7872) (shen.read-loop V7871 (shen.my-read-byte V7871) V7873 V7874)) (true (if (V7874 V7872) (let Parse (shen.try-parse V7873) (if (shen.nothing-doing? Parse) (shen.read-loop V7871 (shen.my-read-byte V7871) (append V7873 (cons V7872 ())) V7874) (do (shen.record-it V7873) Parse))) (shen.read-loop V7871 (shen.my-read-byte V7871) (append V7873 (cons V7872 ())) V7874)))))

(defun shen.try-parse (V7875) (let S-exprs (trap-error (compile (lambda X (shen.<s-exprs> X)) V7875) (lambda E shen.i-failed!)) (if (shen.nothing-doing? S-exprs) shen.i-failed! (shen.process-sexprs S-exprs))))

(defun shen.nothing-doing? (V7878) (cond ((= shen.i-failed! V7878) true) ((= () V7878) true) (true false)))

(defun shen.record-it (V7879) (set shen.*it* (shen.bytes->string V7879)))

(defun shen.bytes->string (V7880) (cond ((= () V7880) "") ((cons? V7880) (cn (n->string (hd V7880)) (shen.bytes->string (tl V7880)))) (true (shen.f-error shen.bytes->string))))

(defun shen.process-sexprs (V7881) (let Unpack&Expand (shen.unpackage&macroexpand V7881) (let FindArities (shen.find-arities Unpack&Expand) (let Types (shen.find-types Unpack&Expand) (map (lambda X (shen.process-applications X Types)) Unpack&Expand)))))

(defun shen.find-types (V7882) (cond ((and (cons? V7882) (and (cons? (tl V7882)) (= (hd V7882) (intern ":")))) (cons (hd (tl V7882)) (shen.find-types (tl (tl V7882))))) ((cons? V7882) (append (shen.find-types (hd V7882)) (shen.find-types (tl V7882)))) (true ())))

(defun shen.find-arities (V7885) (cond ((and (cons? V7885) (and (= define (hd V7885)) (and (cons? (tl V7885)) (and (cons? (tl (tl V7885))) (= { (hd (tl (tl V7885)))))))) (shen.store-arity (hd (tl V7885)) (shen.find-arity (hd (tl V7885)) 1 (tl (tl (tl V7885)))))) ((and (cons? V7885) (and (= define (hd V7885)) (cons? (tl V7885)))) (shen.store-arity (hd (tl V7885)) (shen.find-arity (hd (tl V7885)) 0 (tl (tl V7885))))) ((cons? V7885) (map (lambda Z (shen.find-arities Z)) V7885)) (true shen.skip)))

(defun shen.store-arity (V7886 V7887) (let ArityF (arity V7886) (if (= ArityF -1) (shen.execute-store-arity V7886 V7887) (if (= ArityF V7887) shen.skip (if (shen.sysfunc? V7886) (simple-error (shen.app V7886 " is a system function
" shen.a)) (do (pr (cn "changing the arity of " (shen.app V7886 " may cause errors
" shen.a)) (stoutput)) (shen.execute-store-arity V7886 V7887)))))))

(defun shen.execute-store-arity (V7888 V7889) (cond ((= 0 V7889) (put V7888 arity 0 (value *property-vector*))) (true (do (put V7888 arity V7889 (value *property-vector*)) (shen.update-lambdatable V7888 V7889)))))

(defun shen.update-lambdatable (V7890 V7891) (let LambdaTable (value shen.*lambdatable*) (let Lambda (eval-kl (shen.lambda-function (cons V7890 ()) V7891)) (let Insert (shen.assoc-> V7890 Lambda LambdaTable) (let Reset (set shen.*lambdatable* Insert) Reset)))))

(defun shen.lambda-function (V7894 V7895) (cond ((= 0 V7895) shen.skip) ((= 1 V7895) (let X (gensym Y) (cons lambda (cons X (cons (append V7894 (cons X ())) ()))))) (true (let X (gensym Y) (cons lambda (cons X (cons (shen.lambda-function (append V7894 (cons X ())) (- V7895 1)) ())))))))

(defun shen.assoc-> (V7905 V7906 V7907) (cond ((= () V7907) (cons (cons V7905 V7906) ())) ((and (cons? V7907) (and (cons? (hd V7907)) (= V7905 (hd (hd V7907))))) (cons (cons (hd (hd V7907)) V7906) (tl V7907))) ((cons? V7907) (cons (hd V7907) (shen.assoc-> V7905 V7906 (tl V7907)))) (true (simple-error "implementation error in shen.assoc->"))))

(defun shen.find-arity (V7922 V7923 V7924) (cond ((and (= 0 V7923) (and (cons? V7924) (= (hd V7924) ->))) 0) ((and (= 0 V7923) (and (cons? V7924) (= (hd V7924) <-))) 0) ((and (= 0 V7923) (cons? V7924)) (+ 1 (shen.find-arity V7922 0 (tl V7924)))) ((and (= 1 V7923) (and (cons? V7924) (= } (hd V7924)))) (shen.find-arity V7922 0 (tl V7924))) ((and (= 1 V7923) (cons? V7924)) (shen.find-arity V7922 1 (tl V7924))) ((= 1 V7923) (simple-error (cn "syntax error in " (shen.app V7922 " definition: missing }
" shen.a)))) (true (simple-error (cn "syntax error in " (shen.app V7922 " definition: missing -> or <-
" shen.a))))))

(defun shen.<s-exprs> (V7925) (let Result (let Parseshen.<lsb> (shen.<lsb> V7925) (if (shen.parse-failure? Parseshen.<lsb>) (shen.parse-failure) (let Parseshen.<s-exprs1> (shen.<s-exprs1> Parseshen.<lsb>) (if (shen.parse-failure? Parseshen.<s-exprs1>) (shen.parse-failure) (let Parseshen.<rsb> (shen.<rsb> Parseshen.<s-exprs1>) (if (shen.parse-failure? Parseshen.<rsb>) (shen.parse-failure) (let Parseshen.<s-exprs2> (shen.<s-exprs2> Parseshen.<rsb>) (if (shen.parse-failure? Parseshen.<s-exprs2>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs2>) (cons (shen.cons-form (shen.<-out Parseshen.<s-exprs1>)) (shen.<-out Parseshen.<s-exprs2>))))))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<lrb> (shen.<lrb> V7925) (if (shen.parse-failure? Parseshen.<lrb>) (shen.parse-failure) (let Parseshen.<s-exprs1> (shen.<s-exprs1> Parseshen.<lrb>) (if (shen.parse-failure? Parseshen.<s-exprs1>) (shen.parse-failure) (let Parseshen.<rrb> (shen.<rrb> Parseshen.<s-exprs1>) (if (shen.parse-failure? Parseshen.<rrb>) (shen.parse-failure) (let Parseshen.<s-exprs2> (shen.<s-exprs2> Parseshen.<rrb>) (if (shen.parse-failure? Parseshen.<s-exprs2>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs2>) (shen.add-sexpr (shen.<-out Parseshen.<s-exprs1>) (shen.<-out Parseshen.<s-exprs2>))))))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<lcurly> (shen.<lcurly> V7925) (if (shen.parse-failure? Parseshen.<lcurly>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<lcurly>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons { (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<rcurly> (shen.<rcurly> V7925) (if (shen.parse-failure? Parseshen.<rcurly>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<rcurly>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons } (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<bar> (shen.<bar> V7925) (if (shen.parse-failure? Parseshen.<bar>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<bar>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons bar! (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<semicolon> (shen.<semicolon> V7925) (if (shen.parse-failure? Parseshen.<semicolon>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<semicolon>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons (intern ";") (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<colon> (shen.<colon> V7925) (if (shen.parse-failure? Parseshen.<colon>) (shen.parse-failure) (let Parseshen.<equal> (shen.<equal> Parseshen.<colon>) (if (shen.parse-failure? Parseshen.<equal>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<equal>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons (intern ":=") (shen.<-out Parseshen.<s-exprs>))))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<colon> (shen.<colon> V7925) (if (shen.parse-failure? Parseshen.<colon>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<colon>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons (intern ":") (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<comma> (shen.<comma> V7925) (if (shen.parse-failure? Parseshen.<comma>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<comma>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons (intern ",") (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<comment> (shen.<comment> V7925) (if (shen.parse-failure? Parseshen.<comment>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<comment>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (shen.<-out Parseshen.<s-exprs>)))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<atom> (shen.<atom> V7925) (if (shen.parse-failure? Parseshen.<atom>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<atom>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons (shen.<-out Parseshen.<atom>) (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<whitespaces> (shen.<whitespaces> V7925) (if (shen.parse-failure? Parseshen.<whitespaces>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<whitespaces>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (shen.<-out Parseshen.<s-exprs>)))))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V7925) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ()))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)))

(defun shen.add-sexpr (V7926 V7927) (cond ((and (cons? V7926) (and (= $ (hd V7926)) (and (cons? (tl V7926)) (= () (tl (tl V7926)))))) (append (explode (hd (tl V7926))) V7927)) (true (cons V7926 V7927))))

(defun shen.<lsb> (V7928) (let Result (if (shen.=hd? V7928 91) (let News7610 (shen.tls V7928) (shen.comb (shen.in-> News7610) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<rsb> (V7929) (let Result (if (shen.=hd? V7929 93) (let News7612 (shen.tls V7929) (shen.comb (shen.in-> News7612) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<s-exprs1> (V7930) (let Result (let Parseshen.<s-exprs> (shen.<s-exprs> V7930) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (shen.<-out Parseshen.<s-exprs>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<s-exprs2> (V7931) (let Result (let Parseshen.<s-exprs> (shen.<s-exprs> V7931) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (shen.<-out Parseshen.<s-exprs>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.cons-form (V7933) (cond ((= () V7933) ()) ((and (cons? V7933) (and (cons? (tl V7933)) (and (cons? (tl (tl V7933))) (and (= () (tl (tl (tl V7933)))) (= (hd (tl V7933)) bar!))))) (cons cons (cons (hd V7933) (tl (tl V7933))))) ((and (cons? V7933) (and (cons? (tl V7933)) (and (cons? (tl (tl V7933))) (and (cons? (tl (tl (tl V7933)))) (= (hd (tl V7933)) bar!))))) (simple-error "misapplication of |
")) ((cons? V7933) (cons cons (cons (hd V7933) (cons (shen.cons-form (tl V7933)) ())))) (true (shen.f-error shen.cons-form))))

(defun shen.<lrb> (V7934) (let Result (if (shen.=hd? V7934 40) (let News7616 (shen.tls V7934) (shen.comb (shen.in-> News7616) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<rrb> (V7935) (let Result (if (shen.=hd? V7935 41) (let News7618 (shen.tls V7935) (shen.comb (shen.in-> News7618) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<lcurly> (V7936) (let Result (if (shen.=hd? V7936 123) (let News7620 (shen.tls V7936) (shen.comb (shen.in-> News7620) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<rcurly> (V7937) (let Result (if (shen.=hd? V7937 125) (let News7622 (shen.tls V7937) (shen.comb (shen.in-> News7622) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<bar> (V7938) (let Result (if (shen.=hd? V7938 124) (let News7624 (shen.tls V7938) (shen.comb (shen.in-> News7624) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<semicolon> (V7939) (let Result (if (shen.=hd? V7939 59) (let News7626 (shen.tls V7939) (shen.comb (shen.in-> News7626) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<colon> (V7940) (let Result (if (shen.=hd? V7940 58) (let News7628 (shen.tls V7940) (shen.comb (shen.in-> News7628) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<comma> (V7941) (let Result (if (shen.=hd? V7941 44) (let News7630 (shen.tls V7941) (shen.comb (shen.in-> News7630) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<equal> (V7942) (let Result (if (shen.=hd? V7942 61) (let News7632 (shen.tls V7942) (shen.comb (shen.in-> News7632) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<comment> (V7943) (let Result (let Parseshen.<singleline> (shen.<singleline> V7943) (if (shen.parse-failure? Parseshen.<singleline>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<singleline>) shen.skip))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<multiline> (shen.<multiline> V7943) (if (shen.parse-failure? Parseshen.<multiline>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<multiline>) shen.skip))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<singleline> (V7944) (let Result (let Parseshen.<backslash> (shen.<backslash> V7944) (if (shen.parse-failure? Parseshen.<backslash>) (shen.parse-failure) (let Parseshen.<backslash> (shen.<backslash> Parseshen.<backslash>) (if (shen.parse-failure? Parseshen.<backslash>) (shen.parse-failure) (let Parseshen.<shortnatters> (shen.<shortnatters> Parseshen.<backslash>) (if (shen.parse-failure? Parseshen.<shortnatters>) (shen.parse-failure) (let Parseshen.<returns> (shen.<returns> Parseshen.<shortnatters>) (if (shen.parse-failure? Parseshen.<returns>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<returns>) shen.skip))))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<backslash> (V7945) (let Result (if (shen.=hd? V7945 92) (let News7636 (shen.tls V7945) (shen.comb (shen.in-> News7636) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<shortnatters> (V7946) (let Result (let Parseshen.<shortnatter> (shen.<shortnatter> V7946) (if (shen.parse-failure? Parseshen.<shortnatter>) (shen.parse-failure) (let Parseshen.<shortnatters> (shen.<shortnatters> Parseshen.<shortnatter>) (if (shen.parse-failure? Parseshen.<shortnatters>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<shortnatters>) shen.skip))))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V7946) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) shen.skip))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<shortnatter> (V7947) (let Result (if (shen.non-empty-stream? V7947) (let Byte (shen.hds V7947) (let News7639 (shen.tls V7947) (if (not (shen.return? Byte)) (shen.comb (shen.in-> News7639) shen.skip) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<returns> (V7948) (let Result (let Parseshen.<return> (shen.<return> V7948) (if (shen.parse-failure? Parseshen.<return>) (shen.parse-failure) (let Parseshen.<returns> (shen.<returns> Parseshen.<return>) (if (shen.parse-failure? Parseshen.<returns>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<returns>) shen.skip))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<return> (shen.<return> V7948) (if (shen.parse-failure? Parseshen.<return>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<return>) shen.skip))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<return> (V7949) (let Result (if (shen.non-empty-stream? V7949) (let Byte (shen.hds V7949) (let News7642 (shen.tls V7949) (if (shen.return? Byte) (shen.comb (shen.in-> News7642) shen.skip) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.return? (V7950) (element? V7950 (cons 9 (cons 10 (cons 13 ())))))

(defun shen.<multiline> (V7951) (let Result (let Parseshen.<backslash> (shen.<backslash> V7951) (if (shen.parse-failure? Parseshen.<backslash>) (shen.parse-failure) (let Parseshen.<times> (shen.<times> Parseshen.<backslash>) (if (shen.parse-failure? Parseshen.<times>) (shen.parse-failure) (let Parseshen.<longnatter> (shen.<longnatter> Parseshen.<times>) (if (shen.parse-failure? Parseshen.<longnatter>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<longnatter>) shen.skip))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<times> (V7952) (let Result (if (shen.=hd? V7952 42) (let News7645 (shen.tls V7952) (shen.comb (shen.in-> News7645) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<longnatter> (V7953) (let Result (let Parseshen.<comment> (shen.<comment> V7953) (if (shen.parse-failure? Parseshen.<comment>) (shen.parse-failure) (let Parseshen.<longnatter> (shen.<longnatter> Parseshen.<comment>) (if (shen.parse-failure? Parseshen.<longnatter>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<longnatter>) shen.skip))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<times> (shen.<times> V7953) (if (shen.parse-failure? Parseshen.<times>) (shen.parse-failure) (let Parseshen.<backslash> (shen.<backslash> Parseshen.<times>) (if (shen.parse-failure? Parseshen.<backslash>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<backslash>) shen.skip))))) (if (shen.parse-failure? Result) (let Result (if (shen.non-empty-stream? V7953) (let News7647 (shen.tls V7953) (let Parseshen.<longnatter> (shen.<longnatter> News7647) (if (shen.parse-failure? Parseshen.<longnatter>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<longnatter>) shen.skip)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)))

(defun shen.<atom> (V7954) (let Result (let Parseshen.<str> (shen.<str> V7954) (if (shen.parse-failure? Parseshen.<str>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<str>) (shen.<-out Parseshen.<str>)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<number> (shen.<number> V7954) (if (shen.parse-failure? Parseshen.<number>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<number>) (shen.<-out Parseshen.<number>)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<sym> (shen.<sym> V7954) (if (shen.parse-failure? Parseshen.<sym>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<sym>) (if (= (shen.<-out Parseshen.<sym>) "<>") (cons vector (cons 0 ())) (intern (shen.<-out Parseshen.<sym>)))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)))

(defun shen.<sym> (V7955) (let Result (let Parseshen.<alpha> (shen.<alpha> V7955) (if (shen.parse-failure? Parseshen.<alpha>) (shen.parse-failure) (let Parseshen.<alphanums> (shen.<alphanums> Parseshen.<alpha>) (if (shen.parse-failure? Parseshen.<alphanums>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<alphanums>) (cn (shen.<-out Parseshen.<alpha>) (shen.<-out Parseshen.<alphanums>))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<alpha> (V7956) (let Result (if (shen.non-empty-stream? V7956) (let Byte (shen.hds V7956) (let News7651 (shen.tls V7956) (if (shen.alpha? Byte) (shen.comb (shen.in-> News7651) (n->string Byte)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.alpha? (V7957) (or (shen.lowercase? V7957) (or (shen.uppercase? V7957) (shen.misc? V7957))))

(defun shen.lowercase? (V7958) (and (>= V7958 97) (<= V7958 122)))

(defun shen.uppercase? (V7959) (and (>= V7959 65) (<= V7959 90)))

(defun shen.misc? (V7960) (element? V7960 (cons 61 (cons 45 (cons 42 (cons 47 (cons 43 (cons 95 (cons 63 (cons 36 (cons 33 (cons 64 (cons 126 (cons 46 (cons 62 (cons 60 (cons 38 (cons 37 (cons 39 (cons 35 (cons 96 ())))))))))))))))))))))

(defun shen.<alphanums> (V7961) (let Result (let Parseshen.<alphanum> (shen.<alphanum> V7961) (if (shen.parse-failure? Parseshen.<alphanum>) (shen.parse-failure) (let Parseshen.<alphanums> (shen.<alphanums> Parseshen.<alphanum>) (if (shen.parse-failure? Parseshen.<alphanums>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<alphanums>) (cn (shen.<-out Parseshen.<alphanum>) (shen.<-out Parseshen.<alphanums>))))))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V7961) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ""))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<alphanum> (V7962) (let Result (let Parseshen.<alpha> (shen.<alpha> V7962) (if (shen.parse-failure? Parseshen.<alpha>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<alpha>) (shen.<-out Parseshen.<alpha>)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<numeral> (shen.<numeral> V7962) (if (shen.parse-failure? Parseshen.<numeral>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<numeral>) (shen.<-out Parseshen.<numeral>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<numeral> (V7963) (let Result (if (shen.non-empty-stream? V7963) (let Byte (shen.hds V7963) (let News7655 (shen.tls V7963) (if (shen.digit? Byte) (shen.comb (shen.in-> News7655) (n->string Byte)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.digit? (V7964) (and (>= V7964 48) (<= V7964 57)))

(defun shen.<str> (V7965) (let Result (let Parseshen.<dbq> (shen.<dbq> V7965) (if (shen.parse-failure? Parseshen.<dbq>) (shen.parse-failure) (let Parseshen.<strcontents> (shen.<strcontents> Parseshen.<dbq>) (if (shen.parse-failure? Parseshen.<strcontents>) (shen.parse-failure) (let Parseshen.<dbq> (shen.<dbq> Parseshen.<strcontents>) (if (shen.parse-failure? Parseshen.<dbq>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<dbq>) (shen.<-out Parseshen.<strcontents>)))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<dbq> (V7966) (let Result (if (shen.=hd? V7966 34) (let News7658 (shen.tls V7966) (shen.comb (shen.in-> News7658) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<strcontents> (V7967) (let Result (let Parseshen.<strc> (shen.<strc> V7967) (if (shen.parse-failure? Parseshen.<strc>) (shen.parse-failure) (let Parseshen.<strcontents> (shen.<strcontents> Parseshen.<strc>) (if (shen.parse-failure? Parseshen.<strcontents>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<strcontents>) (cn (shen.<-out Parseshen.<strc>) (shen.<-out Parseshen.<strcontents>))))))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V7967) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ""))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<strc> (V7968) (let Result (let Parseshen.<control> (shen.<control> V7968) (if (shen.parse-failure? Parseshen.<control>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<control>) (shen.<-out Parseshen.<control>)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<notdbq> (shen.<notdbq> V7968) (if (shen.parse-failure? Parseshen.<notdbq>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<notdbq>) (shen.<-out Parseshen.<notdbq>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<control> (V7969) (let Result (let Parseshen.<lowC> (shen.<lowC> V7969) (if (shen.parse-failure? Parseshen.<lowC>) (shen.parse-failure) (let Parseshen.<hash> (shen.<hash> Parseshen.<lowC>) (if (shen.parse-failure? Parseshen.<hash>) (shen.parse-failure) (let Parseshen.<integer> (shen.<integer> Parseshen.<hash>) (if (shen.parse-failure? Parseshen.<integer>) (shen.parse-failure) (let Parseshen.<semicolon> (shen.<semicolon> Parseshen.<integer>) (if (shen.parse-failure? Parseshen.<semicolon>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<semicolon>) (n->string (shen.<-out Parseshen.<integer>))))))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<notdbq> (V7970) (let Result (if (shen.non-empty-stream? V7970) (let Byte (shen.hds V7970) (let News7663 (shen.tls V7970) (if (not (= Byte 34)) (shen.comb (shen.in-> News7663) (n->string Byte)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<lowC> (V7971) (let Result (if (shen.=hd? V7971 99) (let News7665 (shen.tls V7971) (shen.comb (shen.in-> News7665) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<hash> (V7972) (let Result (if (shen.=hd? V7972 35) (let News7667 (shen.tls V7972) (shen.comb (shen.in-> News7667) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<number> (V7973) (let Result (let Parseshen.<minus> (shen.<minus> V7973) (if (shen.parse-failure? Parseshen.<minus>) (shen.parse-failure) (let Parseshen.<number> (shen.<number> Parseshen.<minus>) (if (shen.parse-failure? Parseshen.<number>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<number>) (- 0 (shen.<-out Parseshen.<number>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<plus> (shen.<plus> V7973) (if (shen.parse-failure? Parseshen.<plus>) (shen.parse-failure) (let Parseshen.<number> (shen.<number> Parseshen.<plus>) (if (shen.parse-failure? Parseshen.<number>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<number>) (shen.<-out Parseshen.<number>)))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<e-number> (shen.<e-number> V7973) (if (shen.parse-failure? Parseshen.<e-number>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<e-number>) (shen.<-out Parseshen.<e-number>)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<float> (shen.<float> V7973) (if (shen.parse-failure? Parseshen.<float>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<float>) (shen.<-out Parseshen.<float>)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<integer> (shen.<integer> V7973) (if (shen.parse-failure? Parseshen.<integer>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<integer>) (shen.<-out Parseshen.<integer>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)) Result)) Result)))

(defun shen.<minus> (V7974) (let Result (if (shen.=hd? V7974 45) (let News7670 (shen.tls V7974) (shen.comb (shen.in-> News7670) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<plus> (V7975) (let Result (if (shen.=hd? V7975 43) (let News7672 (shen.tls V7975) (shen.comb (shen.in-> News7672) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<integer> (V7976) (let Result (let Parseshen.<digits> (shen.<digits> V7976) (if (shen.parse-failure? Parseshen.<digits>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<digits>) (shen.compute-integer (shen.<-out Parseshen.<digits>))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<digits> (V7977) (let Result (let Parseshen.<digit> (shen.<digit> V7977) (if (shen.parse-failure? Parseshen.<digit>) (shen.parse-failure) (let Parseshen.<digits> (shen.<digits> Parseshen.<digit>) (if (shen.parse-failure? Parseshen.<digits>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<digits>) (cons (shen.<-out Parseshen.<digit>) (shen.<-out Parseshen.<digits>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<digit> (shen.<digit> V7977) (if (shen.parse-failure? Parseshen.<digit>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<digit>) (cons (shen.<-out Parseshen.<digit>) ())))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<digit> (V7978) (let Result (if (shen.non-empty-stream? V7978) (let Byte (shen.hds V7978) (let News7676 (shen.tls V7978) (if (shen.digit? Byte) (shen.comb (shen.in-> News7676) (shen.byte->digit Byte)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.byte->digit (V7979) (- V7979 48))

(defun shen.compute-integer (V7980) (shen.compute-integer-h (reverse V7980) 0))

(defun shen.compute-integer-h (V7983 V7984) (cond ((= () V7983) 0) ((cons? V7983) (+ (* (shen.expt 10 V7984) (hd V7983)) (shen.compute-integer-h (tl V7983) (+ V7984 1)))) (true (shen.f-error shen.compute-integer-h))))

(defun shen.expt (V7987 V7988) (cond ((= 0 V7988) 1) ((> V7988 0) (* V7987 (shen.expt V7987 (- V7988 1)))) (true (/ (shen.expt V7987 (+ V7988 1)) V7987))))

(defun shen.<float> (V7989) (let Result (let Parseshen.<integer> (shen.<integer> V7989) (if (shen.parse-failure? Parseshen.<integer>) (shen.parse-failure) (let Parseshen.<stop> (shen.<stop> Parseshen.<integer>) (if (shen.parse-failure? Parseshen.<stop>) (shen.parse-failure) (let Parseshen.<fraction> (shen.<fraction> Parseshen.<stop>) (if (shen.parse-failure? Parseshen.<fraction>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<fraction>) (+ (shen.<-out Parseshen.<integer>) (shen.<-out Parseshen.<fraction>))))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<stop> (shen.<stop> V7989) (if (shen.parse-failure? Parseshen.<stop>) (shen.parse-failure) (let Parseshen.<fraction> (shen.<fraction> Parseshen.<stop>) (if (shen.parse-failure? Parseshen.<fraction>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<fraction>) (shen.<-out Parseshen.<fraction>)))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<stop> (V7990) (let Result (if (shen.=hd? V7990 46) (let News7679 (shen.tls V7990) (shen.comb (shen.in-> News7679) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<fraction> (V7991) (let Result (let Parseshen.<digits> (shen.<digits> V7991) (if (shen.parse-failure? Parseshen.<digits>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<digits>) (shen.compute-fraction (shen.<-out Parseshen.<digits>))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.compute-fraction (V7992) (shen.compute-fraction-h V7992 -1))

(defun shen.compute-fraction-h (V7995 V7996) (cond ((= () V7995) 0) ((cons? V7995) (+ (* (shen.expt 10 V7996) (hd V7995)) (shen.compute-fraction-h (tl V7995) (- V7996 1)))) (true (shen.f-error shen.compute-fraction-h))))

(defun shen.<e-number> (V7997) (let Result (let Parseshen.<float> (shen.<float> V7997) (if (shen.parse-failure? Parseshen.<float>) (shen.parse-failure) (let Parseshen.<lowE> (shen.<lowE> Parseshen.<float>) (if (shen.parse-failure? Parseshen.<lowE>) (shen.parse-failure) (let Parseshen.<log10> (shen.<log10> Parseshen.<lowE>) (if (shen.parse-failure? Parseshen.<log10>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<log10>) (shen.compute-E (shen.<-out Parseshen.<float>) (shen.<-out Parseshen.<log10>))))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<integer> (shen.<integer> V7997) (if (shen.parse-failure? Parseshen.<integer>) (shen.parse-failure) (let Parseshen.<lowE> (shen.<lowE> Parseshen.<integer>) (if (shen.parse-failure? Parseshen.<lowE>) (shen.parse-failure) (let Parseshen.<log10> (shen.<log10> Parseshen.<lowE>) (if (shen.parse-failure? Parseshen.<log10>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<log10>) (shen.compute-E (shen.<-out Parseshen.<integer>) (shen.<-out Parseshen.<log10>))))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<log10> (V7998) (let Result (let Parseshen.<plus> (shen.<plus> V7998) (if (shen.parse-failure? Parseshen.<plus>) (shen.parse-failure) (let Parseshen.<log10> (shen.<log10> Parseshen.<plus>) (if (shen.parse-failure? Parseshen.<log10>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<log10>) (shen.<-out Parseshen.<log10>)))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<minus> (shen.<minus> V7998) (if (shen.parse-failure? Parseshen.<minus>) (shen.parse-failure) (let Parseshen.<log10> (shen.<log10> Parseshen.<minus>) (if (shen.parse-failure? Parseshen.<log10>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<log10>) (- 0 (shen.<-out Parseshen.<log10>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<integer> (shen.<integer> V7998) (if (shen.parse-failure? Parseshen.<integer>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<integer>) (shen.<-out Parseshen.<integer>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)))

(defun shen.<lowE> (V7999) (let Result (if (shen.=hd? V7999 101) (let News7684 (shen.tls V7999) (shen.comb (shen.in-> News7684) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.compute-E (V8000 V8001) (* V8000 (shen.expt 10 V8001)))

(defun shen.<whitespaces> (V8002) (let Result (let Parseshen.<whitespace> (shen.<whitespace> V8002) (if (shen.parse-failure? Parseshen.<whitespace>) (shen.parse-failure) (let Parseshen.<whitespaces> (shen.<whitespaces> Parseshen.<whitespace>) (if (shen.parse-failure? Parseshen.<whitespaces>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<whitespaces>) shen.skip))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<whitespace> (shen.<whitespace> V8002) (if (shen.parse-failure? Parseshen.<whitespace>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<whitespace>) shen.skip))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<whitespace> (V8003) (let Result (if (shen.non-empty-stream? V8003) (let Byte (shen.hds V8003) (let News7687 (shen.tls V8003) (if (shen.whitespace? Byte) (shen.comb (shen.in-> News7687) shen.skip) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.whitespace? (V8006) (cond ((= 32 V8006) true) ((= 13 V8006) true) ((= 10 V8006) true) ((= 9 V8006) true) (true false)))

(defun shen.unpackage&macroexpand (V8007) (cond ((= () V8007) ()) ((and (cons? V8007) (shen.packaged? (hd V8007))) (shen.unpackage&macroexpand (append (shen.unpackage (hd V8007)) (tl V8007)))) ((cons? V8007) (let M (macroexpand (hd V8007)) (if (shen.packaged? M) (shen.unpackage&macroexpand (cons M (tl V8007))) (cons M (shen.unpackage&macroexpand (tl V8007)))))) (true (shen.f-error shen.unpackage&macroexpand))))

(defun shen.packaged? (V8010) (cond ((and (cons? V8010) (and (= package (hd V8010)) (and (cons? (tl V8010)) (cons? (tl (tl V8010)))))) true) (true false)))

(defun shen.unpackage (V8013) (cond ((and (cons? V8013) (and (= package (hd V8013)) (and (cons? (tl V8013)) (and (= null (hd (tl V8013))) (cons? (tl (tl V8013))))))) (tl (tl (tl V8013)))) ((and (cons? V8013) (and (= package (hd V8013)) (and (cons? (tl V8013)) (cons? (tl (tl V8013)))))) (let External! (eval (hd (tl (tl V8013)))) (let Package (shen.package-symbols (str (hd (tl V8013))) External! (tl (tl (tl V8013)))) (let RecordExternal (shen.record-external (hd (tl V8013)) External!) Package)))) (true (shen.f-error shen.unpackage))))

(defun shen.record-external (V8014 V8015) (let External (trap-error (get V8014 shen.external-symbols (value *property-vector*)) (lambda E ())) (put V8014 shen.external-symbols (union V8015 External) (value *property-vector*))))

(defun shen.package-symbols (V8020 V8021 V8022) (cond ((cons? V8022) (map (lambda X (shen.package-symbols V8020 V8021 X)) V8022)) ((shen.internal? V8022 V8020 V8021) (shen.intern-in-package V8020 V8022)) (true V8022)))

(defun shen.intern-in-package (V8023 V8024) (intern (@s V8023 (@s "." (str V8024)))))

(defun shen.internal? (V8025 V8026 V8027) (and (not (element? V8025 V8027)) (and (not (shen.sng? V8025)) (and (not (shen.dbl? V8025)) (and (symbol? V8025) (and (not (shen.sysfunc? V8025)) (and (not (variable? V8025)) (and (not (shen.internal-to-shen? (str V8025))) (not (shen.internal-to-P? V8026 (str V8025)))))))))))

(defun shen.internal-to-shen? (V8032) (cond ((and (shen.+string? V8032) (and (= "s" (hdstr V8032)) (and (shen.+string? (tlstr V8032)) (and (= "h" (hdstr (tlstr V8032))) (and (shen.+string? (tlstr (tlstr V8032))) (and (= "e" (hdstr (tlstr (tlstr V8032)))) (and (shen.+string? (tlstr (tlstr (tlstr V8032)))) (and (= "n" (hdstr (tlstr (tlstr (tlstr V8032))))) (and (shen.+string? (tlstr (tlstr (tlstr (tlstr V8032))))) (= "." (hdstr (tlstr (tlstr (tlstr (tlstr V8032))))))))))))))) true) (true false)))

(defun shen.sysfunc? (V8033) (element? V8033 (get shen shen.external-symbols (value *property-vector*))))

(defun shen.internal-to-P? (V8041 V8042) (cond ((and (= "" V8041) (and (shen.+string? V8042) (= "." (hdstr V8042)))) true) ((and (shen.+string? V8041) (and (shen.+string? V8042) (= (hdstr V8041) (hdstr V8042)))) (shen.internal-to-P? (tlstr V8041) (tlstr V8042))) (true false)))

(defun shen.process-applications (V8045 V8046) (cond ((element? V8045 V8046) V8045) ((and (cons? V8045) (shen.non-application? (hd V8045))) (shen.special-case (hd V8045) V8045 V8046)) ((cons? V8045) (shen.process-application (map (lambda Y (shen.process-applications Y V8046)) V8045) V8046)) (true V8045)))

(defun shen.non-application? (V8049) (cond ((= define V8049) true) ((= defun V8049) true) ((= synonyms V8049) true) ((shen.special? V8049) true) ((shen.extraspecial? V8049) true) (true false)))

(defun shen.special-case (V8054 V8055 V8056) (cond ((and (= lambda V8054) (and (cons? V8055) (and (= lambda (hd V8055)) (and (cons? (tl V8055)) (and (cons? (tl (tl V8055))) (= () (tl (tl (tl V8055))))))))) (cons lambda (cons (hd (tl V8055)) (cons (shen.process-applications (hd (tl (tl V8055))) V8056) ())))) ((and (= let V8054) (and (cons? V8055) (and (= let (hd V8055)) (and (cons? (tl V8055)) (and (cons? (tl (tl V8055))) (and (cons? (tl (tl (tl V8055)))) (= () (tl (tl (tl (tl V8055))))))))))) (cons let (cons (hd (tl V8055)) (cons (shen.process-applications (hd (tl (tl V8055))) V8056) (cons (shen.process-applications (hd (tl (tl (tl V8055)))) V8056) ()))))) ((and (= defun V8054) (and (cons? V8055) (and (= defun (hd V8055)) (and (cons? (tl V8055)) (and (cons? (tl (tl V8055))) (and (cons? (tl (tl (tl V8055)))) (= () (tl (tl (tl (tl V8055))))))))))) V8055) ((and (= define V8054) (and (cons? V8055) (and (= define (hd V8055)) (and (cons? (tl V8055)) (and (cons? (tl (tl V8055))) (= { (hd (tl (tl V8055))))))))) (cons define (cons (hd (tl V8055)) (cons { (shen.process-after-type (hd (tl V8055)) (tl (tl (tl V8055))) V8056))))) ((and (= define V8054) (and (cons? V8055) (and (= define (hd V8055)) (cons? (tl V8055))))) (cons define (cons (hd (tl V8055)) (map (lambda Y (shen.process-applications Y V8056)) (tl (tl V8055)))))) ((= synonyms V8054) (cons synonyms V8055)) ((and (= type V8054) (and (cons? V8055) (and (= type (hd V8055)) (and (cons? (tl V8055)) (and (cons? (tl (tl V8055))) (= () (tl (tl (tl V8055))))))))) (cons type (cons (shen.process-applications (hd (tl V8055)) V8056) (tl (tl V8055))))) ((and (= input+ V8054) (and (cons? V8055) (and (= input+ (hd V8055)) (and (cons? (tl V8055)) (and (cons? (tl (tl V8055))) (= () (tl (tl (tl V8055))))))))) (cons input+ (cons (hd (tl V8055)) (cons (shen.process-applications (hd (tl (tl V8055))) V8056) ())))) ((and (cons? V8055) (shen.special? (hd V8055))) (cons (hd V8055) (map (lambda Y (shen.process-applications Y V8056)) (tl V8055)))) ((and (cons? V8055) (shen.extraspecial? (hd V8055))) V8055) (true (shen.f-error shen.special-case))))

(defun shen.process-after-type (V8059 V8060 V8061) (cond ((and (cons? V8060) (= } (hd V8060))) (cons } (map (lambda Y (shen.process-applications Y V8061)) (tl V8060)))) ((cons? V8060) (cons (hd V8060) (shen.process-after-type V8059 (tl V8060) V8061))) (true (simple-error (cn "missing } in " (shen.app V8059 "
" shen.a))))))

(defun shen.process-application (V8062 V8063) (cond ((cons? V8062) (let ArityF (arity (hd V8062)) (let N (length (tl V8062)) (if (element? V8062 V8063) V8062 (if (shen.shen-call? (hd V8062)) V8062 (if (shen.fn-call? V8062) (shen.fn-call V8062) (if (shen.zero-place? V8062) V8062 (if (shen.undefined-f? (hd V8062) ArityF) (shen.simple-curry (cons (cons fn (cons (hd V8062) ())) (tl V8062))) (if (variable? (hd V8062)) (shen.simple-curry V8062) (if (shen.application? (hd V8062)) (shen.simple-curry V8062) (if (shen.partial-application*? (hd V8062) ArityF N) (shen.lambda-function V8062 (- ArityF N)) (if (shen.overapplication? (hd V8062) ArityF N) (shen.simple-curry (cons (cons fn (cons (hd V8062) ())) (tl V8062))) V8062)))))))))))) (true (shen.f-error shen.process-application))))

(defun shen.zero-place? (V8066) (cond ((and (cons? V8066) (= () (tl V8066))) true) (true false)))

(defun shen.shen-call? (V8067) (and (symbol? V8067) (shen.internal-to-shen? (str V8067))))

(defun shen.internal-to-shen? (V8072) (cond ((and (shen.+string? V8072) (and (= "s" (hdstr V8072)) (and (shen.+string? (tlstr V8072)) (and (= "h" (hdstr (tlstr V8072))) (and (shen.+string? (tlstr (tlstr V8072))) (and (= "e" (hdstr (tlstr (tlstr V8072)))) (and (shen.+string? (tlstr (tlstr (tlstr V8072)))) (and (= "n" (hdstr (tlstr (tlstr (tlstr V8072))))) (and (shen.+string? (tlstr (tlstr (tlstr (tlstr V8072))))) (= "." (hdstr (tlstr (tlstr (tlstr (tlstr V8072))))))))))))))) true) (true false)))

(defun shen.application? (V8075) (cond ((and (cons? V8075) (and (= protect (hd V8075)) (and (cons? (tl V8075)) (= () (tl (tl V8075)))))) false) (true (cons? V8075))))

(defun shen.undefined-f? (V8080 V8081) (cond ((= -1 V8081) (and (shen.lowercase-symbol? V8080) (not (element? V8080 (external shen))))) (true false)))

(defun shen.lowercase-symbol? (V8082) (and (symbol? V8082) (not (variable? V8082))))

(defun shen.simple-curry (V8083) (cond ((and (cons? V8083) (and (cons? (tl V8083)) (= () (tl (tl V8083))))) V8083) ((and (cons? V8083) (and (cons? (tl V8083)) (cons? (tl (tl V8083))))) (shen.simple-curry (cons (cons (hd V8083) (cons (hd (tl V8083)) ())) (tl (tl V8083))))) (true V8083)))

(defun function (V8084) (fn V8084))

(defun fn (V8085) (let LookUp (assoc V8085 (value shen.*lambdatable*)) (if (empty? LookUp) (simple-error (cn "fn: " (shen.app V8085 " is undefined
" shen.a))) (tl LookUp))))

(defun shen.fn-call? (V8088) (cond ((and (cons? V8088) (and (= fn (hd V8088)) (and (cons? (tl V8088)) (= () (tl (tl V8088)))))) true) ((and (cons? V8088) (and (= function (hd V8088)) (and (cons? (tl V8088)) (= () (tl (tl V8088)))))) true) (true false)))

(defun shen.fn-call (V8089) (cond ((and (cons? V8089) (and (= function (hd V8089)) (and (cons? (tl V8089)) (= () (tl (tl V8089)))))) (shen.fn-call (cons fn (tl V8089)))) ((and (cons? V8089) (and (= fn (hd V8089)) (and (cons? (tl V8089)) (= () (tl (tl V8089)))))) (let ArityF (arity (hd (tl V8089))) (if (= ArityF -1) V8089 (if (= ArityF 0) (simple-error "fn cannot be applied to a zero place function
") (shen.lambda-function (tl V8089) ArityF))))) (true (shen.f-error shen.fn-call))))

(defun shen.partial-application*? (V8090 V8091 V8092) (let Verdict (> V8091 V8092) (let Message (if (and Verdict (and (shen.loading?) (not (element? V8090 (cons + (cons - ())))))) (pr (cn "partial application of " (shen.app V8090 "
" shen.a)) (stoutput)) shen.skip) Verdict)))

(defun shen.loading? () (value shen.*loading?*))

(defun shen.overapplication? (V8097 V8098 V8099) (cond ((= -1 V8098) false) (true (let Verdict (< V8098 V8099) (let Message (if (and Verdict (shen.loading?)) (pr (shen.app V8097 (cn " might not like " (shen.app V8099 (cn " argument" (shen.app (if (= V8099 1) "" "s") "
" shen.a)) shen.a)) shen.a) (stoutput)) shen.skip) Verdict)))))

