(defun read-file (V7979) (let Bytelist (read-file-as-bytelist V7979) (let S-exprs (trap-error (compile (lambda X (shen.<s-exprs> X)) Bytelist) (lambda E (shen.print-residue (value shen.*residue*)))) (let Process (shen.process-sexprs S-exprs) Process))))

(defun shen.print-residue (V7980) (let Err (pr "syntax error here:
" (stoutput)) (shen.nchars 50 V7980)))

(defun shen.nchars (V7985 V7986) (cond ((= 0 V7985) (do (pr " ..." (stoutput)) (abort))) ((= () V7986) (do (pr " ..." (stoutput)) (abort))) ((cons? V7986) (do (pr (n->string (hd V7986)) (stoutput)) (shen.nchars (- V7985 1) (tl V7986)))) (true (shen.f-error shen.nchars))))

(defun it () (value shen.*it*))

(defun read-file-as-bytelist (V7987) (let Stream (open V7987 in) (let Byte (read-byte Stream) (let Bytes (shen.read-file-as-bytelist-help Stream Byte ()) (let Close (close Stream) (reverse Bytes))))))

(defun shen.read-file-as-bytelist-help (V7988 V7989 V7990) (cond ((= -1 V7989) V7990) (true (shen.read-file-as-bytelist-help V7988 (read-byte V7988) (cons V7989 V7990)))))

(defun read-file-as-string (V7991) (let Stream (open V7991 in) (shen.rfas-h Stream (read-byte Stream) "")))

(defun shen.rfas-h (V7992 V7993 V7994) (cond ((= -1 V7993) (do (close V7992) V7994)) (true (shen.rfas-h V7992 (read-byte V7992) (cn V7994 (n->string V7993))))))

(defun input (V7995) (eval-kl (read V7995)))

(defun input+ (V7996 V7997) (let Mono? (shen.monotype V7996) (let Input (read V7997) (if (= false (shen.typecheck Input (shen.rectify-type V7996))) (simple-error (cn "type error: " (shen.app Input (cn " is not of type " (shen.app V7996 "
" shen.r)) shen.r))) (eval-kl Input)))))

(defun shen.monotype (V7998) (cond ((cons? V7998) (map (lambda Z (shen.monotype Z)) V7998)) (true (if (variable? V7998) (simple-error (cn "input+ expects a monotype: not " (shen.app V7998 "
" shen.a))) V7998))))

(defun lineread (V7999) (shen.read-loop V7999 (shen.my-read-byte V7999) () (lambda X (shen.return? X))))

(defun read-from-string (V8000) (let Bytelist (shen.str->bytes V8000) (let S-exprs (compile (lambda X (shen.<s-exprs> X)) Bytelist) (let Process (shen.process-sexprs S-exprs) Process))))

(defun read-from-string-unprocessed (V8001) (let Bytelist (shen.str->bytes V8001) (let S-exprs (compile (lambda X (shen.<s-exprs> X)) Bytelist) S-exprs)))

(defun shen.str->bytes (V8002) (cond ((= "" V8002) ()) ((shen.+string? V8002) (cons (string->n (hdstr V8002)) (shen.str->bytes (tlstr V8002)))) (true (shen.f-error shen.str->bytes))))

(defun read (V8003) (hd (shen.read-loop V8003 (shen.my-read-byte V8003) () (lambda X (shen.whitespace? X)))))

(defun shen.my-read-byte (V8004) (if (shen.char-stinput? V8004) (string->n (shen.read-unit-string V8004)) (read-byte V8004)))

(defun shen.read-loop (V8009 V8010 V8011 V8012) (cond ((= 94 V8010) (simple-error "read aborted")) ((= -1 V8010) (if (empty? V8011) (simple-error "error: empty stream") (compile (lambda X (shen.<s-exprs> X)) V8011))) ((= 0 V8010) (shen.read-loop V8009 (shen.my-read-byte V8009) V8011 V8012)) (true (if (V8012 V8010) (let Parse (shen.try-parse V8011) (if (shen.nothing-doing? Parse) (shen.read-loop V8009 (shen.my-read-byte V8009) (append V8011 (cons V8010 ())) V8012) (do (shen.record-it V8011) Parse))) (shen.read-loop V8009 (shen.my-read-byte V8009) (append V8011 (cons V8010 ())) V8012)))))

(defun shen.try-parse (V8013) (let S-exprs (trap-error (compile (lambda X (shen.<s-exprs> X)) V8013) (lambda E shen.i-failed!)) (if (shen.nothing-doing? S-exprs) shen.i-failed! (shen.process-sexprs S-exprs))))

(defun shen.nothing-doing? (V8016) (cond ((= shen.i-failed! V8016) true) ((= () V8016) true) (true false)))

(defun shen.record-it (V8017) (set shen.*it* (shen.bytes->string V8017)))

(defun shen.bytes->string (V8018) (cond ((= () V8018) "") ((cons? V8018) (cn (n->string (hd V8018)) (shen.bytes->string (tl V8018)))) (true (shen.f-error shen.bytes->string))))

(defun shen.process-sexprs (V8019) (let Unpack&Expand (shen.unpackage&macroexpand V8019) (let FindArities (shen.find-arities Unpack&Expand) (let Types (shen.find-types Unpack&Expand) (map (lambda X (shen.process-applications X Types)) Unpack&Expand)))))

(defun shen.find-types (V8020) (cond ((and (cons? V8020) (and (cons? (tl V8020)) (= (hd V8020) (intern ":")))) (cons (hd (tl V8020)) (shen.find-types (tl (tl V8020))))) ((cons? V8020) (append (shen.find-types (hd V8020)) (shen.find-types (tl V8020)))) (true ())))

(defun shen.find-arities (V8023) (cond ((and (cons? V8023) (and (= define (hd V8023)) (and (cons? (tl V8023)) (and (cons? (tl (tl V8023))) (= { (hd (tl (tl V8023)))))))) (shen.store-arity (hd (tl V8023)) (shen.find-arity (hd (tl V8023)) 1 (tl (tl (tl V8023)))))) ((and (cons? V8023) (and (= define (hd V8023)) (cons? (tl V8023)))) (shen.store-arity (hd (tl V8023)) (shen.find-arity (hd (tl V8023)) 0 (tl (tl V8023))))) ((cons? V8023) (map (lambda Z (shen.find-arities Z)) V8023)) (true shen.skip)))

(defun shen.store-arity (V8024 V8025) (let ArityF (arity V8024) (if (= ArityF -1) (shen.execute-store-arity V8024 V8025) (if (= ArityF V8025) shen.skip (if (shen.sysfunc? V8024) (simple-error (shen.app V8024 " is a system function
" shen.a)) (do (pr (cn "changing the arity of " (shen.app V8024 " may cause errors
" shen.a)) (stoutput)) (shen.execute-store-arity V8024 V8025)))))))

(defun shen.execute-store-arity (V8026 V8027) (cond ((= 0 V8027) (put V8026 arity 0 (value *property-vector*))) (true (do (put V8026 arity V8027 (value *property-vector*)) (shen.update-lambdatable V8026 V8027)))))

(defun shen.update-lambdatable (V8028 V8029) (let LambdaTable (value shen.*lambdatable*) (let Lambda (eval-kl (shen.lambda-function (cons V8028 ()) V8029)) (let Insert (shen.assoc-> V8028 Lambda LambdaTable) (let Reset (set shen.*lambdatable* Insert) Reset)))))

(defun shen.lambda-function (V8032 V8033) (cond ((= 0 V8033) shen.skip) ((= 1 V8033) (let X (gensym Y) (cons lambda (cons X (cons (append V8032 (cons X ())) ()))))) (true (let X (gensym Y) (cons lambda (cons X (cons (shen.lambda-function (append V8032 (cons X ())) (- V8033 1)) ())))))))

(defun shen.assoc-> (V8043 V8044 V8045) (cond ((= () V8045) (cons (cons V8043 V8044) ())) ((and (cons? V8045) (and (cons? (hd V8045)) (= V8043 (hd (hd V8045))))) (cons (cons (hd (hd V8045)) V8044) (tl V8045))) ((cons? V8045) (cons (hd V8045) (shen.assoc-> V8043 V8044 (tl V8045)))) (true (simple-error "implementation error in shen.assoc->"))))

(defun shen.find-arity (V8060 V8061 V8062) (cond ((and (= 0 V8061) (and (cons? V8062) (= (hd V8062) ->))) 0) ((and (= 0 V8061) (and (cons? V8062) (= (hd V8062) <-))) 0) ((and (= 0 V8061) (cons? V8062)) (+ 1 (shen.find-arity V8060 0 (tl V8062)))) ((and (= 1 V8061) (and (cons? V8062) (= } (hd V8062)))) (shen.find-arity V8060 0 (tl V8062))) ((and (= 1 V8061) (cons? V8062)) (shen.find-arity V8060 1 (tl V8062))) ((= 1 V8061) (simple-error (cn "syntax error in " (shen.app V8060 " definition: missing }
" shen.a)))) (true (simple-error (cn "syntax error in " (shen.app V8060 " definition: missing -> or <-
" shen.a))))))

(defun shen.<s-exprs> (V8063) (let Result (let Parseshen.<lsb> (shen.<lsb> V8063) (if (shen.parse-failure? Parseshen.<lsb>) (shen.parse-failure) (let Parseshen.<s-exprs1> (shen.<s-exprs1> Parseshen.<lsb>) (if (shen.parse-failure? Parseshen.<s-exprs1>) (shen.parse-failure) (let Parseshen.<rsb> (shen.<rsb> Parseshen.<s-exprs1>) (if (shen.parse-failure? Parseshen.<rsb>) (shen.parse-failure) (let Parseshen.<s-exprs2> (shen.<s-exprs2> Parseshen.<rsb>) (if (shen.parse-failure? Parseshen.<s-exprs2>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs2>) (cons (shen.cons-form (shen.<-out Parseshen.<s-exprs1>)) (shen.<-out Parseshen.<s-exprs2>))))))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<lrb> (shen.<lrb> V8063) (if (shen.parse-failure? Parseshen.<lrb>) (shen.parse-failure) (let Parseshen.<s-exprs1> (shen.<s-exprs1> Parseshen.<lrb>) (if (shen.parse-failure? Parseshen.<s-exprs1>) (shen.parse-failure) (let Parseshen.<rrb> (shen.<rrb> Parseshen.<s-exprs1>) (if (shen.parse-failure? Parseshen.<rrb>) (shen.parse-failure) (let Parseshen.<s-exprs2> (shen.<s-exprs2> Parseshen.<rrb>) (if (shen.parse-failure? Parseshen.<s-exprs2>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs2>) (shen.add-sexpr (shen.<-out Parseshen.<s-exprs1>) (shen.<-out Parseshen.<s-exprs2>))))))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<lcurly> (shen.<lcurly> V8063) (if (shen.parse-failure? Parseshen.<lcurly>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<lcurly>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons { (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<rcurly> (shen.<rcurly> V8063) (if (shen.parse-failure? Parseshen.<rcurly>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<rcurly>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons } (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<bar> (shen.<bar> V8063) (if (shen.parse-failure? Parseshen.<bar>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<bar>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons bar! (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<semicolon> (shen.<semicolon> V8063) (if (shen.parse-failure? Parseshen.<semicolon>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<semicolon>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons (intern ";") (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<colon> (shen.<colon> V8063) (if (shen.parse-failure? Parseshen.<colon>) (shen.parse-failure) (let Parseshen.<equal> (shen.<equal> Parseshen.<colon>) (if (shen.parse-failure? Parseshen.<equal>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<equal>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons (intern ":=") (shen.<-out Parseshen.<s-exprs>))))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<colon> (shen.<colon> V8063) (if (shen.parse-failure? Parseshen.<colon>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<colon>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons (intern ":") (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<comma> (shen.<comma> V8063) (if (shen.parse-failure? Parseshen.<comma>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<comma>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons (intern ",") (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<comment> (shen.<comment> V8063) (if (shen.parse-failure? Parseshen.<comment>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<comment>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (shen.<-out Parseshen.<s-exprs>)))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<atom> (shen.<atom> V8063) (if (shen.parse-failure? Parseshen.<atom>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<atom>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons (shen.<-out Parseshen.<atom>) (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<whitespaces> (shen.<whitespaces> V8063) (if (shen.parse-failure? Parseshen.<whitespaces>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<whitespaces>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (shen.<-out Parseshen.<s-exprs>)))))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V8063) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ()))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)))

(defun shen.add-sexpr (V8064 V8065) (cond ((and (cons? V8064) (and (= $ (hd V8064)) (and (cons? (tl V8064)) (= () (tl (tl V8064)))))) (append (explode (hd (tl V8064))) V8065)) (true (cons V8064 V8065))))

(defun shen.<lsb> (V8066) (let Result (if (shen.=hd? V8066 91) (let News7740 (shen.tls V8066) (shen.comb (shen.in-> News7740) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<rsb> (V8067) (let Result (if (shen.=hd? V8067 93) (let News7742 (shen.tls V8067) (shen.comb (shen.in-> News7742) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<s-exprs1> (V8068) (let Result (let Parseshen.<s-exprs> (shen.<s-exprs> V8068) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (shen.<-out Parseshen.<s-exprs>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<s-exprs2> (V8069) (let Result (let Parseshen.<s-exprs> (shen.<s-exprs> V8069) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (shen.<-out Parseshen.<s-exprs>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.cons-form (V8071) (cond ((= () V8071) ()) ((and (cons? V8071) (and (cons? (tl V8071)) (and (cons? (tl (tl V8071))) (and (= () (tl (tl (tl V8071)))) (= (hd (tl V8071)) bar!))))) (cons cons (cons (hd V8071) (tl (tl V8071))))) ((and (cons? V8071) (and (cons? (tl V8071)) (and (cons? (tl (tl V8071))) (and (cons? (tl (tl (tl V8071)))) (= (hd (tl V8071)) bar!))))) (simple-error "misapplication of |
")) ((cons? V8071) (cons cons (cons (hd V8071) (cons (shen.cons-form (tl V8071)) ())))) (true (shen.f-error shen.cons-form))))

(defun shen.<lrb> (V8072) (let Result (if (shen.=hd? V8072 40) (let News7746 (shen.tls V8072) (shen.comb (shen.in-> News7746) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<rrb> (V8073) (let Result (if (shen.=hd? V8073 41) (let News7748 (shen.tls V8073) (shen.comb (shen.in-> News7748) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<lcurly> (V8074) (let Result (if (shen.=hd? V8074 123) (let News7750 (shen.tls V8074) (shen.comb (shen.in-> News7750) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<rcurly> (V8075) (let Result (if (shen.=hd? V8075 125) (let News7752 (shen.tls V8075) (shen.comb (shen.in-> News7752) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<bar> (V8076) (let Result (if (shen.=hd? V8076 124) (let News7754 (shen.tls V8076) (shen.comb (shen.in-> News7754) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<semicolon> (V8077) (let Result (if (shen.=hd? V8077 59) (let News7756 (shen.tls V8077) (shen.comb (shen.in-> News7756) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<colon> (V8078) (let Result (if (shen.=hd? V8078 58) (let News7758 (shen.tls V8078) (shen.comb (shen.in-> News7758) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<comma> (V8079) (let Result (if (shen.=hd? V8079 44) (let News7760 (shen.tls V8079) (shen.comb (shen.in-> News7760) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<equal> (V8080) (let Result (if (shen.=hd? V8080 61) (let News7762 (shen.tls V8080) (shen.comb (shen.in-> News7762) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<comment> (V8081) (let Result (let Parseshen.<singleline> (shen.<singleline> V8081) (if (shen.parse-failure? Parseshen.<singleline>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<singleline>) shen.skip))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<multiline> (shen.<multiline> V8081) (if (shen.parse-failure? Parseshen.<multiline>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<multiline>) shen.skip))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<singleline> (V8082) (let Result (let Parseshen.<backslash> (shen.<backslash> V8082) (if (shen.parse-failure? Parseshen.<backslash>) (shen.parse-failure) (let Parseshen.<backslash> (shen.<backslash> Parseshen.<backslash>) (if (shen.parse-failure? Parseshen.<backslash>) (shen.parse-failure) (let Parseshen.<shortnatters> (shen.<shortnatters> Parseshen.<backslash>) (if (shen.parse-failure? Parseshen.<shortnatters>) (shen.parse-failure) (let Parseshen.<returns> (shen.<returns> Parseshen.<shortnatters>) (if (shen.parse-failure? Parseshen.<returns>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<returns>) shen.skip))))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<backslash> (V8083) (let Result (if (shen.=hd? V8083 92) (let News7766 (shen.tls V8083) (shen.comb (shen.in-> News7766) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<shortnatters> (V8084) (let Result (let Parseshen.<shortnatter> (shen.<shortnatter> V8084) (if (shen.parse-failure? Parseshen.<shortnatter>) (shen.parse-failure) (let Parseshen.<shortnatters> (shen.<shortnatters> Parseshen.<shortnatter>) (if (shen.parse-failure? Parseshen.<shortnatters>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<shortnatters>) shen.skip))))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V8084) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) shen.skip))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<shortnatter> (V8085) (let Result (if (shen.non-empty-stream? V8085) (let Byte (shen.hds V8085) (let News7769 (shen.tls V8085) (if (not (shen.return? Byte)) (shen.comb (shen.in-> News7769) shen.skip) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<returns> (V8086) (let Result (let Parseshen.<return> (shen.<return> V8086) (if (shen.parse-failure? Parseshen.<return>) (shen.parse-failure) (let Parseshen.<returns> (shen.<returns> Parseshen.<return>) (if (shen.parse-failure? Parseshen.<returns>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<returns>) shen.skip))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<return> (shen.<return> V8086) (if (shen.parse-failure? Parseshen.<return>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<return>) shen.skip))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<return> (V8087) (let Result (if (shen.non-empty-stream? V8087) (let Byte (shen.hds V8087) (let News7772 (shen.tls V8087) (if (shen.return? Byte) (shen.comb (shen.in-> News7772) shen.skip) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.return? (V8088) (element? V8088 (cons 9 (cons 10 (cons 13 ())))))

(defun shen.<multiline> (V8089) (let Result (let Parseshen.<backslash> (shen.<backslash> V8089) (if (shen.parse-failure? Parseshen.<backslash>) (shen.parse-failure) (let Parseshen.<times> (shen.<times> Parseshen.<backslash>) (if (shen.parse-failure? Parseshen.<times>) (shen.parse-failure) (let Parseshen.<longnatter> (shen.<longnatter> Parseshen.<times>) (if (shen.parse-failure? Parseshen.<longnatter>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<longnatter>) shen.skip))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<times> (V8090) (let Result (if (shen.=hd? V8090 42) (let News7775 (shen.tls V8090) (shen.comb (shen.in-> News7775) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<longnatter> (V8091) (let Result (let Parseshen.<comment> (shen.<comment> V8091) (if (shen.parse-failure? Parseshen.<comment>) (shen.parse-failure) (let Parseshen.<longnatter> (shen.<longnatter> Parseshen.<comment>) (if (shen.parse-failure? Parseshen.<longnatter>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<longnatter>) shen.skip))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<times> (shen.<times> V8091) (if (shen.parse-failure? Parseshen.<times>) (shen.parse-failure) (let Parseshen.<backslash> (shen.<backslash> Parseshen.<times>) (if (shen.parse-failure? Parseshen.<backslash>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<backslash>) shen.skip))))) (if (shen.parse-failure? Result) (let Result (if (shen.non-empty-stream? V8091) (let News7777 (shen.tls V8091) (let Parseshen.<longnatter> (shen.<longnatter> News7777) (if (shen.parse-failure? Parseshen.<longnatter>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<longnatter>) shen.skip)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)))

(defun shen.<atom> (V8092) (let Result (let Parseshen.<str> (shen.<str> V8092) (if (shen.parse-failure? Parseshen.<str>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<str>) (shen.<-out Parseshen.<str>)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<number> (shen.<number> V8092) (if (shen.parse-failure? Parseshen.<number>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<number>) (shen.<-out Parseshen.<number>)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<sym> (shen.<sym> V8092) (if (shen.parse-failure? Parseshen.<sym>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<sym>) (if (= (shen.<-out Parseshen.<sym>) "<>") (cons vector (cons 0 ())) (intern (shen.<-out Parseshen.<sym>)))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)))

(defun shen.<sym> (V8093) (let Result (let Parseshen.<alpha> (shen.<alpha> V8093) (if (shen.parse-failure? Parseshen.<alpha>) (shen.parse-failure) (let Parseshen.<alphanums> (shen.<alphanums> Parseshen.<alpha>) (if (shen.parse-failure? Parseshen.<alphanums>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<alphanums>) (cn (shen.<-out Parseshen.<alpha>) (shen.<-out Parseshen.<alphanums>))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<alpha> (V8094) (let Result (if (shen.non-empty-stream? V8094) (let Byte (shen.hds V8094) (let News7781 (shen.tls V8094) (if (shen.alpha? Byte) (shen.comb (shen.in-> News7781) (n->string Byte)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.alpha? (V8095) (or (shen.lowercase? V8095) (or (shen.uppercase? V8095) (shen.misc? V8095))))

(defun shen.lowercase? (V8096) (and (>= V8096 97) (<= V8096 122)))

(defun shen.uppercase? (V8097) (and (>= V8097 65) (<= V8097 90)))

(defun shen.misc? (V8098) (element? V8098 (cons 61 (cons 45 (cons 42 (cons 47 (cons 43 (cons 95 (cons 63 (cons 36 (cons 33 (cons 64 (cons 126 (cons 46 (cons 62 (cons 60 (cons 38 (cons 37 (cons 39 (cons 35 (cons 96 ())))))))))))))))))))))

(defun shen.<alphanums> (V8099) (let Result (let Parseshen.<alphanum> (shen.<alphanum> V8099) (if (shen.parse-failure? Parseshen.<alphanum>) (shen.parse-failure) (let Parseshen.<alphanums> (shen.<alphanums> Parseshen.<alphanum>) (if (shen.parse-failure? Parseshen.<alphanums>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<alphanums>) (cn (shen.<-out Parseshen.<alphanum>) (shen.<-out Parseshen.<alphanums>))))))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V8099) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ""))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<alphanum> (V8100) (let Result (let Parseshen.<alpha> (shen.<alpha> V8100) (if (shen.parse-failure? Parseshen.<alpha>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<alpha>) (shen.<-out Parseshen.<alpha>)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<numeral> (shen.<numeral> V8100) (if (shen.parse-failure? Parseshen.<numeral>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<numeral>) (shen.<-out Parseshen.<numeral>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<numeral> (V8101) (let Result (if (shen.non-empty-stream? V8101) (let Byte (shen.hds V8101) (let News7785 (shen.tls V8101) (if (shen.digit? Byte) (shen.comb (shen.in-> News7785) (n->string Byte)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.digit? (V8102) (and (>= V8102 48) (<= V8102 57)))

(defun shen.<str> (V8103) (let Result (let Parseshen.<dbq> (shen.<dbq> V8103) (if (shen.parse-failure? Parseshen.<dbq>) (shen.parse-failure) (let Parseshen.<strcontents> (shen.<strcontents> Parseshen.<dbq>) (if (shen.parse-failure? Parseshen.<strcontents>) (shen.parse-failure) (let Parseshen.<dbq> (shen.<dbq> Parseshen.<strcontents>) (if (shen.parse-failure? Parseshen.<dbq>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<dbq>) (shen.<-out Parseshen.<strcontents>)))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<dbq> (V8104) (let Result (if (shen.=hd? V8104 34) (let News7788 (shen.tls V8104) (shen.comb (shen.in-> News7788) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<strcontents> (V8105) (let Result (let Parseshen.<strc> (shen.<strc> V8105) (if (shen.parse-failure? Parseshen.<strc>) (shen.parse-failure) (let Parseshen.<strcontents> (shen.<strcontents> Parseshen.<strc>) (if (shen.parse-failure? Parseshen.<strcontents>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<strcontents>) (cn (shen.<-out Parseshen.<strc>) (shen.<-out Parseshen.<strcontents>))))))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V8105) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ""))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<strc> (V8106) (let Result (let Parseshen.<control> (shen.<control> V8106) (if (shen.parse-failure? Parseshen.<control>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<control>) (shen.<-out Parseshen.<control>)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<notdbq> (shen.<notdbq> V8106) (if (shen.parse-failure? Parseshen.<notdbq>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<notdbq>) (shen.<-out Parseshen.<notdbq>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<control> (V8107) (let Result (let Parseshen.<lowC> (shen.<lowC> V8107) (if (shen.parse-failure? Parseshen.<lowC>) (shen.parse-failure) (let Parseshen.<hash> (shen.<hash> Parseshen.<lowC>) (if (shen.parse-failure? Parseshen.<hash>) (shen.parse-failure) (let Parseshen.<integer> (shen.<integer> Parseshen.<hash>) (if (shen.parse-failure? Parseshen.<integer>) (shen.parse-failure) (let Parseshen.<semicolon> (shen.<semicolon> Parseshen.<integer>) (if (shen.parse-failure? Parseshen.<semicolon>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<semicolon>) (n->string (shen.<-out Parseshen.<integer>))))))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<notdbq> (V8108) (let Result (if (shen.non-empty-stream? V8108) (let Byte (shen.hds V8108) (let News7793 (shen.tls V8108) (if (not (= Byte 34)) (shen.comb (shen.in-> News7793) (n->string Byte)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<lowC> (V8109) (let Result (if (shen.=hd? V8109 99) (let News7795 (shen.tls V8109) (shen.comb (shen.in-> News7795) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<hash> (V8110) (let Result (if (shen.=hd? V8110 35) (let News7797 (shen.tls V8110) (shen.comb (shen.in-> News7797) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<number> (V8111) (let Result (let Parseshen.<minus> (shen.<minus> V8111) (if (shen.parse-failure? Parseshen.<minus>) (shen.parse-failure) (let Parseshen.<number> (shen.<number> Parseshen.<minus>) (if (shen.parse-failure? Parseshen.<number>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<number>) (- 0 (shen.<-out Parseshen.<number>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<plus> (shen.<plus> V8111) (if (shen.parse-failure? Parseshen.<plus>) (shen.parse-failure) (let Parseshen.<number> (shen.<number> Parseshen.<plus>) (if (shen.parse-failure? Parseshen.<number>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<number>) (shen.<-out Parseshen.<number>)))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<e-number> (shen.<e-number> V8111) (if (shen.parse-failure? Parseshen.<e-number>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<e-number>) (shen.<-out Parseshen.<e-number>)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<float> (shen.<float> V8111) (if (shen.parse-failure? Parseshen.<float>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<float>) (shen.<-out Parseshen.<float>)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<integer> (shen.<integer> V8111) (if (shen.parse-failure? Parseshen.<integer>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<integer>) (shen.<-out Parseshen.<integer>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)) Result)) Result)))

(defun shen.<minus> (V8112) (let Result (if (shen.=hd? V8112 45) (let News7800 (shen.tls V8112) (shen.comb (shen.in-> News7800) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<plus> (V8113) (let Result (if (shen.=hd? V8113 43) (let News7802 (shen.tls V8113) (shen.comb (shen.in-> News7802) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<integer> (V8114) (let Result (let Parseshen.<digits> (shen.<digits> V8114) (if (shen.parse-failure? Parseshen.<digits>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<digits>) (shen.compute-integer (shen.<-out Parseshen.<digits>))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<digits> (V8115) (let Result (let Parseshen.<digit> (shen.<digit> V8115) (if (shen.parse-failure? Parseshen.<digit>) (shen.parse-failure) (let Parseshen.<digits> (shen.<digits> Parseshen.<digit>) (if (shen.parse-failure? Parseshen.<digits>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<digits>) (cons (shen.<-out Parseshen.<digit>) (shen.<-out Parseshen.<digits>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<digit> (shen.<digit> V8115) (if (shen.parse-failure? Parseshen.<digit>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<digit>) (cons (shen.<-out Parseshen.<digit>) ())))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<digit> (V8116) (let Result (if (shen.non-empty-stream? V8116) (let Byte (shen.hds V8116) (let News7806 (shen.tls V8116) (if (shen.digit? Byte) (shen.comb (shen.in-> News7806) (shen.byte->digit Byte)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.byte->digit (V8117) (- V8117 48))

(defun shen.compute-integer (V8118) (shen.compute-integer-h (reverse V8118) 0))

(defun shen.compute-integer-h (V8121 V8122) (cond ((= () V8121) 0) ((cons? V8121) (+ (* (shen.expt 10 V8122) (hd V8121)) (shen.compute-integer-h (tl V8121) (+ V8122 1)))) (true (shen.f-error shen.compute-integer-h))))

(defun shen.expt (V8125 V8126) (cond ((= 0 V8126) 1) ((> V8126 0) (* V8125 (shen.expt V8125 (- V8126 1)))) (true (/ (shen.expt V8125 (+ V8126 1)) V8125))))

(defun shen.<float> (V8127) (let Result (let Parseshen.<integer> (shen.<integer> V8127) (if (shen.parse-failure? Parseshen.<integer>) (shen.parse-failure) (let Parseshen.<stop> (shen.<stop> Parseshen.<integer>) (if (shen.parse-failure? Parseshen.<stop>) (shen.parse-failure) (let Parseshen.<fraction> (shen.<fraction> Parseshen.<stop>) (if (shen.parse-failure? Parseshen.<fraction>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<fraction>) (+ (shen.<-out Parseshen.<integer>) (shen.<-out Parseshen.<fraction>))))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<stop> (shen.<stop> V8127) (if (shen.parse-failure? Parseshen.<stop>) (shen.parse-failure) (let Parseshen.<fraction> (shen.<fraction> Parseshen.<stop>) (if (shen.parse-failure? Parseshen.<fraction>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<fraction>) (shen.<-out Parseshen.<fraction>)))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<stop> (V8128) (let Result (if (shen.=hd? V8128 46) (let News7809 (shen.tls V8128) (shen.comb (shen.in-> News7809) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<fraction> (V8129) (let Result (let Parseshen.<digits> (shen.<digits> V8129) (if (shen.parse-failure? Parseshen.<digits>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<digits>) (shen.compute-fraction (shen.<-out Parseshen.<digits>))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.compute-fraction (V8130) (shen.compute-fraction-h V8130 -1))

(defun shen.compute-fraction-h (V8133 V8134) (cond ((= () V8133) 0) ((cons? V8133) (+ (* (shen.expt 10 V8134) (hd V8133)) (shen.compute-fraction-h (tl V8133) (- V8134 1)))) (true (shen.f-error shen.compute-fraction-h))))

(defun shen.<e-number> (V8135) (let Result (let Parseshen.<float> (shen.<float> V8135) (if (shen.parse-failure? Parseshen.<float>) (shen.parse-failure) (let Parseshen.<lowE> (shen.<lowE> Parseshen.<float>) (if (shen.parse-failure? Parseshen.<lowE>) (shen.parse-failure) (let Parseshen.<log10> (shen.<log10> Parseshen.<lowE>) (if (shen.parse-failure? Parseshen.<log10>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<log10>) (shen.compute-E (shen.<-out Parseshen.<float>) (shen.<-out Parseshen.<log10>))))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<integer> (shen.<integer> V8135) (if (shen.parse-failure? Parseshen.<integer>) (shen.parse-failure) (let Parseshen.<lowE> (shen.<lowE> Parseshen.<integer>) (if (shen.parse-failure? Parseshen.<lowE>) (shen.parse-failure) (let Parseshen.<log10> (shen.<log10> Parseshen.<lowE>) (if (shen.parse-failure? Parseshen.<log10>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<log10>) (shen.compute-E (shen.<-out Parseshen.<integer>) (shen.<-out Parseshen.<log10>))))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<log10> (V8136) (let Result (let Parseshen.<plus> (shen.<plus> V8136) (if (shen.parse-failure? Parseshen.<plus>) (shen.parse-failure) (let Parseshen.<log10> (shen.<log10> Parseshen.<plus>) (if (shen.parse-failure? Parseshen.<log10>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<log10>) (shen.<-out Parseshen.<log10>)))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<minus> (shen.<minus> V8136) (if (shen.parse-failure? Parseshen.<minus>) (shen.parse-failure) (let Parseshen.<log10> (shen.<log10> Parseshen.<minus>) (if (shen.parse-failure? Parseshen.<log10>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<log10>) (- 0 (shen.<-out Parseshen.<log10>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<integer> (shen.<integer> V8136) (if (shen.parse-failure? Parseshen.<integer>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<integer>) (shen.<-out Parseshen.<integer>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)))

(defun shen.<lowE> (V8137) (let Result (if (shen.=hd? V8137 101) (let News7814 (shen.tls V8137) (shen.comb (shen.in-> News7814) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.compute-E (V8138 V8139) (* V8138 (shen.expt 10 V8139)))

(defun shen.<whitespaces> (V8140) (let Result (let Parseshen.<whitespace> (shen.<whitespace> V8140) (if (shen.parse-failure? Parseshen.<whitespace>) (shen.parse-failure) (let Parseshen.<whitespaces> (shen.<whitespaces> Parseshen.<whitespace>) (if (shen.parse-failure? Parseshen.<whitespaces>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<whitespaces>) shen.skip))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<whitespace> (shen.<whitespace> V8140) (if (shen.parse-failure? Parseshen.<whitespace>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<whitespace>) shen.skip))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<whitespace> (V8141) (let Result (if (shen.non-empty-stream? V8141) (let Byte (shen.hds V8141) (let News7817 (shen.tls V8141) (if (shen.whitespace? Byte) (shen.comb (shen.in-> News7817) shen.skip) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.whitespace? (V8144) (cond ((= 32 V8144) true) ((= 13 V8144) true) ((= 10 V8144) true) ((= 9 V8144) true) (true false)))

(defun shen.unpackage&macroexpand (V8145) (cond ((= () V8145) ()) ((and (cons? V8145) (shen.packaged? (hd V8145))) (shen.unpackage&macroexpand (append (shen.unpackage (hd V8145)) (tl V8145)))) ((cons? V8145) (let M (macroexpand (hd V8145)) (if (shen.packaged? M) (shen.unpackage&macroexpand (cons M (tl V8145))) (cons M (shen.unpackage&macroexpand (tl V8145)))))) (true (shen.f-error shen.unpackage&macroexpand))))

(defun shen.packaged? (V8148) (cond ((and (cons? V8148) (and (= package (hd V8148)) (and (cons? (tl V8148)) (cons? (tl (tl V8148)))))) true) (true false)))

(defun shen.unpackage (V8151) (cond ((and (cons? V8151) (and (= package (hd V8151)) (and (cons? (tl V8151)) (and (= null (hd (tl V8151))) (cons? (tl (tl V8151))))))) (tl (tl (tl V8151)))) ((and (cons? V8151) (and (= package (hd V8151)) (and (cons? (tl V8151)) (cons? (tl (tl V8151)))))) (let External! (eval (hd (tl (tl V8151)))) (let Package (shen.package-symbols (str (hd (tl V8151))) External! (tl (tl (tl V8151)))) (let RecordExternal (shen.record-external (hd (tl V8151)) External!) (let RecordInternal (shen.record-internal (hd (tl V8151)) External! (tl (tl (tl V8151)))) Package))))) (true (shen.f-error shen.unpackage))))

(defun shen.record-internal (V8152 V8153 V8154) (put V8152 shen.internal-symbols (shen.internal-symbols (str V8152) V8153 V8154) (value *property-vector*)))

(defun shen.internal-symbols (V8161 V8162 V8163) (cond ((cons? V8163) (union (shen.internal-symbols V8161 V8162 (hd V8163)) (shen.internal-symbols V8161 V8162 (tl V8163)))) ((shen.internal? V8163 V8161 V8162) (cons (shen.intern-in-package V8161 V8163) ())) (true ())))

(defun shen.record-external (V8164 V8165) (let External (trap-error (get V8164 shen.external-symbols (value *property-vector*)) (lambda E ())) (put V8164 shen.external-symbols (union V8165 External) (value *property-vector*))))

(defun shen.package-symbols (V8170 V8171 V8172) (cond ((cons? V8172) (map (lambda X (shen.package-symbols V8170 V8171 X)) V8172)) ((shen.internal? V8172 V8170 V8171) (shen.intern-in-package V8170 V8172)) (true V8172)))

(defun shen.intern-in-package (V8173 V8174) (intern (@s V8173 (@s "." (str V8174)))))

(defun shen.internal? (V8175 V8176 V8177) (and (not (element? V8175 V8177)) (and (not (shen.sng? V8175)) (and (not (shen.dbl? V8175)) (and (symbol? V8175) (and (not (shen.sysfunc? V8175)) (and (not (variable? V8175)) (and (not (shen.internal-to-shen? (str V8175))) (not (shen.internal-to-P? V8176 (str V8175)))))))))))

(defun shen.internal-to-shen? (V8182) (cond ((and (shen.+string? V8182) (and (= "s" (hdstr V8182)) (and (shen.+string? (tlstr V8182)) (and (= "h" (hdstr (tlstr V8182))) (and (shen.+string? (tlstr (tlstr V8182))) (and (= "e" (hdstr (tlstr (tlstr V8182)))) (and (shen.+string? (tlstr (tlstr (tlstr V8182)))) (and (= "n" (hdstr (tlstr (tlstr (tlstr V8182))))) (and (shen.+string? (tlstr (tlstr (tlstr (tlstr V8182))))) (= "." (hdstr (tlstr (tlstr (tlstr (tlstr V8182))))))))))))))) true) (true false)))

(defun shen.sysfunc? (V8183) (element? V8183 (get shen shen.external-symbols (value *property-vector*))))

(defun shen.internal-to-P? (V8191 V8192) (cond ((and (= "" V8191) (and (shen.+string? V8192) (= "." (hdstr V8192)))) true) ((and (shen.+string? V8191) (and (shen.+string? V8192) (= (hdstr V8191) (hdstr V8192)))) (shen.internal-to-P? (tlstr V8191) (tlstr V8192))) (true false)))

(defun shen.process-applications (V8195 V8196) (cond ((element? V8195 V8196) V8195) ((and (cons? V8195) (shen.non-application? (hd V8195))) (shen.special-case (hd V8195) V8195 V8196)) ((cons? V8195) (shen.process-application (map (lambda Y (shen.process-applications Y V8196)) V8195) V8196)) (true V8195)))

(defun shen.non-application? (V8199) (cond ((= define V8199) true) ((= defun V8199) true) ((= synonyms V8199) true) ((shen.special? V8199) true) ((shen.extraspecial? V8199) true) (true false)))

(defun shen.special-case (V8204 V8205 V8206) (cond ((and (= lambda V8204) (and (cons? V8205) (and (= lambda (hd V8205)) (and (cons? (tl V8205)) (and (cons? (tl (tl V8205))) (= () (tl (tl (tl V8205))))))))) (cons lambda (cons (hd (tl V8205)) (cons (shen.process-applications (hd (tl (tl V8205))) V8206) ())))) ((and (= let V8204) (and (cons? V8205) (and (= let (hd V8205)) (and (cons? (tl V8205)) (and (cons? (tl (tl V8205))) (and (cons? (tl (tl (tl V8205)))) (= () (tl (tl (tl (tl V8205))))))))))) (cons let (cons (hd (tl V8205)) (cons (shen.process-applications (hd (tl (tl V8205))) V8206) (cons (shen.process-applications (hd (tl (tl (tl V8205)))) V8206) ()))))) ((and (= defun V8204) (and (cons? V8205) (and (= defun (hd V8205)) (and (cons? (tl V8205)) (and (cons? (tl (tl V8205))) (and (cons? (tl (tl (tl V8205)))) (= () (tl (tl (tl (tl V8205))))))))))) V8205) ((and (= define V8204) (and (cons? V8205) (and (= define (hd V8205)) (and (cons? (tl V8205)) (and (cons? (tl (tl V8205))) (= { (hd (tl (tl V8205))))))))) (cons define (cons (hd (tl V8205)) (cons { (shen.process-after-type (hd (tl V8205)) (tl (tl (tl V8205))) V8206))))) ((and (= define V8204) (and (cons? V8205) (and (= define (hd V8205)) (cons? (tl V8205))))) (cons define (cons (hd (tl V8205)) (map (lambda Y (shen.process-applications Y V8206)) (tl (tl V8205)))))) ((= synonyms V8204) (cons synonyms V8205)) ((and (= type V8204) (and (cons? V8205) (and (= type (hd V8205)) (and (cons? (tl V8205)) (and (cons? (tl (tl V8205))) (= () (tl (tl (tl V8205))))))))) (cons type (cons (shen.process-applications (hd (tl V8205)) V8206) (tl (tl V8205))))) ((and (= input+ V8204) (and (cons? V8205) (and (= input+ (hd V8205)) (and (cons? (tl V8205)) (and (cons? (tl (tl V8205))) (= () (tl (tl (tl V8205))))))))) (cons input+ (cons (hd (tl V8205)) (cons (shen.process-applications (hd (tl (tl V8205))) V8206) ())))) ((and (cons? V8205) (shen.special? (hd V8205))) (cons (hd V8205) (map (lambda Y (shen.process-applications Y V8206)) (tl V8205)))) ((and (cons? V8205) (shen.extraspecial? (hd V8205))) V8205) (true (shen.f-error shen.special-case))))

(defun shen.process-after-type (V8209 V8210 V8211) (cond ((and (cons? V8210) (= } (hd V8210))) (cons } (map (lambda Y (shen.process-applications Y V8211)) (tl V8210)))) ((cons? V8210) (cons (hd V8210) (shen.process-after-type V8209 (tl V8210) V8211))) (true (simple-error (cn "missing } in " (shen.app V8209 "
" shen.a))))))

(defun shen.process-application (V8212 V8213) (cond ((cons? V8212) (let ArityF (arity (hd V8212)) (let N (length (tl V8212)) (if (element? V8212 V8213) V8212 (if (shen.shen-call? (hd V8212)) V8212 (if (shen.foreign? V8212) (shen.unpack-foreign V8212) (if (shen.fn-call? V8212) (shen.fn-call V8212) (if (shen.zero-place? V8212) V8212 (if (shen.undefined-f? (hd V8212) ArityF) (shen.simple-curry (cons (cons fn (cons (hd V8212) ())) (tl V8212))) (if (variable? (hd V8212)) (shen.simple-curry V8212) (if (shen.application? (hd V8212)) (shen.simple-curry V8212) (if (shen.partial-application*? (hd V8212) ArityF N) (shen.lambda-function V8212 (- ArityF N)) (if (shen.overapplication? (hd V8212) ArityF N) (shen.simple-curry (cons (cons fn (cons (hd V8212) ())) (tl V8212))) V8212))))))))))))) (true (shen.f-error shen.process-application))))

(defun shen.unpack-foreign (V8214) (cond ((and (cons? V8214) (and (cons? (hd V8214)) (and (= foreign (hd (hd V8214))) (and (cons? (tl (hd V8214))) (= () (tl (tl (hd V8214)))))))) (cons (hd (tl (hd V8214))) (tl V8214))) (true (shen.f-error shen.unpack-foreign))))

(defun shen.foreign? (V8217) (cond ((and (cons? V8217) (and (cons? (hd V8217)) (and (= foreign (hd (hd V8217))) (and (cons? (tl (hd V8217))) (= () (tl (tl (hd V8217)))))))) true) (true false)))

(defun shen.zero-place? (V8220) (cond ((and (cons? V8220) (= () (tl V8220))) true) (true false)))

(defun shen.shen-call? (V8221) (and (symbol? V8221) (shen.internal-to-shen? (str V8221))))

(defun shen.internal-to-shen? (V8226) (cond ((and (shen.+string? V8226) (and (= "s" (hdstr V8226)) (and (shen.+string? (tlstr V8226)) (and (= "h" (hdstr (tlstr V8226))) (and (shen.+string? (tlstr (tlstr V8226))) (and (= "e" (hdstr (tlstr (tlstr V8226)))) (and (shen.+string? (tlstr (tlstr (tlstr V8226)))) (and (= "n" (hdstr (tlstr (tlstr (tlstr V8226))))) (and (shen.+string? (tlstr (tlstr (tlstr (tlstr V8226))))) (= "." (hdstr (tlstr (tlstr (tlstr (tlstr V8226))))))))))))))) true) (true false)))

(defun shen.application? (V8231) (cond ((and (cons? V8231) (and (= protect (hd V8231)) (and (cons? (tl V8231)) (= () (tl (tl V8231)))))) false) ((and (cons? V8231) (and (= foreign (hd V8231)) (and (cons? (tl V8231)) (= () (tl (tl V8231)))))) false) (true (cons? V8231))))

(defun shen.undefined-f? (V8236 V8237) (cond ((= -1 V8237) (and (shen.lowercase-symbol? V8236) (not (element? V8236 (external shen))))) (true false)))

(defun shen.lowercase-symbol? (V8238) (and (symbol? V8238) (not (variable? V8238))))

(defun shen.simple-curry (V8239) (cond ((and (cons? V8239) (and (cons? (tl V8239)) (= () (tl (tl V8239))))) V8239) ((and (cons? V8239) (and (cons? (tl V8239)) (cons? (tl (tl V8239))))) (shen.simple-curry (cons (cons (hd V8239) (cons (hd (tl V8239)) ())) (tl (tl V8239))))) (true V8239)))

(defun function (V8240) (fn V8240))

(defun fn (V8241) (let LookUp (assoc V8241 (value shen.*lambdatable*)) (if (empty? LookUp) (simple-error (cn "fn: " (shen.app V8241 " is undefined
" shen.a))) (tl LookUp))))

(defun shen.fn-call? (V8244) (cond ((and (cons? V8244) (and (= fn (hd V8244)) (and (cons? (tl V8244)) (= () (tl (tl V8244)))))) true) ((and (cons? V8244) (and (= function (hd V8244)) (and (cons? (tl V8244)) (= () (tl (tl V8244)))))) true) (true false)))

(defun shen.fn-call (V8245) (cond ((and (cons? V8245) (and (= function (hd V8245)) (and (cons? (tl V8245)) (= () (tl (tl V8245)))))) (shen.fn-call (cons fn (tl V8245)))) ((and (cons? V8245) (and (= fn (hd V8245)) (and (cons? (tl V8245)) (= () (tl (tl V8245)))))) (let ArityF (arity (hd (tl V8245))) (if (= ArityF -1) V8245 (if (= ArityF 0) (simple-error "fn cannot be applied to a zero place function
") (shen.lambda-function (tl V8245) ArityF))))) (true (shen.f-error shen.fn-call))))

(defun shen.partial-application*? (V8246 V8247 V8248) (let Verdict (> V8247 V8248) (let Message (if (and Verdict (and (shen.loading?) (not (element? V8246 (cons + (cons - ())))))) (pr (cn "partial application of " (shen.app V8246 "
" shen.a)) (stoutput)) shen.skip) Verdict)))

(defun shen.loading? () (value shen.*loading?*))

(defun shen.overapplication? (V8253 V8254 V8255) (cond ((= -1 V8254) false) (true (let Verdict (< V8254 V8255) (let Message (if (and Verdict (shen.loading?)) (pr (shen.app V8253 (cn " might not like " (shen.app V8255 (cn " argument" (shen.app (if (= V8255 1) "" "s") "
" shen.a)) shen.a)) shen.a) (stoutput)) shen.skip) Verdict)))))

