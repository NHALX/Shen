(defun shen.shen->kl (V1566) (let W1567 (shen.shen->kl-h V1566) (shen.record-and-evaluate W1567)))

(defun shen.record-and-evaluate (V1568) (cond ((and (cons? V1568) (and (= defun (hd V1568)) (and (cons? (tl V1568)) (and (cons? (tl (tl V1568))) (and (cons? (tl (tl (tl V1568)))) (= () (tl (tl (tl (tl V1568)))))))))) (let W1569 (if (shen.sysfunc? (hd (tl V1568))) (simple-error (shen.app (hd (tl V1568)) " is not a legitimate function name
" shen.a)) shen.skip) (let W1570 (shen.store-arity (hd (tl V1568)) (length (hd (tl (tl V1568))))) (let W1571 (shen.record-kl (hd (tl V1568)) V1568) (let W1572 (eval-kl V1568) (shen.fn-print (hd (tl V1568)))))))) (true V1568)))

(defun shen.shen->kl-h (V1573) (cond ((and (cons? V1573) (and (= define (hd V1573)) (cons? (tl V1573)))) (shen.shendef->kldef (hd (tl V1573)) (tl (tl V1573)))) ((and (cons? V1573) (and (= defun (hd V1573)) (and (cons? (tl V1573)) (and (cons? (tl (tl V1573))) (and (cons? (tl (tl (tl V1573)))) (= () (tl (tl (tl (tl V1573)))))))))) V1573) ((and (cons? V1573) (and (= type (hd V1573)) (and (cons? (tl V1573)) (and (cons? (tl (tl V1573))) (= () (tl (tl (tl V1573)))))))) (cons type (cons (hd (tl V1573)) (cons (shen.rcons_form (hd (tl (tl V1573)))) ())))) ((and (cons? V1573) (and (= input+ (hd V1573)) (and (cons? (tl V1573)) (and (cons? (tl (tl V1573))) (= () (tl (tl (tl V1573)))))))) (cons input+ (cons (shen.rcons_form (hd (tl V1573))) (tl (tl V1573))))) ((cons? V1573) (map (lambda Z1574 (shen.shen->kl-h Z1574)) V1573)) (true V1573)))

(defun shen.shendef->kldef (V1575 V1576) (compile (lambda Z1577 (shen.<define> Z1577)) (cons V1575 V1576)))

(defun shen.<define> (V1578) (let W1579 (let W1580 (shen.<name> V1578) (if (shen.parse-failure? W1580) (shen.parse-failure) (if (shen.=hd? W1580 {) (let W1581 (shen.tls W1580) (let W1582 (shen.<signature> W1581) (if (shen.parse-failure? W1582) (shen.parse-failure) (if (shen.=hd? W1582 }) (let W1583 (shen.tls W1582) (let W1584 (shen.<rules> W1583) (if (shen.parse-failure? W1584) (shen.parse-failure) (shen.comb (shen.in-> W1584) (shen.shendef->kldef-h (shen.<-out W1580) (shen.<-out W1584)))))) (shen.parse-failure))))) (shen.parse-failure)))) (if (shen.parse-failure? W1579) (let W1585 (let W1586 (shen.<name> V1578) (if (shen.parse-failure? W1586) (shen.parse-failure) (let W1587 (shen.<rules> W1586) (if (shen.parse-failure? W1587) (shen.parse-failure) (shen.comb (shen.in-> W1587) (shen.shendef->kldef-h (shen.<-out W1586) (shen.<-out W1587))))))) (if (shen.parse-failure? W1585) (shen.parse-failure) W1585)) W1579)))

(defun shen.shendef->kldef-h (V1588 V1589) (let W1590 (map (lambda Z1591 (fst Z1591)) V1589) (let W1592 (shen.arity-chk V1588 W1590) (let W1593 (map (lambda Z1594 (shen.free-var-chk V1588 Z1594)) V1589) (let W1595 (shen.unprotect V1589) (let W1596 (shen.factorise-code (shen.compile-to-kl V1588 W1595 W1592)) W1596))))))

(defun shen.unprotect (V1597) (cond ((tuple? V1597) (@p (shen.unprotect (fst V1597)) (shen.unprotect (snd V1597)))) ((and (cons? V1597) (and (= protect (hd V1597)) (and (cons? (tl V1597)) (= () (tl (tl V1597)))))) (shen.unprotect (hd (tl V1597)))) ((cons? V1597) (map (lambda Z1598 (shen.unprotect Z1598)) V1597)) (true V1597)))

(defun shen.<name> (V1599) (let W1600 (if (shen.non-empty-stream? V1599) (let W1601 (shen.hds V1599) (let W1602 (shen.tls V1599) (shen.comb (shen.in-> W1602) (if (and (symbol? W1601) (not (variable? W1601))) W1601 (simple-error (shen.app W1601 " is not a legitimate function name.
" shen.a)))))) (shen.parse-failure)) (if (shen.parse-failure? W1600) (shen.parse-failure) W1600)))

(defun shen.<signature> (V1603) (let W1604 (if (shen.non-empty-stream? V1603) (let W1605 (shen.hds V1603) (let W1606 (shen.tls V1603) (let W1607 (shen.<signature> W1606) (if (shen.parse-failure? W1607) (shen.parse-failure) (if (not (element? W1605 (cons { (cons } ())))) (shen.comb (shen.in-> W1607) (cons W1605 (shen.<-out W1607))) (shen.parse-failure)))))) (shen.parse-failure)) (if (shen.parse-failure? W1604) (let W1608 (let W1609 (<e> V1603) (if (shen.parse-failure? W1609) (shen.parse-failure) (shen.comb (shen.in-> W1609) ()))) (if (shen.parse-failure? W1608) (shen.parse-failure) W1608)) W1604)))

(defun shen.<rules> (V1610) (let W1611 (let W1612 (shen.<rule> V1610) (if (shen.parse-failure? W1612) (shen.parse-failure) (let W1613 (shen.<rules> W1612) (if (shen.parse-failure? W1613) (shen.parse-failure) (shen.comb (shen.in-> W1613) (cons (shen.linearise (shen.<-out W1612)) (shen.<-out W1613))))))) (if (shen.parse-failure? W1611) (let W1614 (let W1615 (<!> V1610) (if (shen.parse-failure? W1615) (shen.parse-failure) (shen.comb (shen.in-> W1615) (if (empty? (shen.<-out W1615)) () (simple-error (cn "Shen syntax error here:
 " (shen.app (shen.<-out W1615) "
 ..." shen.r))))))) (if (shen.parse-failure? W1614) (shen.parse-failure) W1614)) W1611)))

(defun shen.linearise (V1618) (cond ((tuple? V1618) (shen.linearise-h (fst V1618) (fst V1618) () (snd V1618))) (true (simple-error "implementation error in shen.linearise"))))

(defun shen.linearise-h (V1631 V1632 V1633 V1634) (cond ((= () V1631) (@p V1632 V1634)) ((and (cons? V1631) (cons? (hd V1631))) (shen.linearise-h (append (hd V1631) (tl V1631)) V1632 V1633 V1634)) ((and (cons? V1631) (variable? (hd V1631))) (if (element? (hd V1631) V1633) (let W1635 (gensym V) (shen.linearise-h (tl V1631) (shen.rep-X (hd V1631) W1635 V1632) V1633 (cons where (cons (cons = (cons W1635 (cons (hd V1631) ()))) (cons V1634 ()))))) (shen.linearise-h (tl V1631) V1632 (cons (hd V1631) V1633) V1634))) ((cons? V1631) (shen.linearise-h (tl V1631) V1632 V1633 V1634)) (true (simple-error "implementation error in shen.linearise-h"))))

(defun shen.<rule> (V1636) (let W1637 (let W1638 (shen.<patterns> V1636) (if (shen.parse-failure? W1638) (shen.parse-failure) (if (shen.=hd? W1638 ->) (let W1639 (shen.tls W1638) (if (shen.non-empty-stream? W1639) (let W1640 (shen.hds W1639) (let W1641 (shen.tls W1639) (if (shen.=hd? W1641 where) (let W1642 (shen.tls W1641) (if (shen.non-empty-stream? W1642) (let W1643 (shen.hds W1642) (let W1644 (shen.tls W1642) (shen.comb (shen.in-> W1644) (@p (shen.<-out W1638) (cons where (cons W1643 (cons W1640 ()))))))) (shen.parse-failure))) (shen.parse-failure)))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? W1637) (let W1645 (let W1646 (shen.<patterns> V1636) (if (shen.parse-failure? W1646) (shen.parse-failure) (if (shen.=hd? W1646 ->) (let W1647 (shen.tls W1646) (if (shen.non-empty-stream? W1647) (let W1648 (shen.hds W1647) (let W1649 (shen.tls W1647) (shen.comb (shen.in-> W1649) (@p (shen.<-out W1646) W1648)))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? W1645) (let W1650 (let W1651 (shen.<patterns> V1636) (if (shen.parse-failure? W1651) (shen.parse-failure) (if (shen.=hd? W1651 <-) (let W1652 (shen.tls W1651) (if (shen.non-empty-stream? W1652) (let W1653 (shen.hds W1652) (let W1654 (shen.tls W1652) (if (shen.=hd? W1654 where) (let W1655 (shen.tls W1654) (if (shen.non-empty-stream? W1655) (let W1656 (shen.hds W1655) (let W1657 (shen.tls W1655) (shen.comb (shen.in-> W1657) (@p (shen.<-out W1651) (cons where (cons W1656 (cons (cons shen.choicepoint! (cons W1653 ())) ()))))))) (shen.parse-failure))) (shen.parse-failure)))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? W1650) (let W1658 (let W1659 (shen.<patterns> V1636) (if (shen.parse-failure? W1659) (shen.parse-failure) (if (shen.=hd? W1659 <-) (let W1660 (shen.tls W1659) (if (shen.non-empty-stream? W1660) (let W1661 (shen.hds W1660) (let W1662 (shen.tls W1660) (shen.comb (shen.in-> W1662) (@p (shen.<-out W1659) (cons shen.choicepoint! (cons W1661 ())))))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? W1658) (shen.parse-failure) W1658)) W1650)) W1645)) W1637)))

(defun shen.<patterns> (V1663) (let W1664 (let W1665 (shen.<pattern> V1663) (if (shen.parse-failure? W1665) (shen.parse-failure) (let W1666 (shen.<patterns> W1665) (if (shen.parse-failure? W1666) (shen.parse-failure) (shen.comb (shen.in-> W1666) (cons (shen.<-out W1665) (shen.<-out W1666))))))) (if (shen.parse-failure? W1664) (let W1667 (let W1668 (<e> V1663) (if (shen.parse-failure? W1668) (shen.parse-failure) (shen.comb (shen.in-> W1668) ()))) (if (shen.parse-failure? W1667) (shen.parse-failure) W1667)) W1664)))

(defun shen.<pattern> (V1669) (let W1670 (if (shen.ccons? V1669) (let W1671 (shen.comb (shen.hds V1669) (shen.<-out V1669)) (let W1672 (shen.<constructor> W1671) (if (shen.parse-failure? W1672) (shen.parse-failure) (let W1673 (shen.<pattern1> W1672) (if (shen.parse-failure? W1673) (shen.parse-failure) (let W1674 (shen.<pattern2> W1673) (if (shen.parse-failure? W1674) (shen.parse-failure) (let W1675 (shen.<end> W1674) (if (shen.parse-failure? W1675) (shen.parse-failure) (shen.comb (shen.in-> (shen.tlstream V1669)) (cons (shen.<-out W1672) (cons (shen.<-out W1673) (cons (shen.<-out W1674) ()))))))))))))) (shen.parse-failure)) (if (shen.parse-failure? W1670) (let W1676 (if (shen.ccons? V1669) (let W1677 (shen.comb (shen.hds V1669) (shen.<-out V1669)) (if (shen.=hd? W1677 vector) (let W1678 (shen.tls W1677) (if (shen.=hd? W1678 0) (let W1679 (shen.tls W1678) (let W1680 (shen.<end> W1679) (if (shen.parse-failure? W1680) (shen.parse-failure) (shen.comb (shen.in-> (shen.tlstream V1669)) (cons vector (cons 0 ())))))) (shen.parse-failure))) (shen.parse-failure))) (shen.parse-failure)) (if (shen.parse-failure? W1676) (let W1681 (if (shen.non-empty-stream? V1669) (let W1682 (shen.hds V1669) (let W1683 (shen.tls V1669) (if (cons? W1682) (shen.comb (shen.in-> W1683) (shen.constructor-error W1682)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W1681) (let W1684 (let W1685 (shen.<simple-pattern> V1669) (if (shen.parse-failure? W1685) (shen.parse-failure) (shen.comb (shen.in-> W1685) (shen.<-out W1685)))) (if (shen.parse-failure? W1684) (shen.parse-failure) W1684)) W1681)) W1676)) W1670)))

(defun shen.<constructor> (V1686) (let W1687 (if (shen.non-empty-stream? V1686) (let W1688 (shen.hds V1686) (let W1689 (shen.tls V1686) (if (shen.constructor? W1688) (shen.comb (shen.in-> W1689) W1688) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W1687) (shen.parse-failure) W1687)))

(defun shen.constructor? (V1690) (element? V1690 (cons cons (cons @p (cons @s (cons @v ()))))))

(defun shen.constructor-error (V1691) (simple-error (shen.app V1691 " is not a legitimate constructor
" shen.r)))

(defun shen.<simple-pattern> (V1692) (let W1693 (if (shen.non-empty-stream? V1692) (let W1694 (shen.hds V1692) (let W1695 (shen.tls V1692) (if (= W1694 _) (shen.comb (shen.in-> W1695) (gensym Y)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W1693) (let W1696 (if (shen.non-empty-stream? V1692) (let W1697 (shen.hds V1692) (let W1698 (shen.tls V1692) (if (not (element? W1697 (cons -> (cons <- ())))) (shen.comb (shen.in-> W1698) W1697) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W1696) (shen.parse-failure) W1696)) W1693)))

(defun shen.<pattern1> (V1699) (let W1700 (let W1701 (shen.<pattern> V1699) (if (shen.parse-failure? W1701) (shen.parse-failure) (shen.comb (shen.in-> W1701) (shen.<-out W1701)))) (if (shen.parse-failure? W1700) (shen.parse-failure) W1700)))

(defun shen.<pattern2> (V1702) (let W1703 (let W1704 (shen.<pattern> V1702) (if (shen.parse-failure? W1704) (shen.parse-failure) (shen.comb (shen.in-> W1704) (shen.<-out W1704)))) (if (shen.parse-failure? W1703) (shen.parse-failure) W1703)))

(defun shen.fn-print (V1705) (let W1706 (absvector 2) (let W1707 (address-> W1706 0 shen.printF) (let W1708 (address-> W1707 1 (@s "(" (@s "f" (@s "n" (@s " " (@s (str V1705) ")")))))) W1708))))

(defun shen.printF (V1709) (<-address V1709 1))

(defun shen.arity-chk (V1714 V1715) (cond ((and (cons? V1715) (= () (tl V1715))) (length (hd V1715))) ((and (cons? V1715) (and (cons? (tl V1715)) (= (length (hd V1715)) (length (hd (tl V1715)))))) (shen.arity-chk V1714 (tl V1715))) (true (simple-error (cn "arity error in " (shen.app V1714 "
" shen.a))))))

(defun shen.free-var-chk (V1716 V1717) (cond ((tuple? V1717) (shen.free-variable-error-message V1716 (shen.find-free-vars (shen.extract-vars (fst V1717)) (snd V1717)))) (true (shen.f-error shen.free-var-chk))))

(defun shen.free-variable-error-message (V1718 V1719) (if (empty? V1719) shen.skip (do (pr (cn "free variables in " (shen.app V1718 ":" shen.a)) (stoutput)) (do (map (lambda Z1720 (pr (cn " " (shen.app Z1720 "" shen.a)) (stoutput))) V1719) (do (nl 1) (abort))))))

(defun shen.extract-vars (V1723) (cond ((variable? V1723) (cons V1723 ())) ((cons? V1723) (union (shen.extract-vars (hd V1723)) (shen.extract-vars (tl V1723)))) (true ())))

(defun shen.find-free-vars (V1728 V1729) (cond ((and (cons? V1729) (and (= protect (hd V1729)) (and (cons? (tl V1729)) (= () (tl (tl V1729)))))) ()) ((and (cons? V1729) (and (= let (hd V1729)) (and (cons? (tl V1729)) (and (cons? (tl (tl V1729))) (and (cons? (tl (tl (tl V1729)))) (= () (tl (tl (tl (tl V1729)))))))))) (union (shen.find-free-vars V1728 (hd (tl (tl V1729)))) (shen.find-free-vars (cons (hd (tl V1729)) V1728) (hd (tl (tl (tl V1729))))))) ((and (cons? V1729) (and (= lambda (hd V1729)) (and (cons? (tl V1729)) (and (cons? (tl (tl V1729))) (= () (tl (tl (tl V1729)))))))) (shen.find-free-vars (cons (hd (tl V1729)) V1728) (hd (tl (tl V1729))))) ((cons? V1729) (union (shen.find-free-vars V1728 (hd V1729)) (shen.find-free-vars V1728 (tl V1729)))) ((shen.free-variable? V1729 V1728) (cons V1729 ())) (true ())))

(defun shen.free-variable? (V1730 V1731) (and (variable? V1730) (not (element? V1730 V1731))))

(defun shen.record-kl (V1732 V1733) (put V1732 shen.source V1733 (value *property-vector*)))

(defun shen.compile-to-kl (V1734 V1735 V1736) (let W1737 (shen.parameters V1736) (let W1738 (shen.scan-body V1734 (shen.kl-body V1735 W1737)) (let W1739 (cons defun (cons V1734 (cons W1737 (cons (shen.cond-form W1738) ())))) W1739))))

(defun shen.parameters (V1740) (cond ((= 0 V1740) ()) (true (cons (gensym V) (shen.parameters (- V1740 1))))))

(defun shen.cond-form (V1743) (cond ((and (cons? V1743) (and (cons? (hd V1743)) (and (= true (hd (hd V1743))) (and (cons? (tl (hd V1743))) (= () (tl (tl (hd V1743)))))))) (hd (tl (hd V1743)))) (true (cons cond V1743))))

(defun shen.scan-body (V1752 V1753) (cond ((= () V1753) (cons (cons true (cons (cons shen.f-error (cons V1752 ())) ())) ())) ((and (cons? V1753) (shen.choicepoint? (hd V1753))) (shen.choicepoint V1752 (gensym Freeze) (gensym Result) (hd V1753) (tl V1753))) ((and (cons? V1753) (and (cons? (hd V1753)) (and (= true (hd (hd V1753))) (and (cons? (tl (hd V1753))) (= () (tl (tl (hd V1753)))))))) (cons (hd V1753) ())) ((cons? V1753) (cons (hd V1753) (shen.scan-body V1752 (tl V1753)))) (true (simple-error "implementation error in shen.scan-body"))))

(defun shen.choicepoint? (V1760) (cond ((and (cons? V1760) (and (cons? (tl V1760)) (and (cons? (hd (tl V1760))) (and (= shen.choicepoint! (hd (hd (tl V1760)))) (and (cons? (tl (hd (tl V1760)))) (and (= () (tl (tl (hd (tl V1760))))) (= () (tl (tl V1760))))))))) true) (true false)))

(defun shen.choicepoint (V1776 V1777 V1778 V1779 V1780) (cond ((and (cons? V1779) (and (cons? (tl V1779)) (and (cons? (hd (tl V1779))) (and (cons? (tl (hd (tl V1779)))) (and (cons? (hd (tl (hd (tl V1779))))) (and (= fail-if (hd (hd (tl (hd (tl V1779)))))) (and (cons? (tl (hd (tl (hd (tl V1779)))))) (and (cons? (tl (tl (hd (tl (hd (tl V1779))))))) (and (= () (tl (tl (tl (hd (tl (hd (tl V1779)))))))) (and (= () (tl (tl (hd (tl V1779))))) (and (= () (tl (tl V1779))) (= V1776 (hd (tl (hd (tl (hd (tl V1779)))))))))))))))))) (cons (cons true (cons (cons let (cons V1777 (cons (cons freeze (cons (cons cond (shen.scan-body (hd (tl (hd (tl (hd (tl V1779)))))) V1780)) ())) (cons (cons if (cons (hd V1779) (cons (cons let (cons V1778 (cons (hd (tl (tl (hd (tl (hd (tl V1779))))))) (cons (cons if (cons (cons (hd (tl (hd (tl (hd (tl V1779)))))) (cons V1778 ())) (cons (cons thaw (cons V1777 ())) (cons V1778 ())))) ())))) (cons (cons thaw (cons V1777 ())) ())))) ())))) ())) ())) ((and (cons? V1779) (and (cons? (tl V1779)) (and (cons? (hd (tl V1779))) (and (cons? (tl (hd (tl V1779)))) (and (= () (tl (tl (hd (tl V1779))))) (= () (tl (tl V1779)))))))) (cons (cons true (cons (cons let (cons V1777 (cons (cons freeze (cons (cons cond (shen.scan-body V1776 V1780)) ())) (cons (cons if (cons (hd V1779) (cons (cons let (cons V1778 (cons (hd (tl (hd (tl V1779)))) (cons (cons if (cons (cons = (cons V1778 (cons (cons fail ()) ()))) (cons (cons thaw (cons V1777 ())) (cons V1778 ())))) ())))) (cons (cons thaw (cons V1777 ())) ())))) ())))) ())) ())) (true (simple-error "implementation error in shen.choicepoint"))))

(defun shen.rep-X (V1782 V1783 V1784) (cond ((= V1782 V1784) V1783) ((cons? V1784) (let W1785 (shen.rep-X V1782 V1783 (hd V1784)) (if (= W1785 (hd V1784)) (cons (hd V1784) (shen.rep-X V1782 V1783 (tl V1784))) (cons W1785 (tl V1784))))) (true V1784)))

(defun shen.kl-body (V1786 V1787) (map (lambda Z1788 (shen.triple-stack () (fst Z1788) V1787 (shen.alpha-convert (snd Z1788)))) V1786))

(defun shen.alpha-convert (V1789) (cond ((and (cons? V1789) (and (= lambda (hd V1789)) (and (cons? (tl V1789)) (and (cons? (tl (tl V1789))) (= () (tl (tl (tl V1789)))))))) (let W1790 (gensym Z) (let W1791 (cons lambda (cons W1790 (cons (shen.beta (hd (tl V1789)) W1790 (hd (tl (tl V1789)))) ()))) (map (lambda Z1792 (shen.alpha-convert Z1792)) W1791)))) ((and (cons? V1789) (and (= let (hd V1789)) (and (cons? (tl V1789)) (and (cons? (tl (tl V1789))) (and (cons? (tl (tl (tl V1789)))) (= () (tl (tl (tl (tl V1789)))))))))) (let W1793 (gensym W) (let W1794 (cons let (cons W1793 (cons (hd (tl (tl V1789))) (cons (shen.beta (hd (tl V1789)) W1793 (hd (tl (tl (tl V1789))))) ())))) (map (lambda Z1795 (shen.alpha-convert Z1795)) W1794)))) ((cons? V1789) (map (lambda Z1796 (shen.alpha-convert Z1796)) V1789)) (true V1789)))

(defun shen.triple-stack (V1805 V1806 V1807 V1808) (cond ((and (= () V1806) (and (= () V1807) (and (cons? V1808) (and (= where (hd V1808)) (and (cons? (tl V1808)) (and (cons? (tl (tl V1808))) (= () (tl (tl (tl V1808)))))))))) (shen.triple-stack (cons (hd (tl V1808)) V1805) () () (hd (tl (tl V1808))))) ((and (= () V1806) (= () V1807)) (cons (shen.rectify-test (reverse V1805)) (cons V1808 ()))) ((and (cons? V1806) (and (cons? V1807) (variable? (hd V1806)))) (shen.triple-stack V1805 (tl V1806) (tl V1807) (shen.beta (hd V1806) (hd V1807) V1808))) ((and (cons? V1806) (and (cons? (hd V1806)) (and (cons? (tl (hd V1806))) (and (cons? (tl (tl (hd V1806)))) (and (= () (tl (tl (tl (hd V1806))))) (cons? V1807)))))) (shen.triple-stack (cons (cons (shen.op-test (hd (hd V1806))) (cons (hd V1807) ())) V1805) (cons (hd (tl (hd V1806))) (cons (hd (tl (tl (hd V1806)))) (tl V1806))) (cons (cons (shen.op1 (hd (hd V1806))) (cons (hd V1807) ())) (cons (cons (shen.op2 (hd (hd V1806))) (cons (hd V1807) ())) (tl V1807))) (shen.beta (hd V1806) (hd V1807) V1808))) ((and (cons? V1806) (cons? V1807)) (shen.triple-stack (cons (cons = (cons (hd V1806) (cons (hd V1807) ()))) V1805) (tl V1806) (tl V1807) V1808)) (true (simple-error "implementation error in shen.triple-stack"))))

(defun shen.rectify-test (V1811) (cond ((= () V1811) true) ((and (cons? V1811) (= () (tl V1811))) (hd V1811)) ((and (cons? V1811) (cons? (tl V1811))) (cons and (cons (hd V1811) (cons (shen.rectify-test (tl V1811)) ())))) (true (simple-error "implementation error in shen.rectify-test"))))

(defun shen.beta (V1821 V1822 V1823) (cond ((= V1821 V1823) V1822) ((and (cons? V1823) (and (= lambda (hd V1823)) (and (cons? (tl V1823)) (and (cons? (tl (tl V1823))) (and (= () (tl (tl (tl V1823)))) (= V1821 (hd (tl V1823)))))))) V1823) ((and (cons? V1823) (and (= let (hd V1823)) (and (cons? (tl V1823)) (and (cons? (tl (tl V1823))) (and (cons? (tl (tl (tl V1823)))) (and (= () (tl (tl (tl (tl V1823))))) (= V1821 (hd (tl V1823))))))))) (cons let (cons (hd (tl V1823)) (cons (shen.beta (hd (tl V1823)) V1822 (hd (tl (tl V1823)))) (tl (tl (tl V1823))))))) ((cons? V1823) (map (lambda Z1824 (shen.beta V1821 V1822 Z1824)) V1823)) (true V1823)))

(defun shen.op1 (V1827) (cond ((= cons V1827) hd) ((= @s V1827) hdstr) ((= @p V1827) fst) ((= @v V1827) hdv) (true (simple-error "implementation error in shen.op1"))))

(defun shen.op2 (V1830) (cond ((= cons V1830) tl) ((= @s V1830) tlstr) ((= @p V1830) snd) ((= @v V1830) tlv) (true (simple-error "implementation error in shen.op2"))))

(defun shen.op-test (V1833) (cond ((= cons V1833) cons?) ((= @s V1833) shen.+string?) ((= @p V1833) tuple?) ((= @v V1833) shen.+vector?) (true (simple-error "implementation error in shen.op-test"))))

(defun shen.+string? (V1834) (cond ((= "" V1834) false) (true (string? V1834))))

(defun shen.+vector? (V1835) (cond ((= V1835 (vector 0)) false) (true (vector? V1835))))

(defun factorise (V1838) (cond ((= + V1838) (set shen.*factorise?* true)) ((= - V1838) (set shen.*factorise?* false)) (true (simple-error "factorise expects a + or a -
"))))

(defun shen.factorise-code (V1839) (cond ((and (cons? V1839) (and (= defun (hd V1839)) (and (cons? (tl V1839)) (and (cons? (tl (tl V1839))) (and (cons? (tl (tl (tl V1839)))) (and (cons? (hd (tl (tl (tl V1839))))) (and (= cond (hd (hd (tl (tl (tl V1839)))))) (and (= () (tl (tl (tl (tl V1839))))) (value shen.*factorise?*))))))))) (cons defun (cons (hd (tl V1839)) (cons (hd (tl (tl V1839))) (cons (shen.vertical (hd (tl (tl V1839))) (tl (hd (tl (tl (tl V1839))))) (cons shen.f-error (cons (hd (tl V1839)) ()))) ()))))) (true V1839)))

(defun shen.vertical (V1852 V1853 V1854) (cond ((and (cons? V1853) (and (cons? (hd V1853)) (and (= true (hd (hd V1853))) (and (cons? (tl (hd V1853))) (= () (tl (tl (hd V1853)))))))) (hd (tl (hd V1853)))) ((= () V1853) V1854) ((and (cons? V1853) (and (cons? (hd V1853)) (and (cons? (hd (hd V1853))) (and (= and (hd (hd (hd V1853)))) (and (cons? (tl (hd (hd V1853)))) (and (cons? (tl (tl (hd (hd V1853))))) (and (= () (tl (tl (tl (hd (hd V1853)))))) (and (cons? (tl (hd V1853))) (= () (tl (tl (hd V1853)))))))))))) (let W1855 (shen.split-cases (hd (tl (hd (hd V1853)))) V1853 ()) (shen.branch (hd (tl (hd (hd V1853)))) V1852 W1855 V1854))) ((and (cons? V1853) (and (cons? (hd V1853)) (and (cons? (tl (hd V1853))) (= () (tl (tl (hd V1853))))))) (cons if (cons (hd (hd V1853)) (cons (hd (tl (hd V1853))) (cons (shen.vertical V1852 (tl V1853) V1854) ()))))) (true (simple-error "implementation error in shen.vertical"))))

(defun shen.split-cases (V1860 V1861 V1862) (cond ((and (cons? V1861) (and (cons? (hd V1861)) (and (cons? (hd (hd V1861))) (and (= and (hd (hd (hd V1861)))) (and (cons? (tl (hd (hd V1861)))) (and (cons? (tl (tl (hd (hd V1861))))) (and (= () (tl (tl (tl (hd (hd V1861)))))) (and (cons? (tl (hd V1861))) (and (= () (tl (tl (hd V1861)))) (= V1860 (hd (tl (hd (hd V1861)))))))))))))) (shen.split-cases (hd (tl (hd (hd V1861)))) (tl V1861) (cons (cons (hd (tl (tl (hd (hd V1861))))) (tl (hd V1861))) V1862))) ((and (cons? V1861) (and (cons? (hd V1861)) (and (cons? (tl (hd V1861))) (and (= () (tl (tl (hd V1861)))) (= V1860 (hd (hd V1861))))))) (shen.split-cases (hd (hd V1861)) (tl V1861) (cons (cons true (tl (hd V1861))) V1862))) (true (cons (reverse V1862) (cons V1861 ())))))

(defun shen.branch (V1863 V1864 V1865 V1866) (cond ((and (cons? V1865) (and (cons? (tl V1865)) (= () (tl (tl V1865))))) (let W1867 (shen.else V1864 (hd (tl V1865)) V1866) (let W1868 (shen.then V1863 V1864 (hd V1865) W1867) (cons if (cons V1863 (cons W1868 (cons W1867 ()))))))) (true (shen.f-error shen.branch))))

(defun shen.else (V1869 V1870 V1871) (let W1872 (shen.vertical V1869 V1870 V1871) (if (shen.inline? W1872) W1872 (shen.procedure-call V1869 W1872))))

(defun shen.procedure-call (V1873 V1874) (let W1875 (gensym shen.else) (let W1876 (shen.remove-if-unused V1873 V1874) (let W1877 (cons defun (cons W1875 (cons W1876 (cons V1874 ())))) (let W1878 (eval-kl W1877) (let W1879 (shen.record-kl W1875 W1877) (cons W1875 W1876)))))))

(defun shen.remove-if-unused (V1886 V1887) (cond ((= () V1886) ()) ((cons? V1886) (if (shen.occurs? (hd V1886) V1887) (cons (hd V1886) (shen.remove-if-unused (tl V1886) V1887)) (shen.remove-if-unused (tl V1886) V1887))) (true (simple-error "implementation error in shen.remove-if-unused"))))

(defun shen.then (V1888 V1889 V1890 V1891) (shen.horizontal (shen.selectors V1888 V1890) V1889 V1890 V1891))

(defun shen.horizontal (V1900 V1901 V1902 V1903) (cond ((= () V1900) (shen.vertical V1901 V1902 V1903)) ((cons? V1900) (let W1904 (gensym V) (cons let (cons W1904 (cons (hd V1900) (cons (shen.horizontal (tl V1900) (cons W1904 V1901) (subst W1904 (hd V1900) V1902) V1903) ())))))) (true (simple-error "implementation error in shen.horizontal"))))

(defun shen.selectors (V1909 V1910) (cond ((and (cons? V1909) (and (cons? (tl V1909)) (and (= () (tl (tl V1909))) (shen.constructor? (shen.op (hd V1909)))))) (let W1911 (shen.op (hd V1909)) (let W1912 (cons (shen.op1 W1911) (tl V1909)) (let W1913 (cons (shen.op2 W1911) (tl V1909)) (let W1914 (shen.rpted? W1912 V1910) (let W1915 (shen.rpted? W1913 V1910) (if (and W1914 W1915) (cons W1912 (cons W1913 ())) (if W1914 (cons W1912 ()) (if W1915 (cons W1913 ()) ()))))))))) (true ())))

(defun shen.rpted? (V1916 V1917) (> (occurrences V1916 V1917) 1))

(defun shen.inline? (V1918) (cond ((cons? V1918) (and (atom? (hd V1918)) (shen.inline? (tl V1918)))) (true (atom? V1918))))

(defun shen.op (V1921) (cond ((= cons? V1921) cons) ((= shen.+string? V1921) @s) ((= shen.+vector? V1921) @v) ((= tuple? V1921) @p) (true shen.skip)))

