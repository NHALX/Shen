(defun shen.shen->kl (V6591) (let KL (shen.shen->kl-h V6591) (shen.record-and-evaluate KL)))

(defun shen.record-and-evaluate (V6592) (cond ((and (cons? V6592) (and (= defun (hd V6592)) (and (cons? (tl V6592)) (and (cons? (tl (tl V6592))) (and (cons? (tl (tl (tl V6592)))) (= () (tl (tl (tl (tl V6592)))))))))) (let SysfuncChk (if (shen.sysfunc? (hd (tl V6592))) (simple-error (shen.app (hd (tl V6592)) " is not a legitimate function name
" shen.a)) shen.skip) (let Arity (shen.store-arity (hd (tl V6592)) (length (hd (tl (tl V6592))))) (let Record (shen.record-kl (hd (tl V6592)) V6592) (let Eval (eval-kl V6592) (shen.fn-print (hd (tl V6592)))))))) (true V6592)))

(defun shen.shen->kl-h (V6593) (cond ((and (cons? V6593) (and (= define (hd V6593)) (cons? (tl V6593)))) (shen.shendef->kldef (hd (tl V6593)) (tl (tl V6593)))) ((and (cons? V6593) (and (= defun (hd V6593)) (and (cons? (tl V6593)) (and (cons? (tl (tl V6593))) (and (cons? (tl (tl (tl V6593)))) (= () (tl (tl (tl (tl V6593)))))))))) V6593) ((and (cons? V6593) (and (= type (hd V6593)) (and (cons? (tl V6593)) (and (cons? (tl (tl V6593))) (= () (tl (tl (tl V6593)))))))) (cons type (cons (hd (tl V6593)) (cons (shen.rcons_form (hd (tl (tl V6593)))) ())))) ((and (cons? V6593) (and (= input+ (hd V6593)) (and (cons? (tl V6593)) (and (cons? (tl (tl V6593))) (= () (tl (tl (tl V6593)))))))) (cons input+ (cons (shen.rcons_form (hd (tl V6593))) (tl (tl V6593))))) ((cons? V6593) (map (lambda Z (shen.shen->kl-h Z)) V6593)) (true V6593)))

(defun shen.shendef->kldef (V6594 V6595) (compile (lambda X (shen.<define> X)) (cons V6594 V6595)))

(defun shen.<define> (V6596) (let Result (let Parseshen.<name> (shen.<name> V6596) (if (shen.parse-failure? Parseshen.<name>) (shen.parse-failure) (if (shen.=hd? Parseshen.<name> {) (let News6455 (shen.tls Parseshen.<name>) (let Parseshen.<signature> (shen.<signature> News6455) (if (shen.parse-failure? Parseshen.<signature>) (shen.parse-failure) (if (shen.=hd? Parseshen.<signature> }) (let News6456 (shen.tls Parseshen.<signature>) (let Parseshen.<rules> (shen.<rules> News6456) (if (shen.parse-failure? Parseshen.<rules>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<rules>) (shen.shendef->kldef-h (shen.<-out Parseshen.<name>) (shen.<-out Parseshen.<rules>)))))) (shen.parse-failure))))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<name> (shen.<name> V6596) (if (shen.parse-failure? Parseshen.<name>) (shen.parse-failure) (let Parseshen.<rules> (shen.<rules> Parseshen.<name>) (if (shen.parse-failure? Parseshen.<rules>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<rules>) (shen.shendef->kldef-h (shen.<-out Parseshen.<name>) (shen.<-out Parseshen.<rules>))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.shendef->kldef-h (V6597 V6598) (let Ps (map (lambda X (fst X)) V6598) (let Arity (shen.arity-chk V6597 Ps) (let FreeVarChk (map (lambda R (shen.free-var-chk V6597 R)) V6598) (let Unprotect (shen.unprotect V6598) (let KL (shen.factorise-code (shen.compile-to-kl V6597 Unprotect Arity)) KL))))))

(defun shen.unprotect (V6599) (cond ((tuple? V6599) (@p (shen.unprotect (fst V6599)) (shen.unprotect (snd V6599)))) ((and (cons? V6599) (and (= protect (hd V6599)) (and (cons? (tl V6599)) (= () (tl (tl V6599)))))) (shen.unprotect (hd (tl V6599)))) ((cons? V6599) (map (lambda Z (shen.unprotect Z)) V6599)) (true V6599)))

(defun shen.<name> (V6600) (let Result (if (shen.non-empty-stream? V6600) (let X (shen.hds V6600) (let News6458 (shen.tls V6600) (shen.comb (shen.in-> News6458) (if (and (symbol? X) (not (variable? X))) X (simple-error (shen.app X " is not a legitimate function name.
" shen.a)))))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<signature> (V6601) (let Result (if (shen.non-empty-stream? V6601) (let X (shen.hds V6601) (let News6460 (shen.tls V6601) (let Parseshen.<signature> (shen.<signature> News6460) (if (shen.parse-failure? Parseshen.<signature>) (shen.parse-failure) (if (not (element? X (cons { (cons } ())))) (shen.comb (shen.in-> Parseshen.<signature>) (cons X (shen.<-out Parseshen.<signature>))) (shen.parse-failure)))))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V6601) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ()))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<rules> (V6602) (let Result (let Parseshen.<rule> (shen.<rule> V6602) (if (shen.parse-failure? Parseshen.<rule>) (shen.parse-failure) (let Parseshen.<rules> (shen.<rules> Parseshen.<rule>) (if (shen.parse-failure? Parseshen.<rules>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<rules>) (cons (shen.linearise (shen.<-out Parseshen.<rule>)) (shen.<-out Parseshen.<rules>))))))) (if (shen.parse-failure? Result) (let Result (let Parse<!> (<!> V6602) (if (shen.parse-failure? Parse<!>) (shen.parse-failure) (shen.comb (shen.in-> Parse<!>) (if (empty? (shen.<-out Parse<!>)) () (simple-error (cn "Shen syntax error here:
 " (shen.app (shen.<-out Parse<!>) "
 ..." shen.r))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.linearise (V6605) (cond ((tuple? V6605) (shen.linearise-h (fst V6605) (fst V6605) () (snd V6605))) (true (simple-error "implementation error in shen.linearise"))))

(defun shen.linearise-h (V6618 V6619 V6620 V6621) (cond ((= () V6618) (@p V6619 V6621)) ((and (cons? V6618) (cons? (hd V6618))) (shen.linearise-h (append (hd V6618) (tl V6618)) V6619 V6620 V6621)) ((and (cons? V6618) (variable? (hd V6618))) (if (element? (hd V6618) V6620) (let Z (gensym V) (shen.linearise-h (tl V6618) (shen.rep-X (hd V6618) Z V6619) V6620 (cons where (cons (cons = (cons Z (cons (hd V6618) ()))) (cons V6621 ()))))) (shen.linearise-h (tl V6618) V6619 (cons (hd V6618) V6620) V6621))) ((cons? V6618) (shen.linearise-h (tl V6618) V6619 V6620 V6621)) (true (simple-error "implementation error in shen.linearise-h"))))

(defun shen.<rule> (V6622) (let Result (let Parseshen.<patterns> (shen.<patterns> V6622) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> ->) (let News6463 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News6463) (let Action (shen.hds News6463) (let News6464 (shen.tls News6463) (if (shen.=hd? News6464 where) (let News6465 (shen.tls News6464) (if (shen.non-empty-stream? News6465) (let Guard (shen.hds News6465) (let News6466 (shen.tls News6465) (shen.comb (shen.in-> News6466) (@p (shen.<-out Parseshen.<patterns>) (cons where (cons Guard (cons Action ()))))))) (shen.parse-failure))) (shen.parse-failure)))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<patterns> (shen.<patterns> V6622) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> ->) (let News6467 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News6467) (let Action (shen.hds News6467) (let News6468 (shen.tls News6467) (shen.comb (shen.in-> News6468) (@p (shen.<-out Parseshen.<patterns>) Action)))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<patterns> (shen.<patterns> V6622) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> <-) (let News6469 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News6469) (let Action (shen.hds News6469) (let News6470 (shen.tls News6469) (if (shen.=hd? News6470 where) (let News6471 (shen.tls News6470) (if (shen.non-empty-stream? News6471) (let Guard (shen.hds News6471) (let News6472 (shen.tls News6471) (shen.comb (shen.in-> News6472) (@p (shen.<-out Parseshen.<patterns>) (cons where (cons Guard (cons (cons shen.choicepoint! (cons Action ())) ()))))))) (shen.parse-failure))) (shen.parse-failure)))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<patterns> (shen.<patterns> V6622) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> <-) (let News6473 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News6473) (let Action (shen.hds News6473) (let News6474 (shen.tls News6473) (shen.comb (shen.in-> News6474) (@p (shen.<-out Parseshen.<patterns>) (cons shen.choicepoint! (cons Action ())))))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)) Result)))

(defun shen.<patterns> (V6623) (let Result (let Parseshen.<pattern> (shen.<pattern> V6623) (if (shen.parse-failure? Parseshen.<pattern>) (shen.parse-failure) (let Parseshen.<patterns> (shen.<patterns> Parseshen.<pattern>) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<patterns>) (cons (shen.<-out Parseshen.<pattern>) (shen.<-out Parseshen.<patterns>))))))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V6623) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ()))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<pattern> (V6624) (let Result (if (shen.ccons? V6624) (let SynCons (shen.comb (shen.hds V6624) (shen.<-out V6624)) (let Parseshen.<constructor> (shen.<constructor> SynCons) (if (shen.parse-failure? Parseshen.<constructor>) (shen.parse-failure) (let Parseshen.<pattern1> (shen.<pattern1> Parseshen.<constructor>) (if (shen.parse-failure? Parseshen.<pattern1>) (shen.parse-failure) (let Parseshen.<pattern2> (shen.<pattern2> Parseshen.<pattern1>) (if (shen.parse-failure? Parseshen.<pattern2>) (shen.parse-failure) (let Parseshen.<end> (shen.<end> Parseshen.<pattern2>) (if (shen.parse-failure? Parseshen.<end>) (shen.parse-failure) (shen.comb (shen.in-> (shen.tlstream V6624)) (cons (shen.<-out Parseshen.<constructor>) (cons (shen.<-out Parseshen.<pattern1>) (cons (shen.<-out Parseshen.<pattern2>) ()))))))))))))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (if (shen.ccons? V6624) (let SynCons (shen.comb (shen.hds V6624) (shen.<-out V6624)) (if (shen.=hd? SynCons vector) (let News6477 (shen.tls SynCons) (if (shen.=hd? News6477 0) (let News6478 (shen.tls News6477) (let Parseshen.<end> (shen.<end> News6478) (if (shen.parse-failure? Parseshen.<end>) (shen.parse-failure) (shen.comb (shen.in-> (shen.tlstream V6624)) (cons vector (cons 0 ())))))) (shen.parse-failure))) (shen.parse-failure))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (if (shen.non-empty-stream? V6624) (let X (shen.hds V6624) (let News6479 (shen.tls V6624) (if (cons? X) (shen.comb (shen.in-> News6479) (shen.constructor-error X)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (let Parseshen.<simple-pattern> (shen.<simple-pattern> V6624) (if (shen.parse-failure? Parseshen.<simple-pattern>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<simple-pattern>) (shen.<-out Parseshen.<simple-pattern>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)) Result)))

(defun shen.<constructor> (V6625) (let Result (if (shen.non-empty-stream? V6625) (let C (shen.hds V6625) (let News6481 (shen.tls V6625) (if (shen.constructor? C) (shen.comb (shen.in-> News6481) C) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.constructor? (V6626) (element? V6626 (cons cons (cons @p (cons @s (cons @v ()))))))

(defun shen.constructor-error (V6627) (simple-error (shen.app V6627 " is not a legitimate constructor
" shen.r)))

(defun shen.<simple-pattern> (V6628) (let Result (if (shen.non-empty-stream? V6628) (let X (shen.hds V6628) (let News6483 (shen.tls V6628) (if (= X _) (shen.comb (shen.in-> News6483) (gensym Y)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (if (shen.non-empty-stream? V6628) (let X (shen.hds V6628) (let News6484 (shen.tls V6628) (if (not (element? X (cons -> (cons <- ())))) (shen.comb (shen.in-> News6484) X) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<pattern1> (V6629) (let Result (let Parseshen.<pattern> (shen.<pattern> V6629) (if (shen.parse-failure? Parseshen.<pattern>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<pattern>) (shen.<-out Parseshen.<pattern>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<pattern2> (V6630) (let Result (let Parseshen.<pattern> (shen.<pattern> V6630) (if (shen.parse-failure? Parseshen.<pattern>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<pattern>) (shen.<-out Parseshen.<pattern>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.fn-print (V6631) (let V (absvector 2) (let Print (address-> V 0 shen.printF) (let Named (address-> Print 1 (@s "(" (@s "f" (@s "n" (@s " " (@s (str V6631) ")")))))) Named))))

(defun shen.printF (V6632) (<-address V6632 1))

(defun shen.arity-chk (V6637 V6638) (cond ((and (cons? V6638) (= () (tl V6638))) (length (hd V6638))) ((and (cons? V6638) (and (cons? (tl V6638)) (= (length (hd V6638)) (length (hd (tl V6638)))))) (shen.arity-chk V6637 (tl V6638))) (true (simple-error (cn "arity error in " (shen.app V6637 "
" shen.a))))))

(defun shen.free-var-chk (V6639 V6640) (cond ((tuple? V6640) (shen.free-variable-error-message V6639 (shen.find-free-vars (shen.extract-vars (fst V6640)) (snd V6640)))) (true (shen.f-error shen.free-var-chk))))

(defun shen.free-variable-error-message (V6641 V6642) (if (empty? V6642) shen.skip (do (pr (cn "free variables in " (shen.app V6641 ":" shen.a)) (stoutput)) (do (map (lambda X (pr (cn " " (shen.app X "" shen.a)) (stoutput))) V6642) (do (nl 1) (abort))))))

(defun shen.extract-vars (V6645) (cond ((variable? V6645) (cons V6645 ())) ((cons? V6645) (union (shen.extract-vars (hd V6645)) (shen.extract-vars (tl V6645)))) (true ())))

(defun shen.find-free-vars (V6650 V6651) (cond ((and (cons? V6651) (and (= protect (hd V6651)) (and (cons? (tl V6651)) (= () (tl (tl V6651)))))) ()) ((and (cons? V6651) (and (= let (hd V6651)) (and (cons? (tl V6651)) (and (cons? (tl (tl V6651))) (and (cons? (tl (tl (tl V6651)))) (= () (tl (tl (tl (tl V6651)))))))))) (union (shen.find-free-vars V6650 (hd (tl (tl V6651)))) (shen.find-free-vars (cons (hd (tl V6651)) V6650) (hd (tl (tl (tl V6651))))))) ((and (cons? V6651) (and (= lambda (hd V6651)) (and (cons? (tl V6651)) (and (cons? (tl (tl V6651))) (= () (tl (tl (tl V6651)))))))) (shen.find-free-vars (cons (hd (tl V6651)) V6650) (hd (tl (tl V6651))))) ((cons? V6651) (union (shen.find-free-vars V6650 (hd V6651)) (shen.find-free-vars V6650 (tl V6651)))) ((shen.free-variable? V6651 V6650) (cons V6651 ())) (true ())))

(defun shen.free-variable? (V6652 V6653) (and (variable? V6652) (not (element? V6652 V6653))))

(defun shen.record-kl (V6654 V6655) (put V6654 shen.source V6655 (value *property-vector*)))

(defun shen.compile-to-kl (V6656 V6657 V6658) (let Parameters (shen.parameters V6658) (let Body (shen.scan-body V6656 (shen.kl-body V6657 Parameters)) (let Defun (cons defun (cons V6656 (cons Parameters (cons (shen.cond-form Body) ())))) Defun))))

(defun shen.parameters (V6659) (cond ((= 0 V6659) ()) (true (cons (gensym V) (shen.parameters (- V6659 1))))))

(defun shen.cond-form (V6662) (cond ((and (cons? V6662) (and (cons? (hd V6662)) (and (= true (hd (hd V6662))) (and (cons? (tl (hd V6662))) (= () (tl (tl (hd V6662)))))))) (hd (tl (hd V6662)))) (true (cons cond V6662))))

(defun shen.scan-body (V6671 V6672) (cond ((= () V6672) (cons (cons true (cons (cons shen.f-error (cons V6671 ())) ())) ())) ((and (cons? V6672) (shen.choicepoint? (hd V6672))) (shen.choicepoint V6671 (gensym Freeze) (gensym Result) (hd V6672) (tl V6672))) ((and (cons? V6672) (and (cons? (hd V6672)) (and (= true (hd (hd V6672))) (and (cons? (tl (hd V6672))) (= () (tl (tl (hd V6672)))))))) (cons (hd V6672) ())) ((cons? V6672) (cons (hd V6672) (shen.scan-body V6671 (tl V6672)))) (true (simple-error "implementation error in shen.scan-body"))))

(defun shen.choicepoint? (V6679) (cond ((and (cons? V6679) (and (cons? (tl V6679)) (and (cons? (hd (tl V6679))) (and (= shen.choicepoint! (hd (hd (tl V6679)))) (and (cons? (tl (hd (tl V6679)))) (and (= () (tl (tl (hd (tl V6679))))) (= () (tl (tl V6679))))))))) true) (true false)))

(defun shen.choicepoint (V6695 V6696 V6697 V6698 V6699) (cond ((and (cons? V6698) (and (cons? (tl V6698)) (and (cons? (hd (tl V6698))) (and (cons? (tl (hd (tl V6698)))) (and (cons? (hd (tl (hd (tl V6698))))) (and (= fail-if (hd (hd (tl (hd (tl V6698)))))) (and (cons? (tl (hd (tl (hd (tl V6698)))))) (and (cons? (tl (tl (hd (tl (hd (tl V6698))))))) (and (= () (tl (tl (tl (hd (tl (hd (tl V6698)))))))) (and (= () (tl (tl (hd (tl V6698))))) (and (= () (tl (tl V6698))) (= V6695 (hd (tl (hd (tl (hd (tl V6698)))))))))))))))))) (cons (cons true (cons (cons let (cons V6696 (cons (cons freeze (cons (cons cond (shen.scan-body (hd (tl (hd (tl (hd (tl V6698)))))) V6699)) ())) (cons (cons if (cons (hd V6698) (cons (cons let (cons V6697 (cons (hd (tl (tl (hd (tl (hd (tl V6698))))))) (cons (cons if (cons (cons (hd (tl (hd (tl (hd (tl V6698)))))) (cons V6697 ())) (cons (cons thaw (cons V6696 ())) (cons V6697 ())))) ())))) (cons (cons thaw (cons V6696 ())) ())))) ())))) ())) ())) ((and (cons? V6698) (and (cons? (tl V6698)) (and (cons? (hd (tl V6698))) (and (cons? (tl (hd (tl V6698)))) (and (= () (tl (tl (hd (tl V6698))))) (= () (tl (tl V6698)))))))) (cons (cons true (cons (cons let (cons V6696 (cons (cons freeze (cons (cons cond (shen.scan-body V6695 V6699)) ())) (cons (cons if (cons (hd V6698) (cons (cons let (cons V6697 (cons (hd (tl (hd (tl V6698)))) (cons (cons if (cons (cons = (cons V6697 (cons (cons fail ()) ()))) (cons (cons thaw (cons V6696 ())) (cons V6697 ())))) ())))) (cons (cons thaw (cons V6696 ())) ())))) ())))) ())) ())) (true (simple-error "implementation error in shen.choicepoint"))))

(defun shen.rep-X (V6701 V6702 V6703) (cond ((= V6701 V6703) V6702) ((cons? V6703) (let Rep (shen.rep-X V6701 V6702 (hd V6703)) (if (= Rep (hd V6703)) (cons (hd V6703) (shen.rep-X V6701 V6702 (tl V6703))) (cons Rep (tl V6703))))) (true V6703)))

(defun shen.kl-body (V6704 V6705) (map (lambda R (shen.triple-stack () (fst R) V6705 (shen.alpha-convert (snd R)))) V6704))

(defun shen.alpha-convert (V6706) (cond ((and (cons? V6706) (and (= lambda (hd V6706)) (and (cons? (tl V6706)) (and (cons? (tl (tl V6706))) (= () (tl (tl (tl V6706)))))))) (let NewV (gensym Z) (let Alpha (cons lambda (cons NewV (cons (shen.beta (hd (tl V6706)) NewV (hd (tl (tl V6706)))) ()))) (map (lambda Z (shen.alpha-convert Z)) Alpha)))) ((and (cons? V6706) (and (= let (hd V6706)) (and (cons? (tl V6706)) (and (cons? (tl (tl V6706))) (and (cons? (tl (tl (tl V6706)))) (= () (tl (tl (tl (tl V6706)))))))))) (let NewV (gensym W) (let Alpha (cons let (cons NewV (cons (hd (tl (tl V6706))) (cons (shen.beta (hd (tl V6706)) NewV (hd (tl (tl (tl V6706))))) ())))) (map (lambda Z (shen.alpha-convert Z)) Alpha)))) ((cons? V6706) (map (lambda Z (shen.alpha-convert Z)) V6706)) (true V6706)))

(defun shen.triple-stack (V6715 V6716 V6717 V6718) (cond ((and (= () V6716) (and (= () V6717) (and (cons? V6718) (and (= where (hd V6718)) (and (cons? (tl V6718)) (and (cons? (tl (tl V6718))) (= () (tl (tl (tl V6718)))))))))) (shen.triple-stack (cons (hd (tl V6718)) V6715) () () (hd (tl (tl V6718))))) ((and (= () V6716) (= () V6717)) (cons (shen.rectify-test (reverse V6715)) (cons V6718 ()))) ((and (cons? V6716) (and (cons? V6717) (variable? (hd V6716)))) (shen.triple-stack V6715 (tl V6716) (tl V6717) (shen.beta (hd V6716) (hd V6717) V6718))) ((and (cons? V6716) (and (cons? (hd V6716)) (and (cons? (tl (hd V6716))) (and (cons? (tl (tl (hd V6716)))) (and (= () (tl (tl (tl (hd V6716))))) (cons? V6717)))))) (shen.triple-stack (cons (cons (shen.op-test (hd (hd V6716))) (cons (hd V6717) ())) V6715) (cons (hd (tl (hd V6716))) (cons (hd (tl (tl (hd V6716)))) (tl V6716))) (cons (cons (shen.op1 (hd (hd V6716))) (cons (hd V6717) ())) (cons (cons (shen.op2 (hd (hd V6716))) (cons (hd V6717) ())) (tl V6717))) (shen.beta (hd V6716) (hd V6717) V6718))) ((and (cons? V6716) (cons? V6717)) (shen.triple-stack (cons (cons = (cons (hd V6716) (cons (hd V6717) ()))) V6715) (tl V6716) (tl V6717) V6718)) (true (simple-error "implementation error in shen.triple-stack"))))

(defun shen.rectify-test (V6721) (cond ((= () V6721) true) ((and (cons? V6721) (= () (tl V6721))) (hd V6721)) ((and (cons? V6721) (cons? (tl V6721))) (cons and (cons (hd V6721) (cons (shen.rectify-test (tl V6721)) ())))) (true (simple-error "implementation error in shen.rectify-test"))))

(defun shen.beta (V6731 V6732 V6733) (cond ((= V6731 V6733) V6732) ((and (cons? V6733) (and (= lambda (hd V6733)) (and (cons? (tl V6733)) (and (cons? (tl (tl V6733))) (and (= () (tl (tl (tl V6733)))) (= V6731 (hd (tl V6733)))))))) V6733) ((and (cons? V6733) (and (= let (hd V6733)) (and (cons? (tl V6733)) (and (cons? (tl (tl V6733))) (and (cons? (tl (tl (tl V6733)))) (and (= () (tl (tl (tl (tl V6733))))) (= V6731 (hd (tl V6733))))))))) (cons let (cons (hd (tl V6733)) (cons (shen.beta (hd (tl V6733)) V6732 (hd (tl (tl V6733)))) (tl (tl (tl V6733))))))) ((cons? V6733) (map (lambda V (shen.beta V6731 V6732 V)) V6733)) (true V6733)))

(defun shen.op1 (V6736) (cond ((= cons V6736) hd) ((= @s V6736) hdstr) ((= @p V6736) fst) ((= @v V6736) hdv) (true (simple-error "implementation error in shen.op1"))))

(defun shen.op2 (V6739) (cond ((= cons V6739) tl) ((= @s V6739) tlstr) ((= @p V6739) snd) ((= @v V6739) tlv) (true (simple-error "implementation error in shen.op2"))))

(defun shen.op-test (V6742) (cond ((= cons V6742) cons?) ((= @s V6742) shen.+string?) ((= @p V6742) tuple?) ((= @v V6742) shen.+vector?) (true (simple-error "implementation error in shen.op-test"))))

(defun shen.+string? (V6743) (cond ((= "" V6743) false) (true (string? V6743))))

(defun shen.+vector? (V6744) (cond ((= V6744 (vector 0)) false) (true (vector? V6744))))

(defun factorise (V6747) (cond ((= + V6747) (set shen.*factorise?* true)) ((= - V6747) (set shen.*factorise?* false)) (true (simple-error "factorise expects a + or a -
"))))

(defun shen.factorise-code (V6748) (cond ((and (cons? V6748) (and (= defun (hd V6748)) (and (cons? (tl V6748)) (and (cons? (tl (tl V6748))) (and (cons? (tl (tl (tl V6748)))) (and (cons? (hd (tl (tl (tl V6748))))) (and (= cond (hd (hd (tl (tl (tl V6748)))))) (and (= () (tl (tl (tl (tl V6748))))) (value shen.*factorise?*))))))))) (cons defun (cons (hd (tl V6748)) (cons (hd (tl (tl V6748))) (cons (shen.vertical (hd (tl (tl V6748))) (tl (hd (tl (tl (tl V6748))))) (cons shen.f-error (cons (hd (tl V6748)) ()))) ()))))) (true V6748)))

(defun shen.vertical (V6761 V6762 V6763) (cond ((and (cons? V6762) (and (cons? (hd V6762)) (and (= true (hd (hd V6762))) (and (cons? (tl (hd V6762))) (= () (tl (tl (hd V6762)))))))) (hd (tl (hd V6762)))) ((= () V6762) V6763) ((and (cons? V6762) (and (cons? (hd V6762)) (and (cons? (hd (hd V6762))) (and (= and (hd (hd (hd V6762)))) (and (cons? (tl (hd (hd V6762)))) (and (cons? (tl (tl (hd (hd V6762))))) (and (= () (tl (tl (tl (hd (hd V6762)))))) (and (cons? (tl (hd V6762))) (= () (tl (tl (hd V6762)))))))))))) (let Before+After (shen.split-cases (hd (tl (hd (hd V6762)))) V6762 ()) (shen.branch (hd (tl (hd (hd V6762)))) V6761 Before+After V6763))) ((and (cons? V6762) (and (cons? (hd V6762)) (and (cons? (tl (hd V6762))) (= () (tl (tl (hd V6762))))))) (cons if (cons (hd (hd V6762)) (cons (hd (tl (hd V6762))) (cons (shen.vertical V6761 (tl V6762) V6763) ()))))) (true (simple-error "implementation error in shen.vertical"))))

(defun shen.split-cases (V6768 V6769 V6770) (cond ((and (cons? V6769) (and (cons? (hd V6769)) (and (cons? (hd (hd V6769))) (and (= and (hd (hd (hd V6769)))) (and (cons? (tl (hd (hd V6769)))) (and (cons? (tl (tl (hd (hd V6769))))) (and (= () (tl (tl (tl (hd (hd V6769)))))) (and (cons? (tl (hd V6769))) (and (= () (tl (tl (hd V6769)))) (= V6768 (hd (tl (hd (hd V6769)))))))))))))) (shen.split-cases (hd (tl (hd (hd V6769)))) (tl V6769) (cons (cons (hd (tl (tl (hd (hd V6769))))) (tl (hd V6769))) V6770))) ((and (cons? V6769) (and (cons? (hd V6769)) (and (cons? (tl (hd V6769))) (and (= () (tl (tl (hd V6769)))) (= V6768 (hd (hd V6769))))))) (shen.split-cases (hd (hd V6769)) (tl V6769) (cons (cons true (tl (hd V6769))) V6770))) (true (cons (reverse V6770) (cons V6769 ())))))

(defun shen.branch (V6771 V6772 V6773 V6774) (cond ((and (cons? V6773) (and (cons? (tl V6773)) (= () (tl (tl V6773))))) (let Else (shen.else V6772 (hd (tl V6773)) V6774) (let Then (shen.then V6771 V6772 (hd V6773) Else) (cons if (cons V6771 (cons Then (cons Else ()))))))) (true (shen.f-error shen.branch))))

(defun shen.else (V6775 V6776 V6777) (let Else (shen.vertical V6775 V6776 V6777) (if (shen.inline? Else) Else (shen.procedure-call V6775 Else))))

(defun shen.procedure-call (V6778 V6779) (let F (gensym shen.else) (let Used (shen.remove-if-unused V6778 V6779) (let KL (cons defun (cons F (cons Used (cons V6779 ())))) (let EvalKL (eval-kl KL) (let Record (shen.record-kl F KL) (cons F Used)))))))

(defun shen.remove-if-unused (V6786 V6787) (cond ((= () V6786) ()) ((cons? V6786) (if (shen.occurs? (hd V6786) V6787) (cons (hd V6786) (shen.remove-if-unused (tl V6786) V6787)) (shen.remove-if-unused (tl V6786) V6787))) (true (simple-error "implementation error in shen.remove-if-unused"))))

(defun shen.then (V6788 V6789 V6790 V6791) (shen.horizontal (shen.selectors V6788 V6790) V6789 V6790 V6791))

(defun shen.horizontal (V6800 V6801 V6802 V6803) (cond ((= () V6800) (shen.vertical V6801 V6802 V6803)) ((cons? V6800) (let V (gensym V) (cons let (cons V (cons (hd V6800) (cons (shen.horizontal (tl V6800) (cons V V6801) (subst V (hd V6800) V6802) V6803) ())))))) (true (simple-error "implementation error in shen.horizontal"))))

(defun shen.selectors (V6808 V6809) (cond ((and (cons? V6808) (and (cons? (tl V6808)) (and (= () (tl (tl V6808))) (shen.constructor? (shen.op (hd V6808)))))) (let Op (shen.op (hd V6808)) (let Hd (cons (shen.op1 Op) (tl V6808)) (let Tl (cons (shen.op2 Op) (tl V6808)) (let RptedHd? (shen.rpted? Hd V6809) (let RptedTl? (shen.rpted? Tl V6809) (if (and RptedHd? RptedTl?) (cons Hd (cons Tl ())) (if RptedHd? (cons Hd ()) (if RptedTl? (cons Tl ()) ()))))))))) (true ())))

(defun shen.rpted? (V6810 V6811) (> (occurrences V6810 V6811) 1))

(defun shen.inline? (V6812) (cond ((cons? V6812) (and (atom? (hd V6812)) (shen.inline? (tl V6812)))) (true (atom? V6812))))

(defun shen.op (V6815) (cond ((= cons? V6815) cons) ((= shen.+string? V6815) @s) ((= shen.+vector? V6815) @v) ((= tuple? V6815) @p) (true shen.skip)))

