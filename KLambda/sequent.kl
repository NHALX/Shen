(defun shen.<datatype> (V8240) (let Result (if (shen.non-empty-stream? V8240) (let D (shen.hds V8240) (let News8101 (shen.tls V8240) (let Parseshen.<datatype-rules> (shen.<datatype-rules> News8101) (if (shen.parse-failure? Parseshen.<datatype-rules>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<datatype-rules>) (let Prolog (shen.rules->prolog D (shen.<-out Parseshen.<datatype-rules>)) (shen.remember-datatype D (fn D)))))))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<datatype-rules> (V8241) (let Result (let Parseshen.<datatype-rule> (shen.<datatype-rule> V8241) (if (shen.parse-failure? Parseshen.<datatype-rule>) (shen.parse-failure) (let Parseshen.<datatype-rules> (shen.<datatype-rules> Parseshen.<datatype-rule>) (if (shen.parse-failure? Parseshen.<datatype-rules>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<datatype-rules>) (append (shen.<-out Parseshen.<datatype-rule>) (shen.<-out Parseshen.<datatype-rules>))))))) (if (shen.parse-failure? Result) (let Result (let Parse<!> (<!> V8241) (if (shen.parse-failure? Parse<!>) (shen.parse-failure) (shen.comb (shen.in-> Parse<!>) (if (empty? (shen.<-out Parse<!>)) () (simple-error (cn "datatype syntax error here:
 " (shen.app (shen.<-out Parse<!>) "
 ..." shen.r))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<datatype-rule> (V8242) (let Result (let Parseshen.<single> (shen.<single> V8242) (if (shen.parse-failure? Parseshen.<single>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<single>) (shen.<-out Parseshen.<single>)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<double> (shen.<double> V8242) (if (shen.parse-failure? Parseshen.<double>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<double>) (shen.<-out Parseshen.<double>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<single> (V8243) (let Result (let Parseshen.<sides> (shen.<sides> V8243) (if (shen.parse-failure? Parseshen.<sides>) (shen.parse-failure) (let Parseshen.<prems> (shen.<prems> Parseshen.<sides>) (if (shen.parse-failure? Parseshen.<prems>) (shen.parse-failure) (let Parseshen.<sng> (shen.<sng> Parseshen.<prems>) (if (shen.parse-failure? Parseshen.<sng>) (shen.parse-failure) (let Parseshen.<conc> (shen.<conc> Parseshen.<sng>) (if (shen.parse-failure? Parseshen.<conc>) (shen.parse-failure) (let Parseshen.<sc> (shen.<sc> Parseshen.<conc>) (if (shen.parse-failure? Parseshen.<sc>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<sc>) (cons (cons (shen.<-out Parseshen.<sides>) (cons (shen.<-out Parseshen.<prems>) (cons (shen.<-out Parseshen.<conc>) ()))) ())))))))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<double> (V8244) (let Result (let Parseshen.<sides> (shen.<sides> V8244) (if (shen.parse-failure? Parseshen.<sides>) (shen.parse-failure) (let Parseshen.<formulae> (shen.<formulae> Parseshen.<sides>) (if (shen.parse-failure? Parseshen.<formulae>) (shen.parse-failure) (let Parseshen.<dbl> (shen.<dbl> Parseshen.<formulae>) (if (shen.parse-failure? Parseshen.<dbl>) (shen.parse-failure) (let Parseshen.<formula> (shen.<formula> Parseshen.<dbl>) (if (shen.parse-failure? Parseshen.<formula>) (shen.parse-failure) (let Parseshen.<sc> (shen.<sc> Parseshen.<formula>) (if (shen.parse-failure? Parseshen.<sc>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<sc>) (shen.lr-rule (shen.<-out Parseshen.<sides>) (shen.<-out Parseshen.<formulae>) (cons () (cons (shen.<-out Parseshen.<formula>) ())))))))))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<formulae> (V8245) (let Result (let Parseshen.<formula> (shen.<formula> V8245) (if (shen.parse-failure? Parseshen.<formula>) (shen.parse-failure) (let Parseshen.<sc> (shen.<sc> Parseshen.<formula>) (if (shen.parse-failure? Parseshen.<sc>) (shen.parse-failure) (let Parseshen.<formulae> (shen.<formulae> Parseshen.<sc>) (if (shen.parse-failure? Parseshen.<formulae>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<formulae>) (cons (cons () (cons (shen.<-out Parseshen.<formula>) ())) (shen.<-out Parseshen.<formulae>))))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<formula> (shen.<formula> V8245) (if (shen.parse-failure? Parseshen.<formula>) (shen.parse-failure) (let Parseshen.<sc> (shen.<sc> Parseshen.<formula>) (if (shen.parse-failure? Parseshen.<sc>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<sc>) (cons (cons () (cons (shen.<-out Parseshen.<formula>) ())) ())))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<conc> (V8246) (let Result (let Parseshen.<ass> (shen.<ass> V8246) (if (shen.parse-failure? Parseshen.<ass>) (shen.parse-failure) (if (shen.=hd? Parseshen.<ass> >>) (let News8108 (shen.tls Parseshen.<ass>) (let Parseshen.<formula> (shen.<formula> News8108) (if (shen.parse-failure? Parseshen.<formula>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<formula>) (cons (shen.<-out Parseshen.<ass>) (cons (shen.<-out Parseshen.<formula>) ())))))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<formula> (shen.<formula> V8246) (if (shen.parse-failure? Parseshen.<formula>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<formula>) (cons () (cons (shen.<-out Parseshen.<formula>) ()))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<prems> (V8247) (let Result (let Parseshen.<prem> (shen.<prem> V8247) (if (shen.parse-failure? Parseshen.<prem>) (shen.parse-failure) (let Parseshen.<sc> (shen.<sc> Parseshen.<prem>) (if (shen.parse-failure? Parseshen.<sc>) (shen.parse-failure) (let Parseshen.<prems> (shen.<prems> Parseshen.<sc>) (if (shen.parse-failure? Parseshen.<prems>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<prems>) (cons (shen.<-out Parseshen.<prem>) (shen.<-out Parseshen.<prems>))))))))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V8247) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ()))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<prem> (V8248) (let Result (if (shen.=hd? V8248 !) (let News8111 (shen.tls V8248) (shen.comb (shen.in-> News8111) !)) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (let Parseshen.<ass> (shen.<ass> V8248) (if (shen.parse-failure? Parseshen.<ass>) (shen.parse-failure) (if (shen.=hd? Parseshen.<ass> >>) (let News8112 (shen.tls Parseshen.<ass>) (let Parseshen.<formula> (shen.<formula> News8112) (if (shen.parse-failure? Parseshen.<formula>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<formula>) (cons (shen.<-out Parseshen.<ass>) (cons (shen.<-out Parseshen.<formula>) ())))))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<formula> (shen.<formula> V8248) (if (shen.parse-failure? Parseshen.<formula>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<formula>) (cons () (cons (shen.<-out Parseshen.<formula>) ()))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)))

(defun shen.<ass> (V8249) (let Result (let Parseshen.<formula> (shen.<formula> V8249) (if (shen.parse-failure? Parseshen.<formula>) (shen.parse-failure) (let Parseshen.<iscomma> (shen.<iscomma> Parseshen.<formula>) (if (shen.parse-failure? Parseshen.<iscomma>) (shen.parse-failure) (let Parseshen.<ass> (shen.<ass> Parseshen.<iscomma>) (if (shen.parse-failure? Parseshen.<ass>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<ass>) (cons (shen.<-out Parseshen.<formula>) (shen.<-out Parseshen.<ass>))))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<formula> (shen.<formula> V8249) (if (shen.parse-failure? Parseshen.<formula>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<formula>) (cons (shen.<-out Parseshen.<formula>) ())))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V8249) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ()))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)))

(defun shen.<iscomma> (V8250) (let Result (if (shen.non-empty-stream? V8250) (let X (shen.hds V8250) (let News8115 (shen.tls V8250) (if (= X (intern ",")) (shen.comb (shen.in-> News8115) shen.skip) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<formula> (V8251) (let Result (let Parseshen.<expr> (shen.<expr> V8251) (if (shen.parse-failure? Parseshen.<expr>) (shen.parse-failure) (let Parseshen.<iscolon> (shen.<iscolon> Parseshen.<expr>) (if (shen.parse-failure? Parseshen.<iscolon>) (shen.parse-failure) (let Parseshen.<type> (shen.<type> Parseshen.<iscolon>) (if (shen.parse-failure? Parseshen.<type>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<type>) (cons (shen.curry (shen.<-out Parseshen.<expr>)) (cons (intern ":") (cons (shen.rectify-type (shen.<-out Parseshen.<type>)) ())))))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<expr> (shen.<expr> V8251) (if (shen.parse-failure? Parseshen.<expr>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<expr>) (shen.<-out Parseshen.<expr>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<iscolon> (V8252) (let Result (if (shen.non-empty-stream? V8252) (let X (shen.hds V8252) (let News8118 (shen.tls V8252) (if (= X (intern ":")) (shen.comb (shen.in-> News8118) shen.skip) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<sides> (V8253) (let Result (let Parseshen.<side> (shen.<side> V8253) (if (shen.parse-failure? Parseshen.<side>) (shen.parse-failure) (let Parseshen.<sides> (shen.<sides> Parseshen.<side>) (if (shen.parse-failure? Parseshen.<sides>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<sides>) (cons (shen.<-out Parseshen.<side>) (shen.<-out Parseshen.<sides>))))))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V8253) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ()))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<side> (V8254) (let Result (if (shen.=hd? V8254 if) (let News8121 (shen.tls V8254) (if (shen.non-empty-stream? News8121) (let P (shen.hds News8121) (let News8122 (shen.tls News8121) (shen.comb (shen.in-> News8122) (cons if (cons P ()))))) (shen.parse-failure))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (if (shen.=hd? V8254 let) (let News8123 (shen.tls V8254) (if (shen.non-empty-stream? News8123) (let X (shen.hds News8123) (let News8124 (shen.tls News8123) (if (shen.non-empty-stream? News8124) (let Y (shen.hds News8124) (let News8125 (shen.tls News8124) (shen.comb (shen.in-> News8125) (cons let (cons X (cons Y ())))))) (shen.parse-failure)))) (shen.parse-failure))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (if (shen.=hd? V8254 shen.let!) (let News8126 (shen.tls V8254) (if (shen.non-empty-stream? News8126) (let X (shen.hds News8126) (let News8127 (shen.tls News8126) (if (shen.non-empty-stream? News8127) (let Y (shen.hds News8127) (let News8128 (shen.tls News8127) (shen.comb (shen.in-> News8128) (cons shen.let! (cons X (cons Y ())))))) (shen.parse-failure)))) (shen.parse-failure))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)))

(defun shen.lr-rule (V8261 V8262 V8263) (cond ((and (cons? V8263) (and (= () (hd V8263)) (and (cons? (tl V8263)) (= () (tl (tl V8263)))))) (let P (gensym P) (let LConc (cons (tl V8263) (cons P ())) (let LPrem (cons (shen.coll-formulae V8262) (cons P ())) (let Left (cons V8261 (cons (cons LPrem ()) (cons LConc ()))) (let Right (cons V8261 (cons V8262 (cons V8263 ()))) (cons Right (cons Left ())))))))) (true (simple-error "implementation error in shen.lr-rule"))))

(defun shen.coll-formulae (V8266) (cond ((= () V8266) ()) ((and (cons? V8266) (and (cons? (hd V8266)) (and (= () (hd (hd V8266))) (and (cons? (tl (hd V8266))) (= () (tl (tl (hd V8266)))))))) (cons (hd (tl (hd V8266))) (shen.coll-formulae (tl V8266)))) (true (simple-error "implementation error in shen.coll-formulae"))))

(defun shen.<expr> (V8267) (let Result (if (shen.non-empty-stream? V8267) (let X (shen.hds V8267) (let News8130 (shen.tls V8267) (if (not (shen.key-in-sequent-calculus? X)) (shen.comb (shen.in-> News8130) (macroexpand X)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.key-in-sequent-calculus? (V8268) (or (element? V8268 (cons >> (cons (intern ";") (cons (intern ",") (cons (intern ":") (cons <-- ())))))) (or (shen.sng? V8268) (shen.dbl? V8268))))

(defun shen.<type> (V8269) (let Result (let Parseshen.<expr> (shen.<expr> V8269) (if (shen.parse-failure? Parseshen.<expr>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<expr>) (shen.<-out Parseshen.<expr>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<dbl> (V8270) (let Result (if (shen.non-empty-stream? V8270) (let X (shen.hds V8270) (let News8133 (shen.tls V8270) (if (shen.dbl? X) (shen.comb (shen.in-> News8133) X) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<sng> (V8271) (let Result (if (shen.non-empty-stream? V8271) (let X (shen.hds V8271) (let News8135 (shen.tls V8271) (if (shen.sng? X) (shen.comb (shen.in-> News8135) X) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.sng? (V8272) (and (symbol? V8272) (shen.sng-h? (str V8272))))

(defun shen.sng-h? (V8275) (cond ((= "___" V8275) true) ((and (shen.+string? V8275) (= "_" (hdstr V8275))) (shen.sng-h? (tlstr V8275))) (true false)))

(defun shen.dbl? (V8276) (and (symbol? V8276) (shen.dbl-h? (str V8276))))

(defun shen.dbl-h? (V8279) (cond ((= "===" V8279) true) ((and (shen.+string? V8279) (= "=" (hdstr V8279))) (shen.dbl-h? (tlstr V8279))) (true false)))

(defun shen.remember-datatype (V8280 V8281) (do (set shen.*datatypes* (shen.assoc-> V8280 V8281 (value shen.*datatypes*))) (do (set shen.*alldatatypes* (shen.assoc-> V8280 V8281 (value shen.*alldatatypes*))) V8280)))

(defun shen.rules->prolog (V8282 V8283) (let Clauses (mapcan (lambda Rule (shen.rule->clause Rule)) V8283) (eval (cons defprolog (cons V8282 Clauses)))))

(defun shen.rule->clause (V8286) (cond ((and (cons? V8286) (and (cons? (tl V8286)) (and (cons? (tl (tl V8286))) (and (cons? (hd (tl (tl V8286)))) (and (cons? (tl (hd (tl (tl V8286))))) (and (= () (tl (tl (hd (tl (tl V8286)))))) (= () (tl (tl (tl V8286)))))))))) (let Constraints (shen.extract-vars V8286) (let HypVs (append (shen.nvars (length (hd (hd (tl (tl V8286)))))) (cons Delta ())) (let Active (shen.extract-vars (hd (tl (hd (tl (tl V8286)))))) (let Head (shen.compile-consequent (hd (tl (hd (tl (tl V8286))))) HypVs) (let Goals (shen.goals Constraints (hd (hd (tl (tl V8286)))) (hd V8286) (hd (tl V8286)) HypVs Active) (append Head (append (cons <-- ()) (append Goals (cons (intern ";") ())))))))))) (true (simple-error "implementation error in shen.rule->clause"))))

(defun shen.compile-consequent (V8293 V8294) (cond ((cons? V8294) (cons (shen.optimise-typing V8293) (cons (hd V8294) ()))) (true (simple-error "implementation error in shen.compile-consequent"))))

(defun shen.nvars (V8295) (cond ((= 0 V8295) ()) (true (cons (gensym V) (shen.nvars (- V8295 1))))))

(defun shen.optimise-typing (V8296) (cond ((and (cons? V8296) (and (cons? (tl V8296)) (and (cons? (tl (tl V8296))) (and (= () (tl (tl (tl V8296)))) (= (hd (tl V8296)) (intern ":")))))) (cons - (cons (shen.cons-form-with-modes (cons (hd V8296) (cons (hd (tl V8296)) (cons (cons + (tl (tl V8296))) ())))) ()))) (true (cons + (cons (shen.cons-form-with-modes V8296) ())))))

(defun shen.cons-form-with-modes (V8297) (cond ((and (cons? V8297) (and (= - (hd V8297)) (and (cons? (tl V8297)) (= () (tl (tl V8297)))))) (cons - (cons (shen.cons-form-with-modes (hd (tl V8297))) ()))) ((and (cons? V8297) (and (= + (hd V8297)) (and (cons? (tl V8297)) (= () (tl (tl V8297)))))) (cons + (cons (shen.cons-form-with-modes (hd (tl V8297))) ()))) ((and (cons? V8297) (and (= mode (hd V8297)) (and (cons? (tl V8297)) (and (cons? (tl (tl V8297))) (= () (tl (tl (tl V8297)))))))) (cons (hd (tl (tl V8297))) (cons (shen.cons-form-with-modes (hd (tl V8297))) ()))) ((and (cons? V8297) (and (= bar! (hd V8297)) (and (cons? (tl V8297)) (= () (tl (tl V8297)))))) (hd (tl V8297))) ((cons? V8297) (cons cons (cons (shen.cons-form-with-modes (hd V8297)) (cons (shen.cons-form-with-modes (tl V8297)) ())))) (true V8297)))

(defun shen.goals (V8298 V8299 V8300 V8301 V8302 V8303) (let GoalsAs (shen.compile-assumptions V8299 V8298 V8302 V8303) (let GoalsS (shen.compile-side-conditions V8300) (let GoalsP (shen.compile-premises V8301 V8302) (append GoalsAs (append GoalsS GoalsP))))))

(defun shen.compile-assumptions (V8318 V8319 V8320 V8321) (cond ((= () V8318) ()) ((and (cons? V8318) (and (cons? V8320) (cons? (tl V8320)))) (let NewActive (append (shen.extract-vars (hd V8318)) V8321) (cons (shen.compile-assumption (hd V8318) (hd V8320) (hd (tl V8320)) V8319 V8321) (shen.compile-assumptions (tl V8318) V8319 (tl V8320) NewActive)))) (true (simple-error "implementation error in shen.compile-assumptions"))))

(defun shen.compile-assumption (V8322 V8323 V8324 V8325 V8326) (let F (gensym shen.search) (let Compile (shen.compile-search-procedure F V8322 V8323 V8324 V8325 V8326) (cons F (cons V8323 (cons () (cons V8324 V8325)))))))

(defun shen.compile-search-procedure (V8327 V8328 V8329 V8330 V8331 V8332) (let Past (gensym Previous) (let Base (shen.foundit! V8328 V8329 Past V8330 V8331 V8332) (let Recursive (shen.keep-looking V8327 V8329 Past V8330 V8331) (eval (cons defprolog (cons V8327 (append Base Recursive))))))))

(defun shen.foundit! (V8333 V8334 V8335 V8336 V8337 V8338) (let Passive (shen.passive V8333 V8338) (let Table (shen.tabulate-passive Passive) (let Head (shen.head-foundit! V8333 V8334 V8335 V8336 V8337 Table) (let Body (shen.body-foundit! V8334 V8335 V8336 Table) (append Head (append (cons <-- ()) (append Body (cons (intern ";") ())))))))))

(defun shen.keep-looking (V8339 V8340 V8341 V8342 V8343) (let X (gensym V) (let Head (cons (cons - (cons (cons cons (cons X (cons V8340 ()))) ())) (cons V8341 (cons V8342 V8343))) (let Body (cons (cons V8339 (cons V8340 (cons (cons cons (cons X (cons V8341 ()))) (cons V8342 V8343)))) ()) (append Head (append (cons <-- ()) (append Body (cons (intern ";") ()))))))))

(defun shen.passive (V8348 V8349) (cond ((cons? V8348) (union (shen.passive (hd V8348) V8349) (shen.passive (tl V8348) V8349))) ((shen.passive? V8348 V8349) (cons V8348 ())) (true ())))

(defun shen.passive? (V8350 V8351) (and (not (element? V8350 V8351)) (variable? V8350)))

(defun shen.tabulate-passive (V8352) (map (lambda X (cons X (gensym V))) V8352))

(defun shen.head-foundit! (V8353 V8354 V8355 V8356 V8357 V8358) (let Optimise (shen.optimise-passive V8357 V8358) (cons (cons - (cons (cons cons (cons (shen.optimise-typing V8353) (cons V8354 ()))) ())) (cons V8355 (cons V8356 Optimise)))))

(defun shen.optimise-passive (V8359 V8360) (map (lambda C (shen.optimise-passive-h C V8360)) V8359))

(defun shen.optimise-passive-h (V8361 V8362) (let Entry (assoc V8361 V8362) (if (empty? Entry) V8361 (tl Entry))))

(defun shen.body-foundit! (V8371 V8372 V8373 V8374) (cond ((= () V8374) (cons (cons bind (cons V8373 (cons (cons append (cons (cons 1 (cons V8372 ())) (cons (cons 1 (cons V8371 ())) ()))) ()))) ())) ((and (cons? V8374) (cons? (hd V8374))) (cons (cons bind (cons (tl (hd V8374)) (cons (hd (hd V8374)) ()))) (shen.body-foundit! V8371 V8372 V8373 (tl V8374)))) (true (simple-error "implementation error in shen.body-foundit!"))))

(defun shen.compile-side-conditions (V8375) (map (lambda X (shen.compile-side-condition X)) V8375))

(defun shen.compile-side-condition (V8378) (cond ((and (cons? V8378) (and (= let (hd V8378)) (and (cons? (tl V8378)) (and (cons? (tl (tl V8378))) (= () (tl (tl (tl V8378)))))))) (cons is (tl V8378))) ((and (cons? V8378) (and (= shen.let! (hd V8378)) (and (cons? (tl V8378)) (and (cons? (tl (tl V8378))) (= () (tl (tl (tl V8378)))))))) (cons is! (tl V8378))) ((and (cons? V8378) (and (= if (hd V8378)) (and (cons? (tl V8378)) (= () (tl (tl V8378)))))) (cons when (tl V8378))) (true (simple-error "implementation error in shen.compile-side-condition"))))

(defun shen.compile-premises (V8379 V8380) (let Hyp (hd (reverse V8380)) (map (lambda X (shen.compile-premise X Hyp)) V8379)))

(defun shen.compile-premise (V8387 V8388) (cond ((= ! V8387) !) ((and (cons? V8387) (and (cons? (tl V8387)) (= () (tl (tl V8387))))) (shen.compile-premise-h (reverse (hd V8387)) (hd (tl V8387)) V8388)) (true (simple-error "implementation error in shen.premise"))))

(defun shen.compile-premise-h (V8395 V8396 V8397) (cond ((= () V8395) (cons shen.system-S (cons (shen.cons-form-no-modes V8396) (cons V8397 ())))) ((cons? V8395) (shen.compile-premise-h (tl V8395) V8396 (cons cons (cons (shen.cons-form-no-modes (hd V8395)) (cons V8397 ()))))) (true (simple-error "implementation error in shen.compile-premise-h"))))

(defun shen.cons-form-no-modes (V8398) (cond ((and (cons? V8398) (and (= bar! (hd V8398)) (and (cons? (tl V8398)) (= () (tl (tl V8398)))))) (hd (tl V8398))) ((cons? V8398) (cons cons (cons (shen.cons-form-no-modes (hd V8398)) (cons (shen.cons-form-no-modes (tl V8398)) ())))) (true V8398)))

(defun preclude (V8399) (let InternTypes (map (lambda X (shen.intern-type X)) V8399) (let Datatypes (value shen.*datatypes*) (let Remove (shen.remove-datatypes InternTypes Datatypes) (let NewDatatypes (set shen.*datatypes* Remove) (shen.show-datatypes NewDatatypes))))))

(defun shen.remove-datatypes (V8404 V8405) (cond ((= () V8404) V8405) ((cons? V8404) (shen.remove-datatypes (tl V8404) (shen.unassoc (hd V8404) V8405))) (true (simple-error "implementation error in shen.remove-datatypes"))))

(defun shen.unassoc (V8415 V8416) (cond ((= () V8416) ()) ((and (cons? V8416) (and (cons? (hd V8416)) (= V8415 (hd (hd V8416))))) (tl V8416)) ((cons? V8416) (cons (hd V8416) (shen.unassoc V8415 (tl V8416)))) (true (simple-error "implementation error in shen.unassoc"))))

(defun shen.show-datatypes (V8417) (map (lambda X (hd X)) V8417))

(defun include (V8418) (let InternTypes (map (lambda X (shen.intern-type X)) V8418) (let Remember (map (lambda D (shen.remember-datatype D (fn D))) InternTypes) (let Datatypes (value shen.*datatypes*) (shen.show-datatypes Datatypes)))))

(defun preclude-all-but (V8419) (let Initialise (set shen.*datatypes* ()) (let InternTypes (map (lambda X (shen.intern-type X)) V8419) (let NewDatatypes (map (lambda D (shen.remember-datatype D (fn D))) InternTypes) (shen.show-datatypes (value shen.*datatypes*))))))

(defun include-all-but (V8420) (let InternTypes (map (lambda X (shen.intern-type X)) V8420) (let AllDatatypes (value shen.*alldatatypes*) (let Datatypes (set shen.*datatypes* (shen.remove-datatypes InternTypes AllDatatypes)) (shen.show-datatypes Datatypes)))))

